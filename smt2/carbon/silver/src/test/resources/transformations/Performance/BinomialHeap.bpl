// 
// Translation of Viper program.
// 
// Date:         2025-01-26 21:44:32
// Tool:         carbon 1.0
// Arguments: :  --disableCaching --boogieExe /home/runner/.dotnet/tools/boogie --timeout 10 --print /home/runner/work/smt-logs/smt-logs/carbon/../smt2/carbon/silver/src/test/resources/transformations/Performance/BinomialHeap.bpl --boogieOpt /proverLog:/home/runner/work/smt-logs/smt-logs/carbon/../smt2/carbon/silver/src/test/resources/transformations/Performance/BinomialHeap-@PROC@.smt2 --ignoreFile dummy-file-to-prevent-cli-parser-from-complaining-about-missing-file-name.silver
// Dependencies:
//   Boogie , located at /home/runner/.dotnet/tools/boogie.
//   Z3 4.12.1 - 64 bit, located at /opt/hostedtoolcache/z3/4.12.1/x64/z3-4.12.1-x64-glibc-2.35/bin/z3.
// 

// ==================================================
// Preamble of State module.
// ==================================================

function  state(Heap: HeapType, Mask: MaskType): bool;
axiom state(dummyHeap, ZeroMask);

// ==================================================
// Preamble of Heap module.
// ==================================================

type Ref;
var Heap: HeapType;
const null: Ref;
type Field A B;
type NormalField;
const dummyHeap: HeapType;
type HeapType = <A, B> [Ref, Field A B]B;
const unique $allocated: Field NormalField bool;
axiom (forall o_152: Ref, f_160: (Field NormalField Ref), Heap: HeapType ::
  { Heap[o_152, f_160] }
  Heap[o_152, $allocated] ==> Heap[Heap[o_152, f_160], $allocated]
);
function  succHeap(Heap0: HeapType, Heap1: HeapType): bool;
function  succHeapTrans(Heap0: HeapType, Heap1: HeapType): bool;
function  IdenticalOnKnownLocations(Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType): bool;
function  IsPredicateField<A, B>(f_1: (Field A B)): bool;
function  IsWandField<A, B>(f_1: (Field A B)): bool;
function  getPredWandId<A, B>(f_1: (Field A B)): int;
// Frame all locations with direct permissions
axiom (forall <A, B> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, o_153: Ref, f_161: (Field A B) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), ExhaleHeap[o_153, f_161] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, o_153, f_161) ==> Heap[o_153, f_161] == ExhaleHeap[o_153, f_161]
);
// Frame all predicate mask locations of predicates with direct permission
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_58: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsPredicateField(pm_f_58), ExhaleHeap[null, PredicateMaskField(pm_f_58)] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_58) && IsPredicateField(pm_f_58) ==> Heap[null, PredicateMaskField(pm_f_58)] == ExhaleHeap[null, PredicateMaskField(pm_f_58)]
);
// Frame all locations with known folded permissions
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_58: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsPredicateField(pm_f_58) }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_58) && IsPredicateField(pm_f_58) ==> (forall <A, B> o2_59: Ref, f_161: (Field A B) ::
    { ExhaleHeap[o2_59, f_161] }
    Heap[null, PredicateMaskField(pm_f_58)][o2_59, f_161] ==> Heap[o2_59, f_161] == ExhaleHeap[o2_59, f_161]
  )
);
// Frame all wand mask locations of wands with direct permission
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_58: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsWandField(pm_f_58), ExhaleHeap[null, WandMaskField(pm_f_58)] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_58) && IsWandField(pm_f_58) ==> Heap[null, WandMaskField(pm_f_58)] == ExhaleHeap[null, WandMaskField(pm_f_58)]
);
// Frame all locations in the footprint of magic wands
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_58: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsWandField(pm_f_58) }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_58) && IsWandField(pm_f_58) ==> (forall <A, B> o2_59: Ref, f_161: (Field A B) ::
    { ExhaleHeap[o2_59, f_161] }
    Heap[null, WandMaskField(pm_f_58)][o2_59, f_161] ==> Heap[o2_59, f_161] == ExhaleHeap[o2_59, f_161]
  )
);
// All previously-allocated references are still allocated
axiom (forall Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, o_153: Ref ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), ExhaleHeap[o_153, $allocated] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> Heap[o_153, $allocated] ==> ExhaleHeap[o_153, $allocated]
);
// Updated Heaps are Successor Heaps
axiom (forall <A, B> Heap: HeapType, o_152: Ref, f_162: (Field A B), v: B ::
  { Heap[o_152, f_162:=v] }
  succHeap(Heap, Heap[o_152, f_162:=v])
);
// IdenticalOnKnownLocations Heaps are Successor Heaps
axiom (forall Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> succHeap(Heap, ExhaleHeap)
);
// Successor Heaps are Transitive Successor Heaps
axiom (forall Heap0: HeapType, Heap1: HeapType ::
  { succHeap(Heap0, Heap1) }
  succHeap(Heap0, Heap1) ==> succHeapTrans(Heap0, Heap1)
);
// Transitivity of Transitive Successor Heaps
axiom (forall Heap0: HeapType, Heap1: HeapType, Heap2: HeapType ::
  { succHeapTrans(Heap0, Heap1), succHeap(Heap1, Heap2) }
  succHeapTrans(Heap0, Heap1) && succHeap(Heap1, Heap2) ==> succHeapTrans(Heap0, Heap2)
);

// ==================================================
// Preamble of Permission module.
// ==================================================

type Perm = real;
type MaskType = <A, B> [Ref, Field A B]Perm;
var Mask: MaskType;
const ZeroMask: MaskType;
axiom (forall <A, B> o_2: Ref, f_4: (Field A B) ::
  { ZeroMask[o_2, f_4] }
  ZeroMask[o_2, f_4] == NoPerm
);
type PMaskType = <A, B> [Ref, Field A B]bool;
const ZeroPMask: PMaskType;
axiom (forall <A, B> o_2: Ref, f_4: (Field A B) ::
  { ZeroPMask[o_2, f_4] }
  !ZeroPMask[o_2, f_4]
);
function  PredicateMaskField<A>(f_5: (Field A FrameType)): Field A PMaskType;
function  WandMaskField<A>(f_5: (Field A FrameType)): Field A PMaskType;
const NoPerm: Perm;
axiom NoPerm == 0.000000000;
const FullPerm: Perm;
axiom FullPerm == 1.000000000;
function  Perm(a: real, b: real): Perm;
const AssumePermUpperBound: bool;
function  GoodMask(Mask: MaskType): bool;
axiom (forall Heap: HeapType, Mask: MaskType ::
  { state(Heap, Mask) }
  state(Heap, Mask) ==> GoodMask(Mask)
);
axiom (forall <A, B> Mask: MaskType, o_2: Ref, f_4: (Field A B) ::
  { GoodMask(Mask), Mask[o_2, f_4] }
  GoodMask(Mask) ==> Mask[o_2, f_4] >= NoPerm && (((GoodMask(Mask) && AssumePermUpperBound) && !IsPredicateField(f_4)) && !IsWandField(f_4) ==> Mask[o_2, f_4] <= FullPerm)
);
function  HasDirectPerm<A, B>(Mask: MaskType, o_2: Ref, f_4: (Field A B)): bool;
axiom (forall <A, B> Mask: MaskType, o_2: Ref, f_4: (Field A B) ::
  { HasDirectPerm(Mask, o_2, f_4) }
  HasDirectPerm(Mask, o_2, f_4) <==> Mask[o_2, f_4] > NoPerm
);
function  sumMask(ResultMask: MaskType, SummandMask1: MaskType, SummandMask2: MaskType): bool;
axiom (forall <A, B> ResultMask: MaskType, SummandMask1: MaskType, SummandMask2: MaskType, o_2: Ref, f_4: (Field A B) ::
  { sumMask(ResultMask, SummandMask1, SummandMask2), ResultMask[o_2, f_4] } { sumMask(ResultMask, SummandMask1, SummandMask2), SummandMask1[o_2, f_4] } { sumMask(ResultMask, SummandMask1, SummandMask2), SummandMask2[o_2, f_4] }
  sumMask(ResultMask, SummandMask1, SummandMask2) ==> ResultMask[o_2, f_4] == SummandMask1[o_2, f_4] + SummandMask2[o_2, f_4]
);

// ==================================================
// Preamble of Function and predicate module.
// ==================================================

// Function heights (higher height means its body is available earlier):
// - height 9: treeDegree
// - height 8: segLength
// - height 7: segDegree
// - height 6: treeParent
// - height 5: presorted
// - height 4: segParent
// - height 3: sorted
// - height 2: treeKey
// - height 1: validChildren
// - height 0: treeSize, segSize
const AssumeFunctionsAbove: int;
// Declarations for function framing
type FrameType;
const EmptyFrame: FrameType;
function  FrameFragment<T>(t: T): FrameType;
function  ConditionalFrame(p: Perm, f_6: FrameType): FrameType;
function  dummyFunction<T>(t: T): bool;
function  CombineFrames(a_1: FrameType, b_1: FrameType): FrameType;
// ==================================================
// Definition of conditional frame fragments
// ==================================================

axiom (forall p: Perm, f_6: FrameType ::
  { ConditionalFrame(p, f_6) }
  ConditionalFrame(p, f_6) == (if p > 0.000000000 then f_6 else EmptyFrame)
);
// Function for recording enclosure of one predicate instance in another
function  InsidePredicate<A, B>(p: (Field A FrameType), v_1: FrameType, q: (Field B FrameType), w: FrameType): bool;
// Transitivity of InsidePredicate
axiom (forall <A, B, C> p: (Field A FrameType), v_1: FrameType, q: (Field B FrameType), w: FrameType, r: (Field C FrameType), u: FrameType ::
  { InsidePredicate(p, v_1, q, w), InsidePredicate(q, w, r, u) }
  InsidePredicate(p, v_1, q, w) && InsidePredicate(q, w, r, u) ==> InsidePredicate(p, v_1, r, u)
);
// Knowledge that two identical instances of the same predicate cannot be inside each other
axiom (forall <A> p: (Field A FrameType), v_1: FrameType, w: FrameType ::
  { InsidePredicate(p, v_1, p, w) }
  !InsidePredicate(p, v_1, p, w)
);

// ==================================================
// Translation of all fields
// ==================================================

const unique key_6: Field NormalField int;
axiom !IsPredicateField(key_6);
axiom !IsWandField(key_6);
const unique degree: Field NormalField int;
axiom !IsPredicateField(degree);
axiom !IsWandField(degree);
const unique parent: Field NormalField Ref;
axiom !IsPredicateField(parent);
axiom !IsWandField(parent);
const unique sibling: Field NormalField Ref;
axiom !IsPredicateField(sibling);
axiom !IsWandField(sibling);
const unique child: Field NormalField Ref;
axiom !IsPredicateField(child);
axiom !IsWandField(child);
const unique Nodes_1: Field NormalField Ref;
axiom !IsPredicateField(Nodes_1);
axiom !IsWandField(Nodes_1);
const unique size_3: Field NormalField int;
axiom !IsPredicateField(size_3);
axiom !IsWandField(size_3);

// ==================================================
// Translation of function treeKey
// ==================================================

// Uninterpreted function definitions
function  treeKey(Heap: HeapType, this: Ref): int;
function  treeKey'(Heap: HeapType, this: Ref): int;
axiom (forall Heap: HeapType, this: Ref ::
  { treeKey(Heap, this) }
  treeKey(Heap, this) == treeKey'(Heap, this) && dummyFunction(treeKey#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeKey'(Heap, this) }
  dummyFunction(treeKey#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeKey(Heap, this) } { state(Heap, Mask), treeKey#triggerStateless(this), tree#trigger(Heap, tree_1(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 2 ==> treeKey(Heap, this) == Heap[this, key_6]
);

// Framing axioms
function  treeKey#frame(frame: FrameType, this: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeKey'(Heap, this) }
  state(Heap, Mask) ==> treeKey'(Heap, this) == treeKey#frame(Heap[null, tree_1(this)], this)
);

// Trigger function (controlling recursive postconditions)
function  treeKey#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeKey#triggerStateless(this: Ref): int;

// Check contract well-formedness and postcondition
procedure treeKey#definedness(this: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 2;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree_1(this):=Mask[null, tree_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in this.key)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree_1(this));
      assume UnfoldingHeap[null, tree_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key_6]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@32.1--36.2) [196548]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key_6:=UnfoldingMask[this, key_6] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree_1(this), UnfoldingHeap[null, tree_1(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.key (BinomialHeap.vpr@32.1--36.2) [196549]"}
        HasDirectPerm(UnfoldingMask, this, key_6);
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key_6:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_5: Ref, f_11: (Field A B) ::
          { newPMask[o_5, f_11] }
          Heap[null, tree#sm(this)][o_5, f_11] || Heap[null, heapseg#sm(Heap[this, child], null)][o_5, f_11] ==> newPMask[o_5, f_11]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := Heap[this, key_6];
}

// ==================================================
// Translation of function treeDegree
// ==================================================

// Uninterpreted function definitions
function  treeDegree(Heap: HeapType, this: Ref): int;
function  treeDegree'(Heap: HeapType, this: Ref): int;
axiom (forall Heap: HeapType, this: Ref ::
  { treeDegree(Heap, this) }
  treeDegree(Heap, this) == treeDegree'(Heap, this) && dummyFunction(treeDegree#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeDegree'(Heap, this) }
  dummyFunction(treeDegree#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeDegree(Heap, this) } { state(Heap, Mask), treeDegree#triggerStateless(this), tree#trigger(Heap, tree_1(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 9 ==> treeDegree(Heap, this) == Heap[this, degree]
);

// Framing axioms
function  treeDegree#frame(frame: FrameType, this: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeDegree'(Heap, this) }
  state(Heap, Mask) ==> treeDegree'(Heap, this) == treeDegree#frame(Heap[null, tree_1(this)], this)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeDegree'(Heap, this) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 9 || treeDegree#trigger(Heap[null, tree_1(this)], this)) ==> 0 <= treeDegree'(Heap, this)
);

// Trigger function (controlling recursive postconditions)
function  treeDegree#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeDegree#triggerStateless(this: Ref): int;

// Check contract well-formedness and postcondition
procedure treeDegree#definedness(this: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 9;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree_1(this):=Mask[null, tree_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in this.degree)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree_1(this));
      assume UnfoldingHeap[null, tree_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key_6]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@38.1--43.2) [196550]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key_6:=UnfoldingMask[this, key_6] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree_1(this), UnfoldingHeap[null, tree_1(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@38.1--43.2) [196551]"}
        HasDirectPerm(UnfoldingMask, this, degree);
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key_6:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_6: Ref, f_12: (Field A B) ::
          { newPMask[o_6, f_12] }
          Heap[null, tree#sm(this)][o_6, f_12] || Heap[null, heapseg#sm(Heap[this, child], null)][o_6, f_12] ==> newPMask[o_6, f_12]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := Heap[this, degree];
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of treeDegree might not hold. Assertion 0 <= result might not hold. (BinomialHeap.vpr@40.10--40.21) [196552]"}
      0 <= Result;
}

// ==================================================
// Translation of function treeSize
// ==================================================

// Uninterpreted function definitions
function  treeSize(Heap: HeapType, this: Ref): int;
function  treeSize'(Heap: HeapType, this: Ref): int;
axiom (forall Heap: HeapType, this: Ref ::
  { treeSize(Heap, this) }
  treeSize(Heap, this) == treeSize'(Heap, this) && dummyFunction(treeSize#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeSize'(Heap, this) }
  dummyFunction(treeSize#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeSize(Heap, this) } { state(Heap, Mask), treeSize#triggerStateless(this), tree#trigger(Heap, tree_1(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 0 ==> treeSize(Heap, this) == (if Heap[this, degree] == 0 then 1 else 1 + segSize'(Heap, Heap[this, child], null))
);

// Framing axioms
function  treeSize#frame(frame: FrameType, this: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeSize'(Heap, this) } { state(Heap, Mask), treeSize#triggerStateless(this), tree#trigger(Heap, tree_1(this)) }
  state(Heap, Mask) ==> treeSize'(Heap, this) == treeSize#frame(Heap[null, tree_1(this)], this)
);

// Trigger function (controlling recursive postconditions)
function  treeSize#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeSize#triggerStateless(this: Ref): int;

// Check contract well-formedness and postcondition
procedure treeSize#definedness(this: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 0;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree_1(this):=Mask[null, tree_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in (this.degree == 0 ? 1 : 1 + segSize(this.child, null)))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree_1(this));
      assume UnfoldingHeap[null, tree_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key_6]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@45.1--49.2) [196553]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key_6:=UnfoldingMask[this, key_6] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree_1(this), UnfoldingHeap[null, tree_1(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@45.1--49.2) [196554]"}
        HasDirectPerm(UnfoldingMask, this, degree);
      if (UnfoldingHeap[this, degree] == 0) {
      } else {
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@45.1--49.2) [196555]"}
          HasDirectPerm(UnfoldingMask, this, child);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@48.52--48.77) [196556]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      }
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key_6:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_40: Ref, f_52: (Field A B) ::
          { newPMask[o_40, f_52] }
          Heap[null, tree#sm(this)][o_40, f_52] || Heap[null, heapseg#sm(Heap[this, child], null)][o_40, f_52] ==> newPMask[o_40, f_52]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := (if Heap[this, degree] == 0 then 1 else 1 + segSize(Heap, Heap[this, child], null));
}

// ==================================================
// Translation of function treeParent
// ==================================================

// Uninterpreted function definitions
function  treeParent(Heap: HeapType, this: Ref): Ref;
function  treeParent'(Heap: HeapType, this: Ref): Ref;
axiom (forall Heap: HeapType, this: Ref ::
  { treeParent(Heap, this) }
  treeParent(Heap, this) == treeParent'(Heap, this) && dummyFunction(treeParent#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeParent'(Heap, this) }
  dummyFunction(treeParent#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeParent(Heap, this) } { state(Heap, Mask), treeParent#triggerStateless(this), tree#trigger(Heap, tree_1(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 6 ==> treeParent(Heap, this) == Heap[this, parent]
);

// Framing axioms
function  treeParent#frame(frame: FrameType, this: Ref): Ref;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeParent'(Heap, this) }
  state(Heap, Mask) ==> treeParent'(Heap, this) == treeParent#frame(Heap[null, tree_1(this)], this)
);

// Trigger function (controlling recursive postconditions)
function  treeParent#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeParent#triggerStateless(this: Ref): Ref;

// Check contract well-formedness and postcondition
procedure treeParent#definedness(this: Ref) returns (Result: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 6;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree_1(this):=Mask[null, tree_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in this.parent)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree_1(this));
      assume UnfoldingHeap[null, tree_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key_6]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@51.1--55.2) [196557]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key_6:=UnfoldingMask[this, key_6] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree_1(this), UnfoldingHeap[null, tree_1(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.parent (BinomialHeap.vpr@51.1--55.2) [196558]"}
        HasDirectPerm(UnfoldingMask, this, parent);
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key_6:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_42: Ref, f_55: (Field A B) ::
          { newPMask[o_42, f_55] }
          Heap[null, tree#sm(this)][o_42, f_55] || Heap[null, heapseg#sm(Heap[this, child], null)][o_42, f_55] ==> newPMask[o_42, f_55]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := Heap[this, parent];
}

// ==================================================
// Translation of function segLength
// ==================================================

// Uninterpreted function definitions
function  segLength(Heap: HeapType, this: Ref, last: Ref): int;
function  segLength'(Heap: HeapType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segLength(Heap, this, last) }
  segLength(Heap, this, last) == segLength'(Heap, this, last) && dummyFunction(segLength#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segLength'(Heap, this, last) }
  dummyFunction(segLength#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segLength(Heap, this, last) } { state(Heap, Mask), segLength#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 8 ==> segLength(Heap, this, last) == (if this == last then 0 else 1 + segLength'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  segLength#frame(frame: FrameType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segLength'(Heap, this, last) } { state(Heap, Mask), segLength#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segLength'(Heap, this, last) == segLength#frame(Heap[null, heapseg(this, last)], this, last)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segLength'(Heap, this, last) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 8 || segLength#trigger(Heap[null, heapseg(this, last)], this, last)) ==> 0 <= segLength'(Heap, this, last)
);

// Trigger function (controlling recursive postconditions)
function  segLength#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  segLength#triggerStateless(this: Ref, last: Ref): int;

// Check contract well-formedness and postcondition
procedure segLength#definedness(this: Ref, last: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 8;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (this == last ? 0 : 1 + (unfolding acc(heapseg(this, last), write) in segLength(this.sibling, last)))
      if (this == last) {
      } else {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree_1(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@64.1--69.2) [196559]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree_1(this):=UnfoldingMask[null, tree_1(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree_1(this), UnfoldingHeap[null, tree_1(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@64.1--69.2) [196560]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@68.57--68.86) [196561]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        } else {
          // Enable postcondition for recursive call
          assume segLength#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_46: Ref, f_60: (Field A B) ::
              { newPMask[o_46, f_60] }
              Heap[null, heapseg#sm(this, last)][o_46, f_60] || Heap[null, tree#sm(this)][o_46, f_60] ==> newPMask[o_46, f_60]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o: Ref, f_61: (Field A B) ::
              { newPMask[o, f_61] }
              Heap[null, heapseg#sm(this, last)][o, f_61] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o, f_61] ==> newPMask[o, f_61]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_14: Ref, f_3: (Field A B) ::
              { newPMask[o_14, f_3] }
              Heap[null, heapseg#sm(this, last)][o_14, f_3] || Heap[null, tree#sm(this)][o_14, f_3] ==> newPMask[o_14, f_3]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_3: Ref, f_24: (Field A B) ::
              { newPMask[o_3, f_24] }
              Heap[null, heapseg#sm(this, last)][o_3, f_24] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_3, f_24] ==> newPMask[o_3, f_24]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := (if this == last then 0 else 1 + segLength(Heap, Heap[this, sibling], last));
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of segLength might not hold. Assertion 0 <= result might not hold. (BinomialHeap.vpr@66.10--66.21) [196562]"}
      0 <= Result;
}

// ==================================================
// Translation of function segSize
// ==================================================

// Uninterpreted function definitions
function  segSize(Heap: HeapType, this: Ref, last: Ref): int;
function  segSize'(Heap: HeapType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segSize(Heap, this, last) }
  segSize(Heap, this, last) == segSize'(Heap, this, last) && dummyFunction(segSize#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segSize'(Heap, this, last) }
  dummyFunction(segSize#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segSize(Heap, this, last) } { state(Heap, Mask), segSize#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 0 ==> segSize(Heap, this, last) == (if this == last then 0 else treeSize'(Heap, this) + segSize'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  segSize#frame(frame: FrameType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segSize'(Heap, this, last) } { state(Heap, Mask), segSize#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segSize'(Heap, this, last) == segSize#frame(Heap[null, heapseg(this, last)], this, last)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segSize'(Heap, this, last) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 0 || segSize#trigger(Heap[null, heapseg(this, last)], this, last)) ==> this == last ==> segSize'(Heap, this, last) == 0
);

// Trigger function (controlling recursive postconditions)
function  segSize#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  segSize#triggerStateless(this: Ref, last: Ref): int;

// Check contract well-formedness and postcondition
procedure segSize#definedness(this: Ref, last: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 0;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (this == last ? 0 : (unfolding acc(heapseg(this, last), write) in treeSize(this) + segSize(this.sibling, last)))
      if (this == last) {
      } else {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree_1(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@71.1--76.2) [196563]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree_1(this):=UnfoldingMask[null, tree_1(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree_1(this), UnfoldingHeap[null, tree_1(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@75.53--75.67) [196564]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@71.1--76.2) [196565]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@75.70--75.97) [196566]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        } else {
          // Enable postcondition for recursive call
          assume segSize#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_1: Ref, f_10: (Field A B) ::
              { newPMask[o_1, f_10] }
              Heap[null, heapseg#sm(this, last)][o_1, f_10] || Heap[null, tree#sm(this)][o_1, f_10] ==> newPMask[o_1, f_10]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_15: Ref, f_51: (Field A B) ::
              { newPMask[o_15, f_51] }
              Heap[null, heapseg#sm(this, last)][o_15, f_51] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_15, f_51] ==> newPMask[o_15, f_51]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := (if this == last then 0 else treeSize(Heap, this) + segSize(Heap, Heap[this, sibling], last));
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (this == last) {
      assert {:msg "  Postcondition of segSize might not hold. Assertion result == 0 might not hold. (BinomialHeap.vpr@73.10--73.38) [196567]"}
        Result == 0;
    }
}

// ==================================================
// Translation of function segDegree
// ==================================================

// Uninterpreted function definitions
function  segDegree(Heap: HeapType, this: Ref, last: Ref, index: int): int;
function  segDegree'(Heap: HeapType, this: Ref, last: Ref, index: int): int;
axiom (forall Heap: HeapType, this: Ref, last: Ref, index: int ::
  { segDegree(Heap, this, last, index) }
  segDegree(Heap, this, last, index) == segDegree'(Heap, this, last, index) && dummyFunction(segDegree#triggerStateless(this, last, index))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref, index: int ::
  { segDegree'(Heap, this, last, index) }
  dummyFunction(segDegree#triggerStateless(this, last, index))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref, index: int ::
  { state(Heap, Mask), segDegree(Heap, this, last, index) } { state(Heap, Mask), segDegree#triggerStateless(this, last, index), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 7 ==> 0 <= index && index < segLength(Heap, this, last) ==> segDegree(Heap, this, last, index) == (if index == 0 then treeDegree(Heap, this) else segDegree'(Heap, Heap[this, sibling], last, index - 1))
);

// Framing axioms
function  segDegree#frame(frame: FrameType, this: Ref, last: Ref, index: int): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref, index: int ::
  { state(Heap, Mask), segDegree'(Heap, this, last, index) } { state(Heap, Mask), segDegree#triggerStateless(this, last, index), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segDegree'(Heap, this, last, index) == segDegree#frame(Heap[null, heapseg(this, last)], this, last, index)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref, index: int ::
  { state(Heap, Mask), segDegree'(Heap, this, last, index) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 7 || segDegree#trigger(Heap[null, heapseg(this, last)], this, last, index)) ==> 0 <= index && index < segLength(Heap, this, last) ==> 0 <= segDegree'(Heap, this, last, index)
);

// Trigger function (controlling recursive postconditions)
function  segDegree#trigger(frame: FrameType, this: Ref, last: Ref, index: int): bool;

// State-independent trigger function
function  segDegree#triggerStateless(this: Ref, last: Ref, index: int): int;

// Check contract well-formedness and postcondition
procedure segDegree#definedness(this: Ref, last: Ref, index: int) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 7;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume 0 <= index;
    assume state(Heap, Mask);
    
    // -- Check definedness of index < segLength(this, last)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@80.33--80.54) [196568]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume index < segLength(Heap, this, last);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(heapseg(this, last), write) in (index == 0 ? treeDegree(this) : segDegree(this.sibling, last, index - 1)))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
      assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree_1(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@78.1--85.2) [196569]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
      if (this != last) {
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, tree_1(this):=UnfoldingMask[null, tree_1(this)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree_1(this), UnfoldingHeap[null, tree_1(this)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        assume this != null;
        UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        if (UnfoldingHeap[this, sibling] != last) {
          assume state(UnfoldingHeap, UnfoldingMask);
          assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
        }
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      if (index == 0) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@84.16--84.32) [196570]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      } else {
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@78.1--85.2) [196571]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@84.34--84.74) [196572]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= index - 1 might not hold. (BinomialHeap.vpr@84.34--84.74) [196573]"}
            0 <= index - 1;
          assert {:msg "  Precondition of function segDegree might not hold. Assertion index - 1 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@84.34--84.74) [196574]"}
            index - 1 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        } else {
          // Enable postcondition for recursive call
          assume segDegree#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last, index - 1);
        }
      }
      
      // -- Free assumptions (exp module)
        if (this != last) {
          havoc newPMask;
          assume (forall <A, B> o_4: Ref, f_54: (Field A B) ::
            { newPMask[o_4, f_54] }
            Heap[null, heapseg#sm(this, last)][o_4, f_54] || Heap[null, tree#sm(this)][o_4, f_54] ==> newPMask[o_4, f_54]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_12: Ref, f_25: (Field A B) ::
            { newPMask[o_12, f_25] }
            Heap[null, heapseg#sm(this, last)][o_12, f_25] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_12, f_25] ==> newPMask[o_12, f_25]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
        }
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := (if index == 0 then treeDegree(Heap, this) else segDegree(Heap, Heap[this, sibling], last, index - 1));
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of segDegree might not hold. Assertion 0 <= result might not hold. (BinomialHeap.vpr@81.10--81.21) [196575]"}
      0 <= Result;
}

// ==================================================
// Translation of function segParent
// ==================================================

// Uninterpreted function definitions
function  segParent(Heap: HeapType, this: Ref, last: Ref): Ref;
function  segParent'(Heap: HeapType, this: Ref, last: Ref): Ref;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segParent(Heap, this, last) }
  segParent(Heap, this, last) == segParent'(Heap, this, last) && dummyFunction(segParent#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segParent'(Heap, this, last) }
  dummyFunction(segParent#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segParent(Heap, this, last) } { state(Heap, Mask), segParent#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 4 ==> this != last ==> segParent(Heap, this, last) == treeParent(Heap, this)
);

// Framing axioms
function  segParent#frame(frame: FrameType, this: Ref, last: Ref): Ref;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segParent'(Heap, this, last) } { state(Heap, Mask), segParent#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segParent'(Heap, this, last) == segParent#frame(Heap[null, heapseg(this, last)], this, last)
);

// Trigger function (controlling recursive postconditions)
function  segParent#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  segParent#triggerStateless(this: Ref, last: Ref): Ref;

// Check contract well-formedness and postcondition
procedure segParent#definedness(this: Ref, last: Ref) returns (Result: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 4;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume this != last;
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(heapseg(this, last), write) in treeParent(this))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
      assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree_1(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@87.1--91.2) [196576]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
      if (this != last) {
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, tree_1(this):=UnfoldingMask[null, tree_1(this)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree_1(this), UnfoldingHeap[null, tree_1(this)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        assume this != null;
        UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        if (UnfoldingHeap[this, sibling] != last) {
          assume state(UnfoldingHeap, UnfoldingMask);
          assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
        }
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@90.35--90.51) [196577]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
        UnfoldingHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      
      // -- Free assumptions (exp module)
        if (this != last) {
          havoc newPMask;
          assume (forall <A, B> o_41: Ref, f_21: (Field A B) ::
            { newPMask[o_41, f_21] }
            Heap[null, heapseg#sm(this, last)][o_41, f_21] || Heap[null, tree#sm(this)][o_41, f_21] ==> newPMask[o_41, f_21]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_23: Ref, f_13: (Field A B) ::
            { newPMask[o_23, f_13] }
            Heap[null, heapseg#sm(this, last)][o_23, f_13] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_23, f_13] ==> newPMask[o_23, f_13]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
        }
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := treeParent(Heap, this);
}

// ==================================================
// Translation of function sorted
// ==================================================

// Uninterpreted function definitions
function  sorted_1(Heap: HeapType, this: Ref, last: Ref): bool;
function  sorted'(Heap: HeapType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { sorted_1(Heap, this, last) }
  sorted_1(Heap, this, last) == sorted'(Heap, this, last) && dummyFunction(sorted#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { sorted'(Heap, this, last) }
  dummyFunction(sorted#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), sorted_1(Heap, this, last) } { state(Heap, Mask), sorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 3 ==> sorted_1(Heap, this, last) == (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) < segDegree(Heap, Heap[this, sibling], last, 0) && sorted'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  sorted#frame(frame: FrameType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), sorted'(Heap, this, last) } { state(Heap, Mask), sorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> sorted'(Heap, this, last) == sorted#frame(Heap[null, heapseg(this, last)], this, last)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), sorted'(Heap, this, last) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 3 || sorted#trigger(Heap[null, heapseg(this, last)], this, last)) ==> sorted'(Heap, this, last) ==> presorted(Heap, this, last)
);

// Trigger function (controlling recursive postconditions)
function  sorted#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  sorted#triggerStateless(this: Ref, last: Ref): bool;

// Check contract well-formedness and postcondition
procedure sorted#definedness(this: Ref, last: Ref) returns (Result: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  var ExhaleWellDef1Heap: HeapType;
  var ExhaleWellDef1Mask: MaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 3;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of 1 < segLength(this, last) ==> (unfolding acc(heapseg(this, last), write) in treeDegree(this) < segDegree(this.sibling, last, 0) && sorted(this.sibling, last))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@97.6--97.27) [196578]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (1 < segLength(Heap, this, last)) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree_1(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@93.1--98.2) [196579]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree_1(this):=UnfoldingMask[null, tree_1(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree_1(this), UnfoldingHeap[null, tree_1(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@97.65--97.81) [196580]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@93.1--98.2) [196581]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@97.84--97.116) [196582]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@97.84--97.116) [196583]"}
            0 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (treeDegree(UnfoldingHeap, this) < segDegree(UnfoldingHeap, UnfoldingHeap[this, sibling], last, 0)) {
          assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@93.1--98.2) [196584]"}
            HasDirectPerm(UnfoldingMask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := UnfoldingHeap;
            ExhaleWellDef0Mask := UnfoldingMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@97.120--97.146) [196585]"}
              NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
            UnfoldingHeap := ExhaleHeap;
            // Stop execution
            assume false;
          } else {
            // Enable postcondition for recursive call
            assume sorted#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
          }
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_13: Ref, f_65: (Field A B) ::
              { newPMask[o_13, f_65] }
              Heap[null, heapseg#sm(this, last)][o_13, f_65] || Heap[null, tree#sm(this)][o_13, f_65] ==> newPMask[o_13, f_65]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_51: Ref, f_66: (Field A B) ::
              { newPMask[o_51, f_66] }
              Heap[null, heapseg#sm(this, last)][o_51, f_66] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_51, f_66] ==> newPMask[o_51, f_66]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := 1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) < segDegree(Heap, Heap[this, sibling], last, 0) && sorted_1(Heap, Heap[this, sibling], last);
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (Result) {
      
      // -- Check definedness of presorted(this, last)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef1Heap := ExhaleWellDef0Heap;
          ExhaleWellDef1Mask := ExhaleWellDef0Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@95.21--95.42) [196586]"}
            NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(this, last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
          ExhaleWellDef0Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assert {:msg "  Postcondition of sorted might not hold. Assertion presorted(this, last) might not hold. (BinomialHeap.vpr@95.10--95.42) [196587]"}
        presorted(Heap, this, last);
    }
}

// ==================================================
// Translation of function presorted
// ==================================================

// Uninterpreted function definitions
function  presorted(Heap: HeapType, this: Ref, last: Ref): bool;
function  presorted'(Heap: HeapType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { presorted(Heap, this, last) }
  presorted(Heap, this, last) == presorted'(Heap, this, last) && dummyFunction(presorted#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { presorted'(Heap, this, last) }
  dummyFunction(presorted#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), presorted(Heap, this, last) } { state(Heap, Mask), presorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 5 ==> presorted(Heap, this, last) == ((1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) <= segDegree(Heap, Heap[this, sibling], last, 0) && presorted'(Heap, Heap[this, sibling], last)) && (2 < segLength(Heap, this, last) && segDegree(Heap, this, last, 0) == segDegree(Heap, this, last, 1) ==> segDegree(Heap, this, last, 1) < segDegree(Heap, this, last, 2)))
);

// Framing axioms
function  presorted#frame(frame: FrameType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), presorted'(Heap, this, last) } { state(Heap, Mask), presorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> presorted'(Heap, this, last) == presorted#frame(Heap[null, heapseg(this, last)], this, last)
);

// Trigger function (controlling recursive postconditions)
function  presorted#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  presorted#triggerStateless(this: Ref, last: Ref): bool;

// Check contract well-formedness and postcondition
procedure presorted#definedness(this: Ref, last: Ref) returns (Result: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 5;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (1 < segLength(this, last) ==> (unfolding acc(heapseg(this, last), write) in treeDegree(this) <= segDegree(this.sibling, last, 0) && presorted(this.sibling, last))) && (2 < segLength(this, last) && segDegree(this, last, 0) == segDegree(this, last, 1) ==> segDegree(this, last, 1) < segDegree(this, last, 2))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@103.7--103.28) [196588]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (1 < segLength(Heap, this, last)) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree_1(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@100.1--105.2) [196589]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree_1(this):=UnfoldingMask[null, tree_1(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree_1(this), UnfoldingHeap[null, tree_1(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@103.66--103.82) [196590]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@100.1--105.2) [196591]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@103.86--103.118) [196592]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@103.86--103.118) [196593]"}
            0 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (treeDegree(UnfoldingHeap, this) <= segDegree(UnfoldingHeap, UnfoldingHeap[this, sibling], last, 0)) {
          assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@100.1--105.2) [196594]"}
            HasDirectPerm(UnfoldingMask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := UnfoldingHeap;
            ExhaleWellDef0Mask := UnfoldingMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@103.122--103.151) [196595]"}
              NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
            UnfoldingHeap := ExhaleHeap;
            // Stop execution
            assume false;
          } else {
            // Enable postcondition for recursive call
            assume presorted#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
          }
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_52: Ref, f_14: (Field A B) ::
              { newPMask[o_52, f_14] }
              Heap[null, heapseg#sm(this, last)][o_52, f_14] || Heap[null, tree#sm(this)][o_52, f_14] ==> newPMask[o_52, f_14]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_20: Ref, f_50: (Field A B) ::
              { newPMask[o_20, f_50] }
              Heap[null, heapseg#sm(this, last)][o_20, f_50] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_20, f_50] ==> newPMask[o_20, f_50]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
      if (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) <= segDegree(Heap, Heap[this, sibling], last, 0) && presorted(Heap, Heap[this, sibling], last)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.7--104.28) [196596]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (2 < segLength(Heap, this, last)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.32--104.56) [196597]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.32--104.56) [196598]"}
              0 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.60--104.84) [196599]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.60--104.84) [196600]"}
              1 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        }
        if (2 < segLength(Heap, this, last) && segDegree(Heap, this, last, 0) == segDegree(Heap, this, last, 1)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.89--104.113) [196601]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.89--104.113) [196602]"}
              1 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.116--104.140) [196603]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 2 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.116--104.140) [196604]"}
              2 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        }
      }
  
  // -- Translate function body
    Result := (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) <= segDegree(Heap, Heap[this, sibling], last, 0) && presorted(Heap, Heap[this, sibling], last)) && (2 < segLength(Heap, this, last) && segDegree(Heap, this, last, 0) == segDegree(Heap, this, last, 1) ==> segDegree(Heap, this, last, 1) < segDegree(Heap, this, last, 2));
}

// ==================================================
// Translation of function validChildren
// ==================================================

// Uninterpreted function definitions
function  validChildren(Heap: HeapType, this: Ref, last: Ref): bool;
function  validChildren'(Heap: HeapType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { validChildren(Heap, this, last) }
  validChildren(Heap, this, last) == validChildren'(Heap, this, last) && dummyFunction(validChildren#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { validChildren'(Heap, this, last) }
  dummyFunction(validChildren#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), validChildren(Heap, this, last) } { state(Heap, Mask), validChildren#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 1 ==> validChildren(Heap, this, last) == (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) == segDegree(Heap, Heap[this, sibling], last, 0) + 1 && validChildren'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  validChildren#frame(frame: FrameType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), validChildren'(Heap, this, last) } { state(Heap, Mask), validChildren#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> validChildren'(Heap, this, last) == validChildren#frame(Heap[null, heapseg(this, last)], this, last)
);

// Trigger function (controlling recursive postconditions)
function  validChildren#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  validChildren#triggerStateless(this: Ref, last: Ref): bool;

// Check contract well-formedness and postcondition
procedure validChildren#definedness(this: Ref, last: Ref) returns (Result: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 1;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of 1 < segLength(this, last) ==> (unfolding acc(heapseg(this, last), write) in treeDegree(this) == segDegree(this.sibling, last, 0) + 1 && validChildren(this.sibling, last))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@110.6--110.27) [196605]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (1 < segLength(Heap, this, last)) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree_1(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@107.1--111.2) [196606]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree_1(this):=UnfoldingMask[null, tree_1(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree_1(this), UnfoldingHeap[null, tree_1(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@110.65--110.81) [196607]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@107.1--111.2) [196608]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@110.85--110.117) [196609]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@110.85--110.117) [196610]"}
            0 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (treeDegree(UnfoldingHeap, this) == segDegree(UnfoldingHeap, UnfoldingHeap[this, sibling], last, 0) + 1) {
          assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@107.1--111.2) [196611]"}
            HasDirectPerm(UnfoldingMask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := UnfoldingHeap;
            ExhaleWellDef0Mask := UnfoldingMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@110.125--110.158) [196612]"}
              NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
            UnfoldingHeap := ExhaleHeap;
            // Stop execution
            assume false;
          } else {
            // Enable postcondition for recursive call
            assume validChildren#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
          }
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_58: Ref, f_30: (Field A B) ::
              { newPMask[o_58, f_30] }
              Heap[null, heapseg#sm(this, last)][o_58, f_30] || Heap[null, tree#sm(this)][o_58, f_30] ==> newPMask[o_58, f_30]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_10: Ref, f_67: (Field A B) ::
              { newPMask[o_10, f_67] }
              Heap[null, heapseg#sm(this, last)][o_10, f_67] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_10, f_67] ==> newPMask[o_10, f_67]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := 1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) == segDegree(Heap, Heap[this, sibling], last, 0) + 1 && validChildren(Heap, Heap[this, sibling], last);
}

// ==================================================
// Translation of predicate tree
// ==================================================

type PredicateType_tree;
function  tree_1(this: Ref): Field PredicateType_tree FrameType;
function  tree#sm(this: Ref): Field PredicateType_tree PMaskType;
axiom (forall this: Ref ::
  { PredicateMaskField(tree_1(this)) }
  PredicateMaskField(tree_1(this)) == tree#sm(this)
);
axiom (forall this: Ref ::
  { tree_1(this) }
  IsPredicateField(tree_1(this))
);
axiom (forall this: Ref ::
  { tree_1(this) }
  getPredWandId(tree_1(this)) == 0
);
function  tree#trigger<A>(Heap: HeapType, pred: (Field A FrameType)): bool;
function  tree#everUsed<A>(pred: (Field A FrameType)): bool;
axiom (forall this: Ref, this2: Ref ::
  { tree_1(this), tree_1(this2) }
  tree_1(this) == tree_1(this2) ==> this == this2
);
axiom (forall this: Ref, this2: Ref ::
  { tree#sm(this), tree#sm(this2) }
  tree#sm(this) == tree#sm(this2) ==> this == this2
);

axiom (forall Heap: HeapType, this: Ref ::
  { tree#trigger(Heap, tree_1(this)) }
  tree#everUsed(tree_1(this))
);

procedure tree#definedness(this: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  
  // -- Check definedness of predicate body of tree
    
    // -- Initializing the state
      Mask := ZeroMask;
      assume state(Heap, Mask);
      assume AssumeFunctionsAbove == -1;
      assume AssumePermUpperBound;
      assume Heap[this, $allocated];
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, key_6:=Mask[this, key_6] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, degree:=Mask[this, degree] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, child:=Mask[this, child] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, parent:=Mask[this, parent] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of 0 <= this.degree
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [196613]"}
        HasDirectPerm(Mask, this, degree);
    assume 0 <= Heap[this, degree];
    
    // -- Check definedness of acc(heapseg(this.child, null), write)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [196614]"}
        HasDirectPerm(Mask, this, child);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, child], null):=Mask[null, heapseg(Heap[this, child], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.degree == segLength(this.child, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [196615]"}
        HasDirectPerm(Mask, this, degree);
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [196616]"}
        HasDirectPerm(Mask, this, child);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@26.17--26.44) [196617]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume Heap[this, degree] == segLength(Heap, Heap[this, child], null);
    
    // -- Check definedness of 0 < this.degree
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [196618]"}
        HasDirectPerm(Mask, this, degree);
    if (0 < Heap[this, degree]) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segDegree(this.child, null, 0) == this.degree - 1
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [196619]"}
          HasDirectPerm(Mask, this, child);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@27.23--27.53) [196620]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.child, null) might not hold. (BinomialHeap.vpr@27.23--27.53) [196621]"}
            0 < segLength(Heap, Heap[this, child], null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [196622]"}
          HasDirectPerm(Mask, this, degree);
      assume segDegree(Heap, Heap[this, child], null, 0) == Heap[this, degree] - 1;
    }
    assume state(Heap, Mask);
    
    // -- Check definedness of validChildren(this.child, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [196623]"}
        HasDirectPerm(Mask, this, child);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@28.2--28.33) [196624]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume validChildren(Heap, Heap[this, child], null);
    
    // -- Check definedness of this.child != null
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [196625]"}
        HasDirectPerm(Mask, this, child);
    if (Heap[this, child] != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.child, null) == this
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [196626]"}
          HasDirectPerm(Mask, this, child);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@29.26--29.53) [196627]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.child != null might not hold. (BinomialHeap.vpr@29.26--29.53) [196628]"}
            Heap[this, child] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, child], null) == this;
    }
    assume state(Heap, Mask);
}

// ==================================================
// Translation of predicate heapseg
// ==================================================

type PredicateType_heapseg;
function  heapseg(this: Ref, last: Ref): Field PredicateType_heapseg FrameType;
function  heapseg#sm(this: Ref, last: Ref): Field PredicateType_heapseg PMaskType;
axiom (forall this: Ref, last: Ref ::
  { PredicateMaskField(heapseg(this, last)) }
  PredicateMaskField(heapseg(this, last)) == heapseg#sm(this, last)
);
axiom (forall this: Ref, last: Ref ::
  { heapseg(this, last) }
  IsPredicateField(heapseg(this, last))
);
axiom (forall this: Ref, last: Ref ::
  { heapseg(this, last) }
  getPredWandId(heapseg(this, last)) == 1
);
function  heapseg#trigger<A>(Heap: HeapType, pred: (Field A FrameType)): bool;
function  heapseg#everUsed<A>(pred: (Field A FrameType)): bool;
axiom (forall this: Ref, last: Ref, this2: Ref, last2: Ref ::
  { heapseg(this, last), heapseg(this2, last2) }
  heapseg(this, last) == heapseg(this2, last2) ==> this == this2 && last == last2
);
axiom (forall this: Ref, last: Ref, this2: Ref, last2: Ref ::
  { heapseg#sm(this, last), heapseg#sm(this2, last2) }
  heapseg#sm(this, last) == heapseg#sm(this2, last2) ==> this == this2 && last == last2
);

axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { heapseg#trigger(Heap, heapseg(this, last)) }
  heapseg#everUsed(heapseg(this, last))
);

procedure heapseg#definedness(this: Ref, last: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  
  // -- Check definedness of predicate body of heapseg
    
    // -- Initializing the state
      Mask := ZeroMask;
      assume state(Heap, Mask);
      assume AssumeFunctionsAbove == -1;
      assume AssumePermUpperBound;
      assume Heap[this, $allocated];
      assume Heap[last, $allocated];
    if (this != last) {
      perm := FullPerm;
      Mask := Mask[null, tree_1(this):=Mask[null, tree_1(this)] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, sibling:=Mask[this, sibling] + perm];
      assume state(Heap, Mask);
      
      // -- Check definedness of acc(heapseg(this.sibling, last), write)
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@57.1--62.2) [196629]"}
          HasDirectPerm(Mask, this, sibling);
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, sibling], last):=Mask[null, heapseg(Heap[this, sibling], last)] + perm];
      assume state(Heap, Mask);
      
      // -- Check definedness of this.sibling != last
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@57.1--62.2) [196630]"}
          HasDirectPerm(Mask, this, sibling);
      if (Heap[this, sibling] != last) {
        assume state(Heap, Mask);
        
        // -- Check definedness of treeParent(this) == segParent(this.sibling, last)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@61.28--61.44) [196631]"}
              NoPerm < perm ==> NoPerm < Mask[null, tree_1(this)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@57.1--62.2) [196632]"}
            HasDirectPerm(Mask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@61.48--61.77) [196633]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, sibling], last)];
            assert {:msg "  Precondition of function segParent might not hold. Assertion this.sibling != last might not hold. (BinomialHeap.vpr@61.48--61.77) [196634]"}
              Heap[this, sibling] != last;
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume treeParent(Heap, this) == segParent(Heap, Heap[this, sibling], last);
      }
    }
    assume state(Heap, Mask);
}

// ==================================================
// Translation of predicate heap
// ==================================================

type PredicateType_heap;
function  heap_1(this: Ref): Field PredicateType_heap FrameType;
function  heap#sm(this: Ref): Field PredicateType_heap PMaskType;
axiom (forall this: Ref ::
  { PredicateMaskField(heap_1(this)) }
  PredicateMaskField(heap_1(this)) == heap#sm(this)
);
axiom (forall this: Ref ::
  { heap_1(this) }
  IsPredicateField(heap_1(this))
);
axiom (forall this: Ref ::
  { heap_1(this) }
  getPredWandId(heap_1(this)) == 2
);
function  heap#trigger<A>(Heap: HeapType, pred: (Field A FrameType)): bool;
function  heap#everUsed<A>(pred: (Field A FrameType)): bool;
axiom (forall this: Ref, this2: Ref ::
  { heap_1(this), heap_1(this2) }
  heap_1(this) == heap_1(this2) ==> this == this2
);
axiom (forall this: Ref, this2: Ref ::
  { heap#sm(this), heap#sm(this2) }
  heap#sm(this) == heap#sm(this2) ==> this == this2
);

axiom (forall Heap: HeapType, this: Ref ::
  { heap#trigger(Heap, heap_1(this)) }
  heap#everUsed(heap_1(this))
);

procedure heap#definedness(this: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  
  // -- Check definedness of predicate body of heap
    
    // -- Initializing the state
      Mask := ZeroMask;
      assume state(Heap, Mask);
      assume AssumeFunctionsAbove == -1;
      assume AssumePermUpperBound;
      assume Heap[this, $allocated];
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [196635]"}
        HasDirectPerm(Mask, this, Nodes_1);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [196636]"}
        HasDirectPerm(Mask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@239.31--239.55) [196637]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(Heap, Heap[this, Nodes_1], null);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [196638]"}
        HasDirectPerm(Mask, this, Nodes_1);
    if (Heap[this, Nodes_1] != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.Nodes, null) == null
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [196639]"}
          HasDirectPerm(Mask, this, Nodes_1);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@240.26--240.53) [196640]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@240.26--240.53) [196641]"}
            Heap[this, Nodes_1] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, Nodes_1], null) == null;
    }
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, size_3:=Mask[this, size_3] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.size == segSize(this.Nodes, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.size (BinomialHeap.vpr@237.1--243.2) [196642]"}
        HasDirectPerm(Mask, this, size_3);
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [196643]"}
        HasDirectPerm(Mask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@242.15--242.40) [196644]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume Heap[this, size_3] == segSize(Heap, Heap[this, Nodes_1], null);
    assume state(Heap, Mask);
}

// ==================================================
// Translation of method reverse2
// ==================================================

procedure reverse2(this: Ref, sibl: Ref) returns (res: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var newVersion: FrameType;
  var ss: Ref;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
    assume Heap[sibl, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of validChildren(this, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@114.34--114.59) [196645]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume validChildren(Heap, this, null);
    assume state(Heap, Mask);
    
    // -- Check definedness of 0 < segLength(this, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@114.67--114.88) [196646]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume 0 < segLength(Heap, this, null);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(sibl, null):=Mask[null, heapseg(sibl, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(sibl, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@115.34--115.52) [196647]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(sibl, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(Heap, sibl, null);
    assume state(Heap, Mask);
    if (sibl != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segDegree(this, null, 0) < segDegree(sibl, null, 0)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@116.28--116.52) [196648]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this, null) might not hold. (BinomialHeap.vpr@116.28--116.52) [196649]"}
            0 < segLength(Heap, this, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@116.55--116.79) [196650]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(sibl, null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(sibl, null) might not hold. (BinomialHeap.vpr@116.55--116.79) [196651]"}
            0 < segLength(Heap, sibl, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segDegree(Heap, this, null, 0) < segDegree(Heap, sibl, null, 0);
    }
    assume state(Heap, Mask);
    if (sibl != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this, null) == segParent(sibl, null)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@117.28--117.49) [196652]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this != null might not hold. (BinomialHeap.vpr@117.28--117.49) [196653]"}
            this != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@117.53--117.74) [196654]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(sibl, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion sibl != null might not hold. (BinomialHeap.vpr@117.53--117.74) [196655]"}
            sibl != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, this, null) == segParent(Heap, sibl, null);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    assume res != null;
    assume state(PostHeap, PostMask);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(res, null):=PostMask[null, heapseg(res, null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(res, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@120.10--120.27) [196656]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(PostHeap, res, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(res, null) == old(segSize(this, null)) + old(segSize(sibl, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@121.10--121.28) [196657]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@121.36--121.55) [196658]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(this, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@121.63--121.82) [196659]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(sibl, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, res, null) == segSize(oldHeap, this, null) + segSize(oldHeap, sibl, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(res, null) == old(segParent(this, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@122.10--122.30) [196660]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@122.10--122.30) [196661]"}
          res != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@122.38--122.59) [196662]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(this, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this != null might not hold. (BinomialHeap.vpr@122.38--122.59) [196663]"}
          this != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, res, null) == segParent(oldHeap, this, null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Translating statement: unfold acc(heapseg(this, null), write) -- BinomialHeap.vpr@124.2--124.28
    assume heapseg#trigger(Heap, heapseg(this, null));
    assume Heap[null, heapseg(this, null)] == FrameFragment((if this != null then CombineFrames(Heap[null, tree_1(this)], CombineFrames(FrameFragment(Heap[this, sibling]), CombineFrames(Heap[null, heapseg(Heap[this, sibling], null)], FrameFragment((if Heap[this, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Unfolding heapseg(this, null) might fail. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@124.2--124.28) [196666]"}
        perm <= Mask[null, heapseg(this, null)];
    }
    Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] - perm];
    
    // -- Update version of predicate
      if (!HasDirectPerm(Mask, null, heapseg(this, null))) {
        havoc newVersion;
        Heap := Heap[null, heapseg(this, null):=newVersion];
      }
    if (this != null) {
      perm := FullPerm;
      Mask := Mask[null, tree_1(this):=Mask[null, tree_1(this)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], tree_1(this), Heap[null, tree_1(this)]);
      assume state(Heap, Mask);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, sibling:=Mask[this, sibling] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, sibling], null):=Mask[null, heapseg(Heap[this, sibling], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], heapseg(Heap[this, sibling], null), Heap[null, heapseg(Heap[this, sibling], null)]);
      assume state(Heap, Mask);
      if (Heap[this, sibling] != null) {
        assume state(Heap, Mask);
        assume treeParent(Heap, this) == segParent(Heap, Heap[this, sibling], null);
      }
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this.sibling != null) -- BinomialHeap.vpr@125.2--136.3
    
    // -- Check definedness of this.sibling != null
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@125.5--125.25) [196670]"}
        HasDirectPerm(Mask, this, sibling);
    if (Heap[this, sibling] != null) {
      
      // -- Assumptions about local variables
        assume Heap[ss, $allocated];
      
      // -- Translating statement: ss := this.sibling -- BinomialHeap.vpr@127.3--127.21
        
        // -- Check definedness of this.sibling
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@127.3--127.21) [196671]"}
            HasDirectPerm(Mask, this, sibling);
        ss := Heap[this, sibling];
        assume state(Heap, Mask);
      
      // -- Translating statement: this.sibling := sibl -- BinomialHeap.vpr@128.3--128.23
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@128.3--128.23) [196672]"}
          FullPerm == Mask[this, sibling];
        Heap := Heap[this, sibling:=sibl];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(this, null), write) -- BinomialHeap.vpr@129.3--129.27
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (this != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this, null) might fail. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@129.3--129.27) [196675]"}
              perm <= Mask[null, tree_1(this)];
          }
          Mask := Mask[null, tree_1(this):=Mask[null, tree_1(this)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], tree_1(this), Heap[null, tree_1(this)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this, null) might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@129.3--129.27) [196677]"}
              perm <= Mask[this, sibling];
          }
          Mask := Mask[this, sibling:=Mask[this, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this, null) might fail. There might be insufficient permission to access heapseg(this.sibling, null) (BinomialHeap.vpr@129.3--129.27) [196679]"}
              perm <= Mask[null, heapseg(Heap[this, sibling], null)];
          }
          Mask := Mask[null, heapseg(Heap[this, sibling], null):=Mask[null, heapseg(Heap[this, sibling], null)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], heapseg(Heap[this, sibling], null), Heap[null, heapseg(Heap[this, sibling], null)]);
          if (Heap[this, sibling] != null) {
            assert {:msg "  Folding heapseg(this, null) might fail. Assertion treeParent(this) == segParent(this.sibling, null) might not hold. (BinomialHeap.vpr@129.3--129.27) [196680]"}
              treeParent(Heap, this) == segParent(Heap, Heap[this, sibling], null);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(this, null));
        assume Heap[null, heapseg(this, null)] == FrameFragment((if this != null then CombineFrames(Heap[null, tree_1(this)], CombineFrames(FrameFragment(Heap[this, sibling]), CombineFrames(Heap[null, heapseg(Heap[this, sibling], null)], FrameFragment((if Heap[this, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(this, null))) {
          Heap := Heap[null, heapseg#sm(this, null):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(this, null):=freshVersion];
        }
        if (this != null) {
          havoc newPMask;
          assume (forall <A, B> o_18: Ref, f_18: (Field A B) ::
            { newPMask[o_18, f_18] }
            Heap[null, heapseg#sm(this, null)][o_18, f_18] || Heap[null, tree#sm(this)][o_18, f_18] ==> newPMask[o_18, f_18]
          );
          Heap := Heap[null, heapseg#sm(this, null):=newPMask];
          Heap := Heap[null, heapseg#sm(this, null):=Heap[null, heapseg#sm(this, null)][this, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_66: Ref, f_28: (Field A B) ::
            { newPMask[o_66, f_28] }
            Heap[null, heapseg#sm(this, null)][o_66, f_28] || Heap[null, heapseg#sm(Heap[this, sibling], null)][o_66, f_28] ==> newPMask[o_66, f_28]
          );
          Heap := Heap[null, heapseg#sm(this, null):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: res := reverse2(ss, this) -- BinomialHeap.vpr@130.3--130.28
        PreCallHeap := Heap;
        PreCallMask := Mask;
        
        // -- Exhaling precondition
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(ss, null) (BinomialHeap.vpr@130.3--130.28) [196682]"}
              perm <= Mask[null, heapseg(ss, null)];
          }
          Mask := Mask[null, heapseg(ss, null):=Mask[null, heapseg(ss, null)] - perm];
          assert {:msg "  The precondition of method reverse2 might not hold. Assertion validChildren(ss, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [196683]"}
            validChildren(Heap, ss, null);
          assert {:msg "  The precondition of method reverse2 might not hold. Assertion 0 < segLength(ss, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [196684]"}
            0 < segLength(Heap, ss, null);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@130.3--130.28) [196685]"}
              perm <= Mask[null, heapseg(this, null)];
          }
          Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] - perm];
          assert {:msg "  The precondition of method reverse2 might not hold. Assertion sorted(this, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [196686]"}
            sorted_1(Heap, this, null);
          if (this != null) {
            assert {:msg "  The precondition of method reverse2 might not hold. Assertion segDegree(ss, null, 0) < segDegree(this, null, 0) might not hold. (BinomialHeap.vpr@130.3--130.28) [196687]"}
              segDegree(Heap, ss, null, 0) < segDegree(Heap, this, null, 0);
          }
          if (this != null) {
            assert {:msg "  The precondition of method reverse2 might not hold. Assertion segParent(ss, null) == segParent(this, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [196688]"}
              segParent(Heap, ss, null) == segParent(Heap, this, null);
          }
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
        
        // -- Havocing target variables
          havoc res;
        
        // -- Inhaling postcondition
          assume res != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted_1(Heap, res, null);
          assume state(Heap, Mask);
          assume segSize(Heap, res, null) == segSize(PreCallHeap, ss, null) + segSize(PreCallHeap, this, null);
          assume state(Heap, Mask);
          assume segParent(Heap, res, null) == segParent(PreCallHeap, ss, null);
          assume state(Heap, Mask);
        assume Heap[res, $allocated];
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: res := this -- BinomialHeap.vpr@133.3--133.14
        res := this;
        assume state(Heap, Mask);
      
      // -- Translating statement: this.sibling := sibl -- BinomialHeap.vpr@134.3--134.23
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@134.3--134.23) [196689]"}
          FullPerm == Mask[this, sibling];
        Heap := Heap[this, sibling:=sibl];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(res, null), write) -- BinomialHeap.vpr@135.3--135.26
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (res != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(res, null) might fail. There might be insufficient permission to access tree(res) (BinomialHeap.vpr@135.3--135.26) [196692]"}
              perm <= Mask[null, tree_1(res)];
          }
          Mask := Mask[null, tree_1(res):=Mask[null, tree_1(res)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(res, null), Heap[null, heapseg(res, null)], tree_1(res), Heap[null, tree_1(res)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(res, null) might fail. There might be insufficient permission to access res.sibling (BinomialHeap.vpr@135.3--135.26) [196694]"}
              perm <= Mask[res, sibling];
          }
          Mask := Mask[res, sibling:=Mask[res, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(res, null) might fail. There might be insufficient permission to access heapseg(res.sibling, null) (BinomialHeap.vpr@135.3--135.26) [196696]"}
              perm <= Mask[null, heapseg(Heap[res, sibling], null)];
          }
          Mask := Mask[null, heapseg(Heap[res, sibling], null):=Mask[null, heapseg(Heap[res, sibling], null)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(res, null), Heap[null, heapseg(res, null)], heapseg(Heap[res, sibling], null), Heap[null, heapseg(Heap[res, sibling], null)]);
          if (Heap[res, sibling] != null) {
            assert {:msg "  Folding heapseg(res, null) might fail. Assertion treeParent(res) == segParent(res.sibling, null) might not hold. (BinomialHeap.vpr@135.3--135.26) [196697]"}
              treeParent(Heap, res) == segParent(Heap, Heap[res, sibling], null);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(res, null));
        assume Heap[null, heapseg(res, null)] == FrameFragment((if res != null then CombineFrames(Heap[null, tree_1(res)], CombineFrames(FrameFragment(Heap[res, sibling]), CombineFrames(Heap[null, heapseg(Heap[res, sibling], null)], FrameFragment((if Heap[res, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(res, null))) {
          Heap := Heap[null, heapseg#sm(res, null):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(res, null):=freshVersion];
        }
        if (res != null) {
          havoc newPMask;
          assume (forall <A, B> o_11: Ref, f_34: (Field A B) ::
            { newPMask[o_11, f_34] }
            Heap[null, heapseg#sm(res, null)][o_11, f_34] || Heap[null, tree#sm(res)][o_11, f_34] ==> newPMask[o_11, f_34]
          );
          Heap := Heap[null, heapseg#sm(res, null):=newPMask];
          Heap := Heap[null, heapseg#sm(res, null):=Heap[null, heapseg#sm(res, null)][res, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_19: Ref, f_57: (Field A B) ::
            { newPMask[o_19, f_57] }
            Heap[null, heapseg#sm(res, null)][o_19, f_57] || Heap[null, heapseg#sm(Heap[res, sibling], null)][o_19, f_57] ==> newPMask[o_19, f_57]
          );
          Heap := Heap[null, heapseg#sm(res, null):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@118.10--118.21) [196699]"}
      res != null;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of reverse2 might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@119.10--119.28) [196700]"}
        perm <= Mask[null, heapseg(res, null)];
    }
    Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] - perm];
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion sorted(res, null) might not hold. (BinomialHeap.vpr@120.10--120.27) [196701]"}
      sorted_1(Heap, res, null);
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion segSize(res, null) == old(segSize(this, null)) + old(segSize(sibl, null)) might not hold. (BinomialHeap.vpr@121.10--121.83) [196702]"}
      segSize(Heap, res, null) == segSize(oldHeap, this, null) + segSize(oldHeap, sibl, null);
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion segParent(res, null) == old(segParent(this, null)) might not hold. (BinomialHeap.vpr@122.10--122.60) [196703]"}
      segParent(Heap, res, null) == segParent(oldHeap, this, null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method concat
// ==================================================

procedure vconcat(a_2: Ref, b_24: Ref, c: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var i_89: int;
  var i_90: int;
  var newVersion: FrameType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_a: Ref;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef1Heap: HeapType;
  var ExhaleWellDef1Mask: MaskType;
  var Unfolding1Heap: HeapType;
  var Unfolding1Mask: MaskType;
  var newPMask: PMaskType;
  var freshVersion: FrameType;
  var i_4_1: int;
  var i_6_2: int;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[a_2, $allocated];
    assume Heap[b_24, $allocated];
    assume Heap[c, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    Mask := Mask[null, heapseg(a_2, b_24):=Mask[null, heapseg(a_2, b_24)] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(b_24, c):=Mask[null, heapseg(b_24, c)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    if (c != null) {
      perm := FullPerm;
      Mask := Mask[null, tree_1(c):=Mask[null, tree_1(c)] + perm];
      assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
    if (a_2 != b_24 && b_24 != c) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(a, b) == segParent(b, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@142.32--142.47) [196704]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(a_2, b_24)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != b might not hold. (BinomialHeap.vpr@142.32--142.47) [196705]"}
            a_2 != b_24;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@142.51--142.66) [196706]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(b_24, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion b != c might not hold. (BinomialHeap.vpr@142.51--142.66) [196707]"}
            b_24 != c;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, a_2, b_24) == segParent(Heap, b_24, c);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(a_2, c):=PostMask[null, heapseg(a_2, c)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segLength(a, c) == old(segLength(a, b)) + old(segLength(b, c))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@144.10--144.25) [196708]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@144.33--144.48) [196709]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@144.56--144.71) [196710]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segLength(PostHeap, a_2, c) == segLength(oldHeap, a_2, b_24) + segLength(oldHeap, b_24, c);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of (forall i: Int :: { segDegree(a, c, i) } { old(segDegree(a, b, i)) } 0 <= i && i < old(segLength(a, b)) ==> segDegree(a, c, i) == old(segDegree(a, b, i)))
      if (*) {
        if (0 <= i_89) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@145.44--145.59) [196711]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
        }
        if (0 <= i_89 && i_89 < segLength(oldHeap, a_2, b_24)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := PostHeap;
            ExhaleWellDef0Mask := PostMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@145.65--145.83) [196712]"}
              NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i might not hold. (BinomialHeap.vpr@145.65--145.83) [196713]"}
              0 <= i_89;
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i < segLength(a, c) might not hold. (BinomialHeap.vpr@145.65--145.83) [196714]"}
              i_89 < segLength(PostHeap, a_2, c);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
            PostHeap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@145.91--145.109) [196715]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i might not hold. (BinomialHeap.vpr@145.91--145.109) [196716]"}
              0 <= i_89;
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i < segLength(a, b) might not hold. (BinomialHeap.vpr@145.91--145.109) [196717]"}
              i_89 < segLength(oldHeap, a_2, b_24);
            // Finish exhale
            // Stop execution
            assume false;
          }
        }
        assume false;
      }
    assume (forall i_1: int ::
      { segDegree#frame(PostHeap[null, heapseg(a_2, c)], a_2, c, i_1) } { segDegree#frame(oldHeap[null, heapseg(a_2, b_24)], a_2, b_24, i_1) }
      0 <= i_1 && i_1 < segLength(oldHeap, a_2, b_24) ==> segDegree(PostHeap, a_2, c, i_1) == segDegree(oldHeap, a_2, b_24, i_1)
    );
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of (forall i: Int :: { segDegree(a, c, i) } old(segLength(a, b)) <= i && i < segLength(a, c) ==> segDegree(a, c, i) == old(segDegree(b, c, i - segLength(a, b))))
      if (*) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@146.30--146.45) [196718]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (segLength(oldHeap, a_2, b_24) <= i_90) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := PostHeap;
            ExhaleWellDef0Mask := PostMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@146.59--146.74) [196719]"}
              NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
            PostHeap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        }
        if (segLength(oldHeap, a_2, b_24) <= i_90 && i_90 < segLength(PostHeap, a_2, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := PostHeap;
            ExhaleWellDef0Mask := PostMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@146.79--146.97) [196720]"}
              NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i might not hold. (BinomialHeap.vpr@146.79--146.97) [196721]"}
              0 <= i_90;
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i < segLength(a, c) might not hold. (BinomialHeap.vpr@146.79--146.97) [196722]"}
              i_90 < segLength(PostHeap, a_2, c);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
            PostHeap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@146.125--146.140) [196723]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@146.105--146.141) [196724]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i - segLength(a, b) might not hold. (BinomialHeap.vpr@146.105--146.141) [196725]"}
              0 <= i_90 - segLength(oldHeap, a_2, b_24);
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i - segLength(a, b) < segLength(b, c) might not hold. (BinomialHeap.vpr@146.105--146.141) [196726]"}
              i_90 - segLength(oldHeap, a_2, b_24) < segLength(oldHeap, b_24, c);
            // Finish exhale
            // Stop execution
            assume false;
          }
        }
        assume false;
      }
    assume (forall i_3_2: int ::
      { segDegree#frame(PostHeap[null, heapseg(a_2, c)], a_2, c, i_3_2) }
      segLength(oldHeap, a_2, b_24) <= i_3_2 && i_3_2 < segLength(PostHeap, a_2, c) ==> segDegree(PostHeap, a_2, c, i_3_2) == segDegree(oldHeap, b_24, c, i_3_2 - segLength(oldHeap, a_2, b_24))
    );
    assume state(PostHeap, PostMask);
    if (c != null) {
      perm := FullPerm;
      PostMask := PostMask[null, tree_1(c):=PostMask[null, tree_1(c)] + perm];
      assume state(PostHeap, PostMask);
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of treeDegree(c) == old(treeDegree(c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.35--147.48) [196727]"}
            NoPerm < perm ==> NoPerm < PostMask[null, tree_1(c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.56--147.69) [196728]"}
            NoPerm < perm ==> NoPerm < oldMask[null, tree_1(c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume treeDegree(PostHeap, c) == treeDegree(oldHeap, c);
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of treeSize(c) == old(treeSize(c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.74--147.85) [196729]"}
            NoPerm < perm ==> NoPerm < PostMask[null, tree_1(c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.93--147.104) [196730]"}
            NoPerm < perm ==> NoPerm < oldMask[null, tree_1(c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume treeSize(PostHeap, c) == treeSize(oldHeap, c);
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of treeParent(c) == old(treeParent(c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.109--147.122) [196731]"}
            NoPerm < perm ==> NoPerm < PostMask[null, tree_1(c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.130--147.143) [196732]"}
            NoPerm < perm ==> NoPerm < oldMask[null, tree_1(c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume treeParent(PostHeap, c) == treeParent(oldHeap, c);
    }
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of old(sorted(a, b)) && (old(sorted(b, c)) && old(0 < segLength(a, b) && 0 < segLength(b, c) ==> segDegree(a, b, segLength(a, b) - 1) < segDegree(b, c, 0)))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@149.14--149.26) [196733]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (sorted_1(oldHeap, a_2, b_24)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@149.35--149.47) [196734]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (sorted_1(oldHeap, b_24, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@150.9--150.24) [196735]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (0 < segLength(oldHeap, a_2, b_24)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@150.32--150.47) [196736]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
          if (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@150.68--150.83) [196737]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@150.52--150.88) [196738]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@150.52--150.88) [196739]"}
                0 <= segLength(oldHeap, a_2, b_24) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@150.52--150.88) [196740]"}
                segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@150.91--150.109) [196741]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@150.91--150.109) [196742]"}
                0 < segLength(oldHeap, b_24, c);
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
        }
      }
    if (sorted_1(oldHeap, a_2, b_24) && (sorted_1(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of sorted(a, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@150.115--150.127) [196743]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume sorted_1(PostHeap, a_2, c);
    }
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of old(presorted(a, b)) && (old(presorted(b, c)) && old(0 < segLength(a, b) && 0 < segLength(b, c) ==> segDegree(a, b, segLength(a, b) - 1) <= segDegree(b, c, 0) && ((2 <= segLength(a, b) && segDegree(a, b, segLength(a, b) - 1) == segDegree(a, b, segLength(a, b) - 2) ==> segDegree(a, b, segLength(a, b) - 1) < segDegree(b, c, 0)) && (2 <= segLength(b, c) && segDegree(b, c, 0) == segDegree(b, c, 1) ==> segDegree(a, b, segLength(a, b) - 1) < segDegree(b, c, 0)))))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@152.14--152.29) [196744]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (presorted(oldHeap, a_2, b_24)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@152.38--152.53) [196745]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (presorted(oldHeap, b_24, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@153.9--153.24) [196746]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (0 < segLength(oldHeap, a_2, b_24)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@153.32--153.47) [196747]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
          if (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@153.68--153.83) [196748]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@153.52--153.88) [196749]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@153.52--153.88) [196750]"}
                0 <= segLength(oldHeap, a_2, b_24) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@153.52--153.88) [196751]"}
                segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@153.92--153.110) [196752]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@153.92--153.110) [196753]"}
                0 < segLength(oldHeap, b_24, c);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) <= segDegree(oldHeap, b_24, c, 0)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.7--154.22) [196754]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                // Finish exhale
                // Stop execution
                assume false;
              }
              if (2 <= segLength(oldHeap, a_2, b_24)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.42--154.57) [196755]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.26--154.62) [196756]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@154.26--154.62) [196757]"}
                    0 <= segLength(oldHeap, a_2, b_24) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@154.26--154.62) [196758]"}
                    segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.82--154.97) [196759]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.66--154.102) [196760]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 2 might not hold. (BinomialHeap.vpr@154.66--154.102) [196761]"}
                    0 <= segLength(oldHeap, a_2, b_24) - 2;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 2 < segLength(a, b) might not hold. (BinomialHeap.vpr@154.66--154.102) [196762]"}
                    segLength(oldHeap, a_2, b_24) - 2 < segLength(oldHeap, a_2, b_24);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
              }
              if (2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.123--154.138) [196763]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.107--154.143) [196764]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@154.107--154.143) [196765]"}
                    0 <= segLength(oldHeap, a_2, b_24) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@154.107--154.143) [196766]"}
                    segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@154.146--154.164) [196767]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@154.146--154.164) [196768]"}
                    0 < segLength(oldHeap, b_24, c);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
              }
              if (2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.7--155.22) [196769]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(oldHeap, b_24, c)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.26--155.44) [196770]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@155.26--155.44) [196771]"}
                      0 < segLength(oldHeap, b_24, c);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.48--155.66) [196772]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(b, c) might not hold. (BinomialHeap.vpr@155.48--155.66) [196773]"}
                      1 < segLength(oldHeap, b_24, c);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                }
                if (2 <= segLength(oldHeap, b_24, c) && segDegree(oldHeap, b_24, c, 0) == segDegree(oldHeap, b_24, c, 1)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@155.87--155.102) [196774]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@155.71--155.107) [196775]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@155.71--155.107) [196776]"}
                      0 <= segLength(oldHeap, a_2, b_24) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@155.71--155.107) [196777]"}
                      segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.110--155.128) [196778]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@155.110--155.128) [196779]"}
                      0 < segLength(oldHeap, b_24, c);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                }
              }
            }
          }
        }
      }
    if (presorted(oldHeap, a_2, b_24) && (presorted(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) <= segDegree(oldHeap, b_24, c, 0) && ((2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)) && (2 <= segLength(oldHeap, b_24, c) && segDegree(oldHeap, b_24, c, 0) == segDegree(oldHeap, b_24, c, 1) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))))) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of presorted(a, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@156.5--156.20) [196780]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume presorted(PostHeap, a_2, c);
    }
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of old(validChildren(a, b)) && (old(validChildren(b, c)) && old(0 < segLength(a, b) && 0 < segLength(b, c) ==> segDegree(a, b, segLength(a, b) - 1) == segDegree(b, c, 0) + 1))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@157.14--157.33) [196781]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (validChildren(oldHeap, a_2, b_24)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@157.42--157.61) [196782]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (validChildren(oldHeap, b_24, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@158.9--158.24) [196783]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (0 < segLength(oldHeap, a_2, b_24)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@158.32--158.47) [196784]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
          if (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@158.68--158.83) [196785]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@158.52--158.88) [196786]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@158.52--158.88) [196787]"}
                0 <= segLength(oldHeap, a_2, b_24) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@158.52--158.88) [196788]"}
                segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@158.92--158.110) [196789]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@158.92--158.110) [196790]"}
                0 < segLength(oldHeap, b_24, c);
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
        }
      }
    if (validChildren(oldHeap, a_2, b_24) && (validChildren(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, b_24, c, 0) + 1))) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of validChildren(a, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@160.1--160.20) [196791]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume validChildren(PostHeap, a_2, c);
    }
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(a, c) == old(segSize(a, b)) + old(segSize(b, c))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@161.10--161.23) [196792]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@161.31--161.44) [196793]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@161.52--161.65) [196794]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, a_2, c) == segSize(oldHeap, a_2, b_24) + segSize(oldHeap, b_24, c);
    assume state(PostHeap, PostMask);
    if (a_2 != b_24) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segParent(a, c) == old(segParent(a, b))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@162.21--162.36) [196795]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != c might not hold. (BinomialHeap.vpr@162.21--162.36) [196796]"}
            a_2 != c;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@162.44--162.59) [196797]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != b might not hold. (BinomialHeap.vpr@162.44--162.59) [196798]"}
            a_2 != b_24;
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume segParent(PostHeap, a_2, c) == segParent(oldHeap, a_2, b_24);
    }
    assume state(PostHeap, PostMask);
    if (b_24 != c) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segParent(a, c) == old(segParent(b, c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@163.21--163.36) [196799]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != c might not hold. (BinomialHeap.vpr@163.21--163.36) [196800]"}
            a_2 != c;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@163.44--163.59) [196801]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion b != c might not hold. (BinomialHeap.vpr@163.44--163.59) [196802]"}
            b_24 != c;
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume segParent(PostHeap, a_2, c) == segParent(oldHeap, b_24, c);
    }
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Translating statement: if (a != b) -- BinomialHeap.vpr@165.2--170.3
    if (a_2 != b_24) {
      
      // -- Translating statement: unfold acc(heapseg(a, b), write) -- BinomialHeap.vpr@166.3--166.23
        assume heapseg#trigger(Heap, heapseg(a_2, b_24));
        assume Heap[null, heapseg(a_2, b_24)] == FrameFragment((if a_2 != b_24 then CombineFrames(Heap[null, tree_1(a_2)], CombineFrames(FrameFragment(Heap[a_2, sibling]), CombineFrames(Heap[null, heapseg(Heap[a_2, sibling], b_24)], FrameFragment((if Heap[a_2, sibling] != b_24 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Unfolding heapseg(a, b) might fail. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@166.3--166.23) [196805]"}
            perm <= Mask[null, heapseg(a_2, b_24)];
        }
        Mask := Mask[null, heapseg(a_2, b_24):=Mask[null, heapseg(a_2, b_24)] - perm];
        
        // -- Update version of predicate
          if (!HasDirectPerm(Mask, null, heapseg(a_2, b_24))) {
            havoc newVersion;
            Heap := Heap[null, heapseg(a_2, b_24):=newVersion];
          }
        if (a_2 != b_24) {
          perm := FullPerm;
          Mask := Mask[null, tree_1(a_2):=Mask[null, tree_1(a_2)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(a_2, b_24), Heap[null, heapseg(a_2, b_24)], tree_1(a_2), Heap[null, tree_1(a_2)]);
          assume state(Heap, Mask);
          perm := FullPerm;
          assume a_2 != null;
          Mask := Mask[a_2, sibling:=Mask[a_2, sibling] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[a_2, sibling], b_24):=Mask[null, heapseg(Heap[a_2, sibling], b_24)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(a_2, b_24), Heap[null, heapseg(a_2, b_24)], heapseg(Heap[a_2, sibling], b_24), Heap[null, heapseg(Heap[a_2, sibling], b_24)]);
          assume state(Heap, Mask);
          if (Heap[a_2, sibling] != b_24) {
            assume state(Heap, Mask);
            assume treeParent(Heap, a_2) == segParent(Heap, Heap[a_2, sibling], b_24);
          }
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: concat(a.sibling, b, c) -- BinomialHeap.vpr@167.3--167.26
        PreCallHeap := Heap;
        PreCallMask := Mask;
        
        // -- Check definedness of a.sibling
          assert {:msg "  Method call might fail. There might be insufficient permission to access a.sibling (BinomialHeap.vpr@167.3--167.26) [196809]"}
            HasDirectPerm(Mask, a_2, sibling);
        arg_a := Heap[a_2, sibling];
        
        // -- Exhaling precondition
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(a.sibling, b) (BinomialHeap.vpr@167.3--167.26) [196810]"}
              perm <= Mask[null, heapseg(arg_a, b_24)];
          }
          Mask := Mask[null, heapseg(arg_a, b_24):=Mask[null, heapseg(arg_a, b_24)] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@167.3--167.26) [196811]"}
              perm <= Mask[null, heapseg(b_24, c)];
          }
          Mask := Mask[null, heapseg(b_24, c):=Mask[null, heapseg(b_24, c)] - perm];
          if (c != null) {
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@167.3--167.26) [196812]"}
                perm <= Mask[null, tree_1(c)];
            }
            Mask := Mask[null, tree_1(c):=Mask[null, tree_1(c)] - perm];
          }
          if (arg_a != b_24 && b_24 != c) {
            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(a.sibling, b) == segParent(b, c) might not hold. (BinomialHeap.vpr@167.3--167.26) [196813]"}
              segParent(Heap, arg_a, b_24) == segParent(Heap, b_24, c);
          }
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
        
        // -- Inhaling postcondition
          perm := FullPerm;
          Mask := Mask[null, heapseg(arg_a, c):=Mask[null, heapseg(arg_a, c)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume segLength(Heap, arg_a, c) == segLength(PreCallHeap, arg_a, b_24) + segLength(PreCallHeap, b_24, c);
          assume state(Heap, Mask);
          assume (forall i_8_1: int ::
            { segDegree#frame(Heap[null, heapseg(arg_a, c)], arg_a, c, i_8_1) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a, b_24)], arg_a, b_24, i_8_1) }
            0 <= i_8_1 && i_8_1 < segLength(PreCallHeap, arg_a, b_24) ==> segDegree(Heap, arg_a, c, i_8_1) == segDegree(PreCallHeap, arg_a, b_24, i_8_1)
          );
          assume state(Heap, Mask);
          assume (forall i_9_1: int ::
            { segDegree#frame(Heap[null, heapseg(arg_a, c)], arg_a, c, i_9_1) }
            segLength(PreCallHeap, arg_a, b_24) <= i_9_1 && i_9_1 < segLength(Heap, arg_a, c) ==> segDegree(Heap, arg_a, c, i_9_1) == segDegree(PreCallHeap, b_24, c, i_9_1 - segLength(PreCallHeap, arg_a, b_24))
          );
          if (c != null) {
            perm := FullPerm;
            Mask := Mask[null, tree_1(c):=Mask[null, tree_1(c)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume treeDegree(Heap, c) == treeDegree(PreCallHeap, c);
            assume state(Heap, Mask);
            assume treeSize(Heap, c) == treeSize(PreCallHeap, c);
            assume state(Heap, Mask);
            assume treeParent(Heap, c) == treeParent(PreCallHeap, c);
          }
          if (sorted_1(PreCallHeap, arg_a, b_24) && (sorted_1(PreCallHeap, b_24, c) && (0 < segLength(PreCallHeap, arg_a, b_24) && 0 < segLength(PreCallHeap, b_24, c) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) < segDegree(PreCallHeap, b_24, c, 0)))) {
            assume state(Heap, Mask);
            assume sorted_1(Heap, arg_a, c);
          }
          if (presorted(PreCallHeap, arg_a, b_24) && (presorted(PreCallHeap, b_24, c) && (0 < segLength(PreCallHeap, arg_a, b_24) && 0 < segLength(PreCallHeap, b_24, c) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) <= segDegree(PreCallHeap, b_24, c, 0) && ((2 <= segLength(PreCallHeap, arg_a, b_24) && segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) == segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 2) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) < segDegree(PreCallHeap, b_24, c, 0)) && (2 <= segLength(PreCallHeap, b_24, c) && segDegree(PreCallHeap, b_24, c, 0) == segDegree(PreCallHeap, b_24, c, 1) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) < segDegree(PreCallHeap, b_24, c, 0)))))) {
            assume state(Heap, Mask);
            assume presorted(Heap, arg_a, c);
          }
          if (validChildren(PreCallHeap, arg_a, b_24) && (validChildren(PreCallHeap, b_24, c) && (0 < segLength(PreCallHeap, arg_a, b_24) && 0 < segLength(PreCallHeap, b_24, c) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) == segDegree(PreCallHeap, b_24, c, 0) + 1))) {
            assume state(Heap, Mask);
            assume validChildren(Heap, arg_a, c);
          }
          assume state(Heap, Mask);
          assume segSize(Heap, arg_a, c) == segSize(PreCallHeap, arg_a, b_24) + segSize(PreCallHeap, b_24, c);
          if (arg_a != b_24) {
            assume state(Heap, Mask);
            assume segParent(Heap, arg_a, c) == segParent(PreCallHeap, arg_a, b_24);
          }
          if (b_24 != c) {
            assume state(Heap, Mask);
            assume segParent(Heap, arg_a, c) == segParent(PreCallHeap, b_24, c);
          }
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: assert c != null ==>
  //   (unfolding acc(tree(a), write) in
  //     (unfolding acc(tree(c), 1 / 2) in a != c)) -- BinomialHeap.vpr@168.3--168.82
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (c != null) {
          
          // -- Check definedness of (unfolding acc(tree(a), write) in (unfolding acc(tree(c), 1 / 2) in a != c))
            UnfoldingHeap := ExhaleWellDef0Heap;
            UnfoldingMask := ExhaleWellDef0Mask;
            assume tree#trigger(UnfoldingHeap, tree_1(a_2));
            assume UnfoldingHeap[null, tree_1(a_2)] == CombineFrames(FrameFragment(UnfoldingHeap[a_2, key_6]), CombineFrames(FrameFragment(UnfoldingHeap[a_2, degree]), CombineFrames(FrameFragment(UnfoldingHeap[a_2, child]), CombineFrames(FrameFragment(UnfoldingHeap[a_2, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[a_2, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[a_2, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[a_2, child] != null then EmptyFrame else EmptyFrame))))))));
            ExhaleWellDef1Heap := UnfoldingHeap;
            ExhaleWellDef1Mask := UnfoldingMask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Assert might fail. There might be insufficient permission to access tree(a) (BinomialHeap.vpr@168.10--168.82) [196814]"}
                perm <= UnfoldingMask[null, tree_1(a_2)];
            }
            UnfoldingMask := UnfoldingMask[null, tree_1(a_2):=UnfoldingMask[null, tree_1(a_2)] - perm];
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, key_6:=UnfoldingMask[a_2, key_6] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, degree:=UnfoldingMask[a_2, degree] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, child:=UnfoldingMask[a_2, child] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, parent:=UnfoldingMask[a_2, parent] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            assume 0 <= UnfoldingHeap[a_2, degree];
            perm := FullPerm;
            UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[a_2, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[a_2, child], null)] + perm];
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(tree_1(a_2), UnfoldingHeap[null, tree_1(a_2)], heapseg(UnfoldingHeap[a_2, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[a_2, child], null)]);
            assume state(UnfoldingHeap, UnfoldingMask);
            assume state(UnfoldingHeap, UnfoldingMask);
            assume UnfoldingHeap[a_2, degree] == segLength(UnfoldingHeap, UnfoldingHeap[a_2, child], null);
            if (0 < UnfoldingHeap[a_2, degree]) {
              assume state(UnfoldingHeap, UnfoldingMask);
              assume segDegree(UnfoldingHeap, UnfoldingHeap[a_2, child], null, 0) == UnfoldingHeap[a_2, degree] - 1;
            }
            assume state(UnfoldingHeap, UnfoldingMask);
            assume validChildren(UnfoldingHeap, UnfoldingHeap[a_2, child], null);
            if (UnfoldingHeap[a_2, child] != null) {
              assume state(UnfoldingHeap, UnfoldingMask);
              assume segParent(UnfoldingHeap, UnfoldingHeap[a_2, child], null) == a_2;
            }
            assume state(UnfoldingHeap, UnfoldingMask);
            Unfolding1Heap := UnfoldingHeap;
            Unfolding1Mask := UnfoldingMask;
            assume tree#trigger(Unfolding1Heap, tree_1(c));
            assume Unfolding1Heap[null, tree_1(c)] == CombineFrames(FrameFragment(Unfolding1Heap[c, key_6]), CombineFrames(FrameFragment(Unfolding1Heap[c, degree]), CombineFrames(FrameFragment(Unfolding1Heap[c, child]), CombineFrames(FrameFragment(Unfolding1Heap[c, parent]), CombineFrames(Unfolding1Heap[null, heapseg(Unfolding1Heap[c, child], null)], CombineFrames(FrameFragment((if 0 < Unfolding1Heap[c, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Unfolding1Heap[c, child] != null then EmptyFrame else EmptyFrame))))))));
            ExhaleWellDef1Heap := Unfolding1Heap;
            ExhaleWellDef1Mask := Unfolding1Mask;
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [196815]"}
              perm >= NoPerm;
            if (perm != NoPerm) {
              assert {:msg "  Assert might fail. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@168.10--168.82) [196816]"}
                perm <= Unfolding1Mask[null, tree_1(c)];
            }
            Unfolding1Mask := Unfolding1Mask[null, tree_1(c):=Unfolding1Mask[null, tree_1(c)] - perm];
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [196817]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, key_6:=Unfolding1Mask[c, key_6] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [196818]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, degree:=Unfolding1Mask[c, degree] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [196819]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, child:=Unfolding1Mask[c, child] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [196820]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, parent:=Unfolding1Mask[c, parent] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume 0 <= Unfolding1Heap[c, degree];
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [196821]"}
              perm >= NoPerm;
            Unfolding1Mask := Unfolding1Mask[null, heapseg(Unfolding1Heap[c, child], null):=Unfolding1Mask[null, heapseg(Unfolding1Heap[c, child], null)] + perm];
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(tree_1(c), Unfolding1Heap[null, tree_1(c)], heapseg(Unfolding1Heap[c, child], null), Unfolding1Heap[null, heapseg(Unfolding1Heap[c, child], null)]);
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume Unfolding1Heap[c, degree] == segLength(Unfolding1Heap, Unfolding1Heap[c, child], null);
            if (0 < Unfolding1Heap[c, degree]) {
              assume state(Unfolding1Heap, Unfolding1Mask);
              assume segDegree(Unfolding1Heap, Unfolding1Heap[c, child], null, 0) == Unfolding1Heap[c, degree] - 1;
            }
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume validChildren(Unfolding1Heap, Unfolding1Heap[c, child], null);
            if (Unfolding1Heap[c, child] != null) {
              assume state(Unfolding1Heap, Unfolding1Mask);
              assume segParent(Unfolding1Heap, Unfolding1Heap[c, child], null) == c;
            }
            assume state(Unfolding1Heap, Unfolding1Mask);
            
            // -- Free assumptions (exp module)
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, key_6:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, degree:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, child:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, parent:=true]];
              havoc newPMask;
              assume (forall <A, B> o_43: Ref, f_33: (Field A B) ::
                { newPMask[o_43, f_33] }
                Heap[null, tree#sm(c)][o_43, f_33] || Heap[null, heapseg#sm(Heap[c, child], null)][o_43, f_33] ==> newPMask[o_43, f_33]
              );
              Heap := Heap[null, tree#sm(c):=newPMask];
              assume state(Heap, Mask);
            
            // -- Free assumptions (exp module)
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, key_6:=true]];
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, degree:=true]];
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, child:=true]];
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, parent:=true]];
              havoc newPMask;
              assume (forall <A, B> o_50: Ref, f_75: (Field A B) ::
                { newPMask[o_50, f_75] }
                Heap[null, tree#sm(a_2)][o_50, f_75] || Heap[null, heapseg#sm(Heap[a_2, child], null)][o_50, f_75] ==> newPMask[o_50, f_75]
              );
              Heap := Heap[null, tree#sm(a_2):=newPMask];
              assume state(Heap, Mask);
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, key_6:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, degree:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, child:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, parent:=true]];
              havoc newPMask;
              assume (forall <A, B> o_22: Ref, f_59: (Field A B) ::
                { newPMask[o_22, f_59] }
                Heap[null, tree#sm(c)][o_22, f_59] || Heap[null, heapseg#sm(Heap[c, child], null)][o_22, f_59] ==> newPMask[o_22, f_59]
              );
              Heap := Heap[null, tree#sm(c):=newPMask];
              assume state(Heap, Mask);
          assert {:msg "  Assert might fail. Assertion a != c might not hold. (BinomialHeap.vpr@168.10--168.82) [196822]"}
            a_2 != c;
        }
        
        // -- Free assumptions (exhale module)
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, key_6:=true]];
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, degree:=true]];
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, child:=true]];
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, parent:=true]];
          havoc newPMask;
          assume (forall <A, B> o_67: Ref, f_69: (Field A B) ::
            { newPMask[o_67, f_69] }
            Heap[null, tree#sm(a_2)][o_67, f_69] || Heap[null, heapseg#sm(Heap[a_2, child], null)][o_67, f_69] ==> newPMask[o_67, f_69]
          );
          Heap := Heap[null, tree#sm(a_2):=newPMask];
          assume state(Heap, Mask);
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, key_6:=true]];
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, degree:=true]];
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, child:=true]];
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, parent:=true]];
          havoc newPMask;
          assume (forall <A, B> o_68: Ref, f_76: (Field A B) ::
            { newPMask[o_68, f_76] }
            Heap[null, tree#sm(c)][o_68, f_76] || Heap[null, heapseg#sm(Heap[c, child], null)][o_68, f_76] ==> newPMask[o_68, f_76]
          );
          Heap := Heap[null, tree#sm(c):=newPMask];
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(a, c), write) -- BinomialHeap.vpr@169.3--169.21
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (a_2 != c) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(a, c) might fail. There might be insufficient permission to access tree(a) (BinomialHeap.vpr@169.3--169.21) [196825]"}
              perm <= Mask[null, tree_1(a_2)];
          }
          Mask := Mask[null, tree_1(a_2):=Mask[null, tree_1(a_2)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(a_2, c), Heap[null, heapseg(a_2, c)], tree_1(a_2), Heap[null, tree_1(a_2)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(a, c) might fail. There might be insufficient permission to access a.sibling (BinomialHeap.vpr@169.3--169.21) [196827]"}
              perm <= Mask[a_2, sibling];
          }
          Mask := Mask[a_2, sibling:=Mask[a_2, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(a, c) might fail. There might be insufficient permission to access heapseg(a.sibling, c) (BinomialHeap.vpr@169.3--169.21) [196829]"}
              perm <= Mask[null, heapseg(Heap[a_2, sibling], c)];
          }
          Mask := Mask[null, heapseg(Heap[a_2, sibling], c):=Mask[null, heapseg(Heap[a_2, sibling], c)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(a_2, c), Heap[null, heapseg(a_2, c)], heapseg(Heap[a_2, sibling], c), Heap[null, heapseg(Heap[a_2, sibling], c)]);
          if (Heap[a_2, sibling] != c) {
            assert {:msg "  Folding heapseg(a, c) might fail. Assertion treeParent(a) == segParent(a.sibling, c) might not hold. (BinomialHeap.vpr@169.3--169.21) [196830]"}
              treeParent(Heap, a_2) == segParent(Heap, Heap[a_2, sibling], c);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(a_2, c):=Mask[null, heapseg(a_2, c)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(a_2, c));
        assume Heap[null, heapseg(a_2, c)] == FrameFragment((if a_2 != c then CombineFrames(Heap[null, tree_1(a_2)], CombineFrames(FrameFragment(Heap[a_2, sibling]), CombineFrames(Heap[null, heapseg(Heap[a_2, sibling], c)], FrameFragment((if Heap[a_2, sibling] != c then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(a_2, c))) {
          Heap := Heap[null, heapseg#sm(a_2, c):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(a_2, c):=freshVersion];
        }
        if (a_2 != c) {
          havoc newPMask;
          assume (forall <A, B> o_69: Ref, f_77: (Field A B) ::
            { newPMask[o_69, f_77] }
            Heap[null, heapseg#sm(a_2, c)][o_69, f_77] || Heap[null, tree#sm(a_2)][o_69, f_77] ==> newPMask[o_69, f_77]
          );
          Heap := Heap[null, heapseg#sm(a_2, c):=newPMask];
          Heap := Heap[null, heapseg#sm(a_2, c):=Heap[null, heapseg#sm(a_2, c)][a_2, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_70: Ref, f_78: (Field A B) ::
            { newPMask[o_70, f_78] }
            Heap[null, heapseg#sm(a_2, c)][o_70, f_78] || Heap[null, heapseg#sm(Heap[a_2, sibling], c)][o_70, f_78] ==> newPMask[o_70, f_78]
          );
          Heap := Heap[null, heapseg#sm(a_2, c):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of concat might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@143.10--143.23) [196832]"}
        perm <= Mask[null, heapseg(a_2, c)];
    }
    Mask := Mask[null, heapseg(a_2, c):=Mask[null, heapseg(a_2, c)] - perm];
    assert {:msg "  Postcondition of concat might not hold. Assertion segLength(a, c) == old(segLength(a, b)) + old(segLength(b, c)) might not hold. (BinomialHeap.vpr@144.10--144.72) [196833]"}
      segLength(Heap, a_2, c) == segLength(oldHeap, a_2, b_24) + segLength(oldHeap, b_24, c);
    if (*) {
      if (0 <= i_4_1 && i_4_1 < segLength(oldHeap, a_2, b_24)) {
        assert {:msg "  Postcondition of concat might not hold. Assertion segDegree(a, c, i) == old(segDegree(a, b, i)) might not hold. (BinomialHeap.vpr@145.10--145.110) [196834]"}
          segDegree(Heap, a_2, c, i_4_1) == segDegree(oldHeap, a_2, b_24, i_4_1);
      }
      assume false;
    }
    assume (forall i_5_1_1: int ::
      { segDegree#frame(Heap[null, heapseg(a_2, c)], a_2, c, i_5_1_1) } { segDegree#frame(oldHeap[null, heapseg(a_2, b_24)], a_2, b_24, i_5_1_1) }
      0 <= i_5_1_1 && i_5_1_1 < segLength(oldHeap, a_2, b_24) ==> segDegree(Heap, a_2, c, i_5_1_1) == segDegree(oldHeap, a_2, b_24, i_5_1_1)
    );
    if (*) {
      if (segLength(oldHeap, a_2, b_24) <= i_6_2 && i_6_2 < segLength(Heap, a_2, c)) {
        assert {:msg "  Postcondition of concat might not hold. Assertion segDegree(a, c, i) == old(segDegree(b, c, i - segLength(a, b))) might not hold. (BinomialHeap.vpr@146.10--146.142) [196835]"}
          segDegree(Heap, a_2, c, i_6_2) == segDegree(oldHeap, b_24, c, i_6_2 - segLength(oldHeap, a_2, b_24));
      }
      assume false;
    }
    assume (forall i_7_1_1: int ::
      { segDegree#frame(Heap[null, heapseg(a_2, c)], a_2, c, i_7_1_1) }
      segLength(oldHeap, a_2, b_24) <= i_7_1_1 && i_7_1_1 < segLength(Heap, a_2, c) ==> segDegree(Heap, a_2, c, i_7_1_1) == segDegree(oldHeap, b_24, c, i_7_1_1 - segLength(oldHeap, a_2, b_24))
    );
    if (c != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of concat might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.10--147.144) [196836]"}
          perm <= Mask[null, tree_1(c)];
      }
      Mask := Mask[null, tree_1(c):=Mask[null, tree_1(c)] - perm];
      assert {:msg "  Postcondition of concat might not hold. Assertion treeDegree(c) == old(treeDegree(c)) might not hold. (BinomialHeap.vpr@147.10--147.144) [196837]"}
        treeDegree(Heap, c) == treeDegree(oldHeap, c);
      assert {:msg "  Postcondition of concat might not hold. Assertion treeSize(c) == old(treeSize(c)) might not hold. (BinomialHeap.vpr@147.10--147.144) [196838]"}
        treeSize(Heap, c) == treeSize(oldHeap, c);
      assert {:msg "  Postcondition of concat might not hold. Assertion treeParent(c) == old(treeParent(c)) might not hold. (BinomialHeap.vpr@147.10--147.144) [196839]"}
        treeParent(Heap, c) == treeParent(oldHeap, c);
    }
    if (sorted_1(oldHeap, a_2, b_24) && (sorted_1(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))) {
      assert {:msg "  Postcondition of concat might not hold. Assertion sorted(a, c) might not hold. (BinomialHeap.vpr@149.10--150.127) [196840]"}
        sorted_1(Heap, a_2, c);
    }
    if (presorted(oldHeap, a_2, b_24) && (presorted(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) <= segDegree(oldHeap, b_24, c, 0) && ((2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)) && (2 <= segLength(oldHeap, b_24, c) && segDegree(oldHeap, b_24, c, 0) == segDegree(oldHeap, b_24, c, 1) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))))) {
      assert {:msg "  Postcondition of concat might not hold. Assertion presorted(a, c) might not hold. (BinomialHeap.vpr@152.10--156.20) [196841]"}
        presorted(Heap, a_2, c);
    }
    if (validChildren(oldHeap, a_2, b_24) && (validChildren(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, b_24, c, 0) + 1))) {
      assert {:msg "  Postcondition of concat might not hold. Assertion validChildren(a, c) might not hold. (BinomialHeap.vpr@157.10--160.20) [196842]"}
        validChildren(Heap, a_2, c);
    }
    assert {:msg "  Postcondition of concat might not hold. Assertion segSize(a, c) == old(segSize(a, b)) + old(segSize(b, c)) might not hold. (BinomialHeap.vpr@161.10--161.66) [196843]"}
      segSize(Heap, a_2, c) == segSize(oldHeap, a_2, b_24) + segSize(oldHeap, b_24, c);
    if (a_2 != b_24) {
      assert {:msg "  Postcondition of concat might not hold. Assertion segParent(a, c) == old(segParent(a, b)) might not hold. (BinomialHeap.vpr@162.10--162.60) [196844]"}
        segParent(Heap, a_2, c) == segParent(oldHeap, a_2, b_24);
    }
    if (b_24 != c) {
      assert {:msg "  Postcondition of concat might not hold. Assertion segParent(a, c) == old(segParent(b, c)) might not hold. (BinomialHeap.vpr@163.10--163.60) [196845]"}
        segParent(Heap, a_2, c) == segParent(oldHeap, b_24, c);
    }
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method findMinNode
// ==================================================

procedure findMinNode(arg_10: Ref) returns (res: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var x: Ref;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  var vmin: int;
  var freshVersion: FrameType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var tmp: Ref;
  var newVersion: FrameType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[arg_10, $allocated];
  
  // -- Checked inhaling of precondition
    assume arg_10 != null;
    perm := FullPerm;
    Mask := Mask[null, heapseg(arg_10, null):=Mask[null, heapseg(arg_10, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(arg, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@177.48--177.65) [196846]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(Heap, arg_10, null);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    assume res != null;
    assume state(PostHeap, PostMask);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(arg_10, res):=PostMask[null, heapseg(arg_10, res)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(arg, res)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@179.31--179.47) [196847]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg_10, res)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(PostHeap, arg_10, res);
    assume state(PostHeap, PostMask);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(res, null):=PostMask[null, heapseg(res, null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(res, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@180.32--180.49) [196848]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(PostHeap, res, null);
    assume state(PostHeap, PostMask);
    if (arg_10 != res) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, null, 0)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@181.45--181.64) [196849]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg_10, res)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@181.25--181.69) [196850]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg_10, res)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(arg, res) - 1 might not hold. (BinomialHeap.vpr@181.25--181.69) [196851]"}
            0 <= segLength(PostHeap, arg_10, res) - 1;
          assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(arg, res) - 1 < segLength(arg, res) might not hold. (BinomialHeap.vpr@181.25--181.69) [196852]"}
            segLength(PostHeap, arg_10, res) - 1 < segLength(PostHeap, arg_10, res);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@181.72--181.95) [196853]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(res, null) might not hold. (BinomialHeap.vpr@181.72--181.95) [196854]"}
            0 < segLength(PostHeap, res, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segDegree(PostHeap, arg_10, res, segLength(PostHeap, arg_10, res) - 1) < segDegree(PostHeap, res, null, 0);
    }
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(arg, res) + segSize(res, null) == old(segSize(arg, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@182.10--182.27) [196855]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg_10, res)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@182.30--182.48) [196856]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@182.56--182.74) [196857]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg_10, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, arg_10, res) + segSize(PostHeap, res, null) == segSize(oldHeap, arg_10, null);
    assume state(PostHeap, PostMask);
    if (arg_10 != res) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segParent(arg, res) == old(segParent(arg, null))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@183.25--183.44) [196858]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg_10, res)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@183.25--183.44) [196859]"}
            arg_10 != res;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@183.52--183.72) [196860]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg_10, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@183.52--183.72) [196861]"}
            arg_10 != null;
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume segParent(PostHeap, arg_10, res) == segParent(oldHeap, arg_10, null);
    }
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(res, null) == old(segParent(arg, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@184.10--184.30) [196862]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@184.10--184.30) [196863]"}
          res != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@184.38--184.58) [196864]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg_10, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@184.38--184.58) [196865]"}
          arg_10 != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, res, null) == segParent(oldHeap, arg_10, null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[x, $allocated];
  
  // -- Translating statement: x := arg -- BinomialHeap.vpr@186.2--186.19
    x := arg_10;
    assume state(Heap, Mask);
  
  // -- Translating statement: res := arg -- BinomialHeap.vpr@187.2--187.12
    res := arg_10;
    assume state(Heap, Mask);
  
  // -- Translating statement: min := (unfolding acc(heapseg(x, null), write) in treeKey(x)) -- BinomialHeap.vpr@190.2--190.49
    
    // -- Check definedness of (unfolding acc(heapseg(x, null), write) in treeKey(x))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume heapseg#trigger(UnfoldingHeap, heapseg(x, null));
      assume UnfoldingHeap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(UnfoldingHeap[null, tree_1(x)], CombineFrames(FrameFragment(UnfoldingHeap[x, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[x, sibling], null)], FrameFragment((if UnfoldingHeap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Assignment might fail. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@190.2--190.49) [196866]"}
          perm <= UnfoldingMask[null, heapseg(x, null)];
      }
      UnfoldingMask := UnfoldingMask[null, heapseg(x, null):=UnfoldingMask[null, heapseg(x, null)] - perm];
      if (x != null) {
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, tree_1(x):=UnfoldingMask[null, tree_1(x)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(x, null), UnfoldingHeap[null, heapseg(x, null)], tree_1(x), UnfoldingHeap[null, tree_1(x)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        assume x != null;
        UnfoldingMask := UnfoldingMask[x, sibling:=UnfoldingMask[x, sibling] + perm];
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[x, sibling], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[x, sibling], null)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(x, null), UnfoldingHeap[null, heapseg(x, null)], heapseg(UnfoldingHeap[x, sibling], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[x, sibling], null)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        if (UnfoldingHeap[x, sibling] != null) {
          assume state(UnfoldingHeap, UnfoldingMask);
          assume treeParent(UnfoldingHeap, x) == segParent(UnfoldingHeap, UnfoldingHeap[x, sibling], null);
        }
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@190.39--190.49) [196867]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(x)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
        UnfoldingHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      
      // -- Free assumptions (exp module)
        if (x != null) {
          havoc newPMask;
          assume (forall <A, B> o_71: Ref, f_35: (Field A B) ::
            { newPMask[o_71, f_35] }
            Heap[null, heapseg#sm(x, null)][o_71, f_35] || Heap[null, tree#sm(x)][o_71, f_35] ==> newPMask[o_71, f_35]
          );
          Heap := Heap[null, heapseg#sm(x, null):=newPMask];
          Heap := Heap[null, heapseg#sm(x, null):=Heap[null, heapseg#sm(x, null)][x, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_72: Ref, f_79: (Field A B) ::
            { newPMask[o_72, f_79] }
            Heap[null, heapseg#sm(x, null)][o_72, f_79] || Heap[null, heapseg#sm(Heap[x, sibling], null)][o_72, f_79] ==> newPMask[o_72, f_79]
          );
          Heap := Heap[null, heapseg#sm(x, null):=newPMask];
        }
        assume state(Heap, Mask);
    vmin := treeKey(Heap, x);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(arg, res), write) -- BinomialHeap.vpr@191.2--191.24
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (arg_10 != res) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(arg, res) might fail. There might be insufficient permission to access tree(arg) (BinomialHeap.vpr@191.2--191.24) [196870]"}
          perm <= Mask[null, tree_1(arg_10)];
      }
      Mask := Mask[null, tree_1(arg_10):=Mask[null, tree_1(arg_10)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(arg_10, res), Heap[null, heapseg(arg_10, res)], tree_1(arg_10), Heap[null, tree_1(arg_10)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(arg, res) might fail. There might be insufficient permission to access arg.sibling (BinomialHeap.vpr@191.2--191.24) [196872]"}
          perm <= Mask[arg_10, sibling];
      }
      Mask := Mask[arg_10, sibling:=Mask[arg_10, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(arg, res) might fail. There might be insufficient permission to access heapseg(arg.sibling, res) (BinomialHeap.vpr@191.2--191.24) [196874]"}
          perm <= Mask[null, heapseg(Heap[arg_10, sibling], res)];
      }
      Mask := Mask[null, heapseg(Heap[arg_10, sibling], res):=Mask[null, heapseg(Heap[arg_10, sibling], res)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(arg_10, res), Heap[null, heapseg(arg_10, res)], heapseg(Heap[arg_10, sibling], res), Heap[null, heapseg(Heap[arg_10, sibling], res)]);
      if (Heap[arg_10, sibling] != res) {
        assert {:msg "  Folding heapseg(arg, res) might fail. Assertion treeParent(arg) == segParent(arg.sibling, res) might not hold. (BinomialHeap.vpr@191.2--191.24) [196875]"}
          treeParent(Heap, arg_10) == segParent(Heap, Heap[arg_10, sibling], res);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(arg_10, res));
    assume Heap[null, heapseg(arg_10, res)] == FrameFragment((if arg_10 != res then CombineFrames(Heap[null, tree_1(arg_10)], CombineFrames(FrameFragment(Heap[arg_10, sibling]), CombineFrames(Heap[null, heapseg(Heap[arg_10, sibling], res)], FrameFragment((if Heap[arg_10, sibling] != res then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(arg_10, res))) {
      Heap := Heap[null, heapseg#sm(arg_10, res):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(arg_10, res):=freshVersion];
    }
    if (arg_10 != res) {
      havoc newPMask;
      assume (forall <A, B> o_30: Ref, f_80: (Field A B) ::
        { newPMask[o_30, f_80] }
        Heap[null, heapseg#sm(arg_10, res)][o_30, f_80] || Heap[null, tree#sm(arg_10)][o_30, f_80] ==> newPMask[o_30, f_80]
      );
      Heap := Heap[null, heapseg#sm(arg_10, res):=newPMask];
      Heap := Heap[null, heapseg#sm(arg_10, res):=Heap[null, heapseg#sm(arg_10, res)][arg_10, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_79: Ref, f_36: (Field A B) ::
        { newPMask[o_79, f_36] }
        Heap[null, heapseg#sm(arg_10, res)][o_79, f_36] || Heap[null, heapseg#sm(Heap[arg_10, sibling], res)][o_79, f_36] ==> newPMask[o_79, f_36]
      );
      Heap := Heap[null, heapseg#sm(arg_10, res):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(res, x), write) -- BinomialHeap.vpr@192.2--192.22
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (res != x) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(res, x) might fail. There might be insufficient permission to access tree(res) (BinomialHeap.vpr@192.2--192.22) [196879]"}
          perm <= Mask[null, tree_1(res)];
      }
      Mask := Mask[null, tree_1(res):=Mask[null, tree_1(res)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(res, x), Heap[null, heapseg(res, x)], tree_1(res), Heap[null, tree_1(res)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(res, x) might fail. There might be insufficient permission to access res.sibling (BinomialHeap.vpr@192.2--192.22) [196881]"}
          perm <= Mask[res, sibling];
      }
      Mask := Mask[res, sibling:=Mask[res, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(res, x) might fail. There might be insufficient permission to access heapseg(res.sibling, x) (BinomialHeap.vpr@192.2--192.22) [196883]"}
          perm <= Mask[null, heapseg(Heap[res, sibling], x)];
      }
      Mask := Mask[null, heapseg(Heap[res, sibling], x):=Mask[null, heapseg(Heap[res, sibling], x)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(res, x), Heap[null, heapseg(res, x)], heapseg(Heap[res, sibling], x), Heap[null, heapseg(Heap[res, sibling], x)]);
      if (Heap[res, sibling] != x) {
        assert {:msg "  Folding heapseg(res, x) might fail. Assertion treeParent(res) == segParent(res.sibling, x) might not hold. (BinomialHeap.vpr@192.2--192.22) [196884]"}
          treeParent(Heap, res) == segParent(Heap, Heap[res, sibling], x);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(res, x));
    assume Heap[null, heapseg(res, x)] == FrameFragment((if res != x then CombineFrames(Heap[null, tree_1(res)], CombineFrames(FrameFragment(Heap[res, sibling]), CombineFrames(Heap[null, heapseg(Heap[res, sibling], x)], FrameFragment((if Heap[res, sibling] != x then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(res, x))) {
      Heap := Heap[null, heapseg#sm(res, x):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(res, x):=freshVersion];
    }
    if (res != x) {
      havoc newPMask;
      assume (forall <A, B> o_80: Ref, f_88: (Field A B) ::
        { newPMask[o_80, f_88] }
        Heap[null, heapseg#sm(res, x)][o_80, f_88] || Heap[null, tree#sm(res)][o_80, f_88] ==> newPMask[o_80, f_88]
      );
      Heap := Heap[null, heapseg#sm(res, x):=newPMask];
      Heap := Heap[null, heapseg#sm(res, x):=Heap[null, heapseg#sm(res, x)][res, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_31: Ref, f_89: (Field A B) ::
        { newPMask[o_31, f_89] }
        Heap[null, heapseg#sm(res, x)][o_31, f_89] || Heap[null, heapseg#sm(Heap[res, sibling], x)][o_31, f_89] ==> newPMask[o_31, f_89]
      );
      Heap := Heap[null, heapseg#sm(res, x):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: while (x != null) -- BinomialHeap.vpr@194.2--226.3
    
    // -- Before loop head
      
      // -- Exhale loop invariant before loop
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not hold on entry. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@195.13--195.50) [196886]"}
            perm <= Mask[null, heapseg(arg_10, res)];
        }
        Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not hold on entry. Assertion sorted(arg, res) might not hold. (BinomialHeap.vpr@195.13--195.50) [196887]"}
          sorted_1(Heap, arg_10, res);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not hold on entry. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@196.13--196.46) [196888]"}
            perm <= Mask[null, heapseg(res, x)];
        }
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not hold on entry. Assertion sorted(res, x) might not hold. (BinomialHeap.vpr@196.13--196.46) [196889]"}
          sorted_1(Heap, res, x);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not hold on entry. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@197.13--197.48) [196890]"}
            perm <= Mask[null, heapseg(x, null)];
        }
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not hold on entry. Assertion sorted(x, null) might not hold. (BinomialHeap.vpr@197.13--197.48) [196891]"}
          sorted_1(Heap, x, null);
        if (arg_10 != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not hold on entry. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not hold. (BinomialHeap.vpr@198.13--198.107) [196892]"}
            segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, res, x, 0);
        }
        if (x != null && res != x) {
          assert {:msg "  Loop invariant x != null && res != x ==> segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not hold on entry. Assertion segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@199.13--199.103) [196893]"}
            segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        if (arg_10 != res && (res == x && x != null)) {
          assert {:msg "  Loop invariant arg != res && (res == x && x != null) ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not hold on entry. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@200.13--200.121) [196894]"}
            segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assert {:msg "  Loop invariant res != null might not hold on entry. Assertion res != null might not hold. (BinomialHeap.vpr@201.13--201.24) [196895]"}
          res != null;
        assert {:msg "  Loop invariant segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not hold on entry. Assertion segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not hold. (BinomialHeap.vpr@202.13--202.94) [196896]"}
          segSize(Heap, arg_10, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg_10, null);
        if (arg_10 != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segParent(arg, res) == segParent(res, x) might not hold on entry. Assertion segParent(arg, res) == segParent(res, x) might not hold. (BinomialHeap.vpr@203.13--203.80) [196897]"}
            segParent(Heap, arg_10, res) == segParent(Heap, res, x);
        }
        if (res != x && x != null) {
          assert {:msg "  Loop invariant res != x && x != null ==> segParent(res, x) == segParent(x, null) might not hold on entry. Assertion segParent(res, x) == segParent(x, null) might not hold. (BinomialHeap.vpr@204.13--204.78) [196898]"}
            segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        if (arg_10 != res && x != null) {
          assert {:msg "  Loop invariant arg != res && x != null ==> segParent(arg, res) == segParent(x, null) might not hold on entry. Assertion segParent(arg, res) == segParent(x, null) might not hold. (BinomialHeap.vpr@205.13--205.82) [196899]"}
            segParent(Heap, arg_10, res) == segParent(Heap, x, null);
        }
        if (arg_10 != res) {
          assert {:msg "  Loop invariant arg != res ==> segParent(arg, res) == old(segParent(arg, null)) might not hold on entry. Assertion segParent(arg, res) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@206.13--206.76) [196900]"}
            segParent(Heap, arg_10, res) == segParent(oldHeap, arg_10, null);
        }
        if (res != x) {
          assert {:msg "  Loop invariant res != x ==> segParent(res, x) == old(segParent(arg, null)) might not hold on entry. Assertion segParent(res, x) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@207.13--207.72) [196901]"}
            segParent(Heap, res, x) == segParent(oldHeap, arg_10, null);
        }
        if (x != null) {
          assert {:msg "  Loop invariant x != null ==> segParent(x, null) == old(segParent(arg, null)) might not hold on entry. Assertion segParent(x, null) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@208.13--208.74) [196902]"}
            segParent(Heap, x, null) == segParent(oldHeap, arg_10, null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
    
    // -- Havoc loop written variables (except locals)
      havoc x, vmin, res;
      assume Heap[x, $allocated];
      assume Heap[res, $allocated];
    
    // -- Check definedness of invariant
      if (*) {
        perm := FullPerm;
        Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(arg, res)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@195.34--195.50) [196903]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted_1(Heap, arg_10, res);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(res, x)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@196.32--196.46) [196904]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted_1(Heap, res, x);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(x, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@197.33--197.48) [196905]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted_1(Heap, x, null);
        assume state(Heap, Mask);
        if (arg_10 != res && res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@198.60--198.79) [196906]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@198.40--198.84) [196907]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(arg, res) - 1 might not hold. (BinomialHeap.vpr@198.40--198.84) [196908]"}
                0 <= segLength(Heap, arg_10, res) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(arg, res) - 1 < segLength(arg, res) might not hold. (BinomialHeap.vpr@198.40--198.84) [196909]"}
                segLength(Heap, arg_10, res) - 1 < segLength(Heap, arg_10, res);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@198.87--198.107) [196910]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(res, x) might not hold. (BinomialHeap.vpr@198.87--198.107) [196911]"}
                0 < segLength(Heap, res, x);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, res, x, 0);
        }
        assume state(Heap, Mask);
        if (x != null && res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@199.57--199.74) [196912]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@199.39--199.79) [196913]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(res, x) - 1 might not hold. (BinomialHeap.vpr@199.39--199.79) [196914]"}
                0 <= segLength(Heap, res, x) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(res, x) - 1 < segLength(res, x) might not hold. (BinomialHeap.vpr@199.39--199.79) [196915]"}
                segLength(Heap, res, x) - 1 < segLength(Heap, res, x);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@199.82--199.103) [196916]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(x, null) might not hold. (BinomialHeap.vpr@199.82--199.103) [196917]"}
                0 < segLength(Heap, x, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        assume state(Heap, Mask);
        if (arg_10 != res && (res == x && x != null)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@200.73--200.92) [196918]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@200.53--200.97) [196919]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(arg, res) - 1 might not hold. (BinomialHeap.vpr@200.53--200.97) [196920]"}
                0 <= segLength(Heap, arg_10, res) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(arg, res) - 1 < segLength(arg, res) might not hold. (BinomialHeap.vpr@200.53--200.97) [196921]"}
                segLength(Heap, arg_10, res) - 1 < segLength(Heap, arg_10, res);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@200.100--200.121) [196922]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(x, null) might not hold. (BinomialHeap.vpr@200.100--200.121) [196923]"}
                0 < segLength(Heap, x, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assume state(Heap, Mask);
        assume res != null;
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null))
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@202.13--202.30) [196924]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@202.33--202.48) [196925]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@202.51--202.67) [196926]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@202.75--202.93) [196927]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg_10, null)];
            // Finish exhale
            // Stop execution
            assume false;
          }
        assume segSize(Heap, arg_10, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg_10, null);
        assume state(Heap, Mask);
        if (arg_10 != res && res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(arg, res) == segParent(res, x)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@203.40--203.59) [196928]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@203.40--203.59) [196929]"}
                arg_10 != res;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@203.63--203.80) [196930]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion res != x might not hold. (BinomialHeap.vpr@203.63--203.80) [196931]"}
                res != x;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, arg_10, res) == segParent(Heap, res, x);
        }
        assume state(Heap, Mask);
        if (res != x && x != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(res, x) == segParent(x, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@204.39--204.56) [196932]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion res != x might not hold. (BinomialHeap.vpr@204.39--204.56) [196933]"}
                res != x;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@204.60--204.78) [196934]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion x != null might not hold. (BinomialHeap.vpr@204.60--204.78) [196935]"}
                x != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        assume state(Heap, Mask);
        if (arg_10 != res && x != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(arg, res) == segParent(x, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@205.41--205.60) [196936]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@205.41--205.60) [196937]"}
                arg_10 != res;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@205.64--205.82) [196938]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion x != null might not hold. (BinomialHeap.vpr@205.64--205.82) [196939]"}
                x != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, arg_10, res) == segParent(Heap, x, null);
        }
        assume state(Heap, Mask);
        if (arg_10 != res) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(arg, res) == old(segParent(arg, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@206.28--206.47) [196940]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg_10, res)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@206.28--206.47) [196941]"}
                arg_10 != res;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@206.55--206.75) [196942]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg_10, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@206.55--206.75) [196943]"}
                arg_10 != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, arg_10, res) == segParent(oldHeap, arg_10, null);
        }
        assume state(Heap, Mask);
        if (res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(res, x) == old(segParent(arg, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@207.26--207.43) [196944]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion res != x might not hold. (BinomialHeap.vpr@207.26--207.43) [196945]"}
                res != x;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@207.51--207.71) [196946]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg_10, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@207.51--207.71) [196947]"}
                arg_10 != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, res, x) == segParent(oldHeap, arg_10, null);
        }
        assume state(Heap, Mask);
        if (x != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(x, null) == old(segParent(arg, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@208.27--208.45) [196948]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion x != null might not hold. (BinomialHeap.vpr@208.27--208.45) [196949]"}
                x != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@208.53--208.73) [196950]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg_10, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@208.53--208.73) [196951]"}
                arg_10 != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, x, null) == segParent(oldHeap, arg_10, null);
        }
        assume state(Heap, Mask);
        assume false;
      }
    
    // -- Check the loop body
      if (*) {
        // Reset state
        loopHeap := Heap;
        loopMask := Mask;
        Mask := ZeroMask;
        assume state(Heap, Mask);
        // Inhale invariant
        perm := FullPerm;
        Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted_1(Heap, arg_10, res);
        perm := FullPerm;
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted_1(Heap, res, x);
        perm := FullPerm;
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted_1(Heap, x, null);
        if (arg_10 != res && res != x) {
          assume state(Heap, Mask);
          assume segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, res, x, 0);
        }
        if (x != null && res != x) {
          assume state(Heap, Mask);
          assume segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        if (arg_10 != res && (res == x && x != null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assume res != null;
        assume state(Heap, Mask);
        assume segSize(Heap, arg_10, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg_10, null);
        if (arg_10 != res && res != x) {
          assume state(Heap, Mask);
          assume segParent(Heap, arg_10, res) == segParent(Heap, res, x);
        }
        if (res != x && x != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        if (arg_10 != res && x != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, arg_10, res) == segParent(Heap, x, null);
        }
        if (arg_10 != res) {
          assume state(Heap, Mask);
          assume segParent(Heap, arg_10, res) == segParent(oldHeap, arg_10, null);
        }
        if (res != x) {
          assume state(Heap, Mask);
          assume segParent(Heap, res, x) == segParent(oldHeap, arg_10, null);
        }
        if (x != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, x, null) == segParent(oldHeap, arg_10, null);
        }
        assume state(Heap, Mask);
        // Check and assume guard
        assume x != null;
        assume state(Heap, Mask);
        
        // -- Translate loop body
          
          // -- Assumptions about local variables
            assume Heap[tmp, $allocated];
          
          // -- Translating statement: unfold acc(heapseg(x, null), write) -- BinomialHeap.vpr@210.3--210.26
            assume heapseg#trigger(Heap, heapseg(x, null));
            assume Heap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(Heap[null, tree_1(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], null)], FrameFragment((if Heap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(x, null) might fail. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@210.3--210.26) [196952]"}
                perm <= Mask[null, heapseg(x, null)];
            }
            Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(x, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(x, null):=newVersion];
              }
            if (x != null) {
              perm := FullPerm;
              Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], tree_1(x), Heap[null, tree_1(x)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume x != null;
              Mask := Mask[x, sibling:=Mask[x, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[x, sibling], null):=Mask[null, heapseg(Heap[x, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], heapseg(Heap[x, sibling], null), Heap[null, heapseg(Heap[x, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[x, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (treeKey(x) < min) -- BinomialHeap.vpr@211.3--216.4
            
            // -- Check definedness of treeKey(x) < min
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@211.6--211.16) [196953]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree_1(x)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (treeKey(Heap, x) < vmin) {
              
              // -- Translating statement: concat(arg, res, x) -- BinomialHeap.vpr@212.4--212.23
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@212.4--212.23) [196954]"}
                      perm <= Mask[null, heapseg(arg_10, res)];
                  }
                  Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@212.4--212.23) [196955]"}
                      perm <= Mask[null, heapseg(res, x)];
                  }
                  Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] - perm];
                  if (x != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@212.4--212.23) [196956]"}
                        perm <= Mask[null, tree_1(x)];
                    }
                    Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] - perm];
                  }
                  if (arg_10 != res && res != x) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(arg, res) == segParent(res, x) might not hold. (BinomialHeap.vpr@212.4--212.23) [196957]"}
                      segParent(Heap, arg_10, res) == segParent(Heap, res, x);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(arg_10, x):=Mask[null, heapseg(arg_10, x)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, arg_10, x) == segLength(PreCallHeap, arg_10, res) + segLength(PreCallHeap, res, x);
                  assume state(Heap, Mask);
                  assume (forall i: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_10, x)], arg_10, x, i) } { segDegree#frame(PreCallHeap[null, heapseg(arg_10, res)], arg_10, res, i) }
                    0 <= i && i < segLength(PreCallHeap, arg_10, res) ==> segDegree(Heap, arg_10, x, i) == segDegree(PreCallHeap, arg_10, res, i)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_1: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_10, x)], arg_10, x, i_1) }
                    segLength(PreCallHeap, arg_10, res) <= i_1 && i_1 < segLength(Heap, arg_10, x) ==> segDegree(Heap, arg_10, x, i_1) == segDegree(PreCallHeap, res, x, i_1 - segLength(PreCallHeap, arg_10, res))
                  );
                  if (x != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, x) == treeDegree(PreCallHeap, x);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, x) == treeSize(PreCallHeap, x);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, x) == treeParent(PreCallHeap, x);
                  }
                  if (sorted_1(PreCallHeap, arg_10, res) && (sorted_1(PreCallHeap, res, x) && (0 < segLength(PreCallHeap, arg_10, res) && 0 < segLength(PreCallHeap, res, x) ==> segDegree(PreCallHeap, arg_10, res, segLength(PreCallHeap, arg_10, res) - 1) < segDegree(PreCallHeap, res, x, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted_1(Heap, arg_10, x);
                  }
                  if (presorted(PreCallHeap, arg_10, res) && (presorted(PreCallHeap, res, x) && (0 < segLength(PreCallHeap, arg_10, res) && 0 < segLength(PreCallHeap, res, x) ==> segDegree(PreCallHeap, arg_10, res, segLength(PreCallHeap, arg_10, res) - 1) <= segDegree(PreCallHeap, res, x, 0) && ((2 <= segLength(PreCallHeap, arg_10, res) && segDegree(PreCallHeap, arg_10, res, segLength(PreCallHeap, arg_10, res) - 1) == segDegree(PreCallHeap, arg_10, res, segLength(PreCallHeap, arg_10, res) - 2) ==> segDegree(PreCallHeap, arg_10, res, segLength(PreCallHeap, arg_10, res) - 1) < segDegree(PreCallHeap, res, x, 0)) && (2 <= segLength(PreCallHeap, res, x) && segDegree(PreCallHeap, res, x, 0) == segDegree(PreCallHeap, res, x, 1) ==> segDegree(PreCallHeap, arg_10, res, segLength(PreCallHeap, arg_10, res) - 1) < segDegree(PreCallHeap, res, x, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, arg_10, x);
                  }
                  if (validChildren(PreCallHeap, arg_10, res) && (validChildren(PreCallHeap, res, x) && (0 < segLength(PreCallHeap, arg_10, res) && 0 < segLength(PreCallHeap, res, x) ==> segDegree(PreCallHeap, arg_10, res, segLength(PreCallHeap, arg_10, res) - 1) == segDegree(PreCallHeap, res, x, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, arg_10, x);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, arg_10, x) == segSize(PreCallHeap, arg_10, res) + segSize(PreCallHeap, res, x);
                  if (arg_10 != res) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_10, x) == segParent(PreCallHeap, arg_10, res);
                  }
                  if (res != x) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_10, x) == segParent(PreCallHeap, res, x);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: res := x -- BinomialHeap.vpr@213.4--213.12
                res := x;
                assume state(Heap, Mask);
              
              // -- Translating statement: min := treeKey(x) -- BinomialHeap.vpr@214.4--214.21
                
                // -- Check definedness of treeKey(x)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@214.11--214.21) [196958]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree_1(x)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                vmin := treeKey(Heap, x);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(res, res), write) -- BinomialHeap.vpr@215.4--215.26
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (res != res) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(res, res) might fail. There might be insufficient permission to access tree(res) (BinomialHeap.vpr@215.4--215.26) [196959]"}
                      perm <= Mask[null, tree_1(res)];
                  }
                  Mask := Mask[null, tree_1(res):=Mask[null, tree_1(res)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(res, res), Heap[null, heapseg(res, res)], tree_1(res), Heap[null, tree_1(res)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(res, res) might fail. There might be insufficient permission to access res.sibling (BinomialHeap.vpr@215.4--215.26) [196960]"}
                      perm <= Mask[res, sibling];
                  }
                  Mask := Mask[res, sibling:=Mask[res, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(res, res) might fail. There might be insufficient permission to access heapseg(res.sibling, res) (BinomialHeap.vpr@215.4--215.26) [196961]"}
                      perm <= Mask[null, heapseg(Heap[res, sibling], res)];
                  }
                  Mask := Mask[null, heapseg(Heap[res, sibling], res):=Mask[null, heapseg(Heap[res, sibling], res)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(res, res), Heap[null, heapseg(res, res)], heapseg(Heap[res, sibling], res), Heap[null, heapseg(Heap[res, sibling], res)]);
                  if (Heap[res, sibling] != res) {
                    assert {:msg "  Folding heapseg(res, res) might fail. Assertion treeParent(res) == segParent(res.sibling, res) might not hold. (BinomialHeap.vpr@215.4--215.26) [196962]"}
                      treeParent(Heap, res) == segParent(Heap, Heap[res, sibling], res);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(res, res):=Mask[null, heapseg(res, res)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(res, res));
                assume Heap[null, heapseg(res, res)] == FrameFragment((if res != res then CombineFrames(Heap[null, tree_1(res)], CombineFrames(FrameFragment(Heap[res, sibling]), CombineFrames(Heap[null, heapseg(Heap[res, sibling], res)], FrameFragment((if Heap[res, sibling] != res then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(res, res))) {
                  Heap := Heap[null, heapseg#sm(res, res):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(res, res):=freshVersion];
                }
                if (res != res) {
                  havoc newPMask;
                  assume (forall <A, B> o_81: Ref, f_90: (Field A B) ::
                    { newPMask[o_81, f_90] }
                    Heap[null, heapseg#sm(res, res)][o_81, f_90] || Heap[null, tree#sm(res)][o_81, f_90] ==> newPMask[o_81, f_90]
                  );
                  Heap := Heap[null, heapseg#sm(res, res):=newPMask];
                  Heap := Heap[null, heapseg#sm(res, res):=Heap[null, heapseg#sm(res, res)][res, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_82: Ref, f_91: (Field A B) ::
                    { newPMask[o_82, f_91] }
                    Heap[null, heapseg#sm(res, res)][o_82, f_91] || Heap[null, heapseg#sm(Heap[res, sibling], res)][o_82, f_91] ==> newPMask[o_82, f_91]
                  );
                  Heap := Heap[null, heapseg#sm(res, res):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
          
          // -- Translating statement: tmp := x -- BinomialHeap.vpr@217.3--217.20
            tmp := x;
            assume state(Heap, Mask);
          
          // -- Translating statement: x := x.sibling -- BinomialHeap.vpr@218.3--218.17
            
            // -- Check definedness of x.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access x.sibling (BinomialHeap.vpr@218.3--218.17) [196963]"}
                HasDirectPerm(Mask, x, sibling);
            x := Heap[x, sibling];
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(x, x), write) -- BinomialHeap.vpr@220.3--220.21
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (x != x) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, x) might fail. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@220.3--220.21) [196964]"}
                  perm <= Mask[null, tree_1(x)];
              }
              Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, x), Heap[null, heapseg(x, x)], tree_1(x), Heap[null, tree_1(x)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, x) might fail. There might be insufficient permission to access x.sibling (BinomialHeap.vpr@220.3--220.21) [196965]"}
                  perm <= Mask[x, sibling];
              }
              Mask := Mask[x, sibling:=Mask[x, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, x) might fail. There might be insufficient permission to access heapseg(x.sibling, x) (BinomialHeap.vpr@220.3--220.21) [196966]"}
                  perm <= Mask[null, heapseg(Heap[x, sibling], x)];
              }
              Mask := Mask[null, heapseg(Heap[x, sibling], x):=Mask[null, heapseg(Heap[x, sibling], x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, x), Heap[null, heapseg(x, x)], heapseg(Heap[x, sibling], x), Heap[null, heapseg(Heap[x, sibling], x)]);
              if (Heap[x, sibling] != x) {
                assert {:msg "  Folding heapseg(x, x) might fail. Assertion treeParent(x) == segParent(x.sibling, x) might not hold. (BinomialHeap.vpr@220.3--220.21) [196967]"}
                  treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], x);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(x, x):=Mask[null, heapseg(x, x)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(x, x));
            assume Heap[null, heapseg(x, x)] == FrameFragment((if x != x then CombineFrames(Heap[null, tree_1(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], x)], FrameFragment((if Heap[x, sibling] != x then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(x, x))) {
              Heap := Heap[null, heapseg#sm(x, x):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(x, x):=freshVersion];
            }
            if (x != x) {
              havoc newPMask;
              assume (forall <A, B> o_62: Ref, f_47: (Field A B) ::
                { newPMask[o_62, f_47] }
                Heap[null, heapseg#sm(x, x)][o_62, f_47] || Heap[null, tree#sm(x)][o_62, f_47] ==> newPMask[o_62, f_47]
              );
              Heap := Heap[null, heapseg#sm(x, x):=newPMask];
              Heap := Heap[null, heapseg#sm(x, x):=Heap[null, heapseg#sm(x, x)][x, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_83: Ref, f_72: (Field A B) ::
                { newPMask[o_83, f_72] }
                Heap[null, heapseg#sm(x, x)][o_83, f_72] || Heap[null, heapseg#sm(Heap[x, sibling], x)][o_83, f_72] ==> newPMask[o_83, f_72]
              );
              Heap := Heap[null, heapseg#sm(x, x):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(tmp, x), write) -- BinomialHeap.vpr@221.3--221.23
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (tmp != x) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@221.3--221.23) [196968]"}
                  perm <= Mask[null, tree_1(tmp)];
              }
              Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(tmp, x), Heap[null, heapseg(tmp, x)], tree_1(tmp), Heap[null, tree_1(tmp)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@221.3--221.23) [196969]"}
                  perm <= Mask[tmp, sibling];
              }
              Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. There might be insufficient permission to access heapseg(tmp.sibling, x) (BinomialHeap.vpr@221.3--221.23) [196970]"}
                  perm <= Mask[null, heapseg(Heap[tmp, sibling], x)];
              }
              Mask := Mask[null, heapseg(Heap[tmp, sibling], x):=Mask[null, heapseg(Heap[tmp, sibling], x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(tmp, x), Heap[null, heapseg(tmp, x)], heapseg(Heap[tmp, sibling], x), Heap[null, heapseg(Heap[tmp, sibling], x)]);
              if (Heap[tmp, sibling] != x) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, x) might not hold. (BinomialHeap.vpr@221.3--221.23) [196971]"}
                  treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], x);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(tmp, x):=Mask[null, heapseg(tmp, x)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(tmp, x));
            assume Heap[null, heapseg(tmp, x)] == FrameFragment((if tmp != x then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], x)], FrameFragment((if Heap[tmp, sibling] != x then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(tmp, x))) {
              Heap := Heap[null, heapseg#sm(tmp, x):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(tmp, x):=freshVersion];
            }
            if (tmp != x) {
              havoc newPMask;
              assume (forall <A, B> o_84: Ref, f_92: (Field A B) ::
                { newPMask[o_84, f_92] }
                Heap[null, heapseg#sm(tmp, x)][o_84, f_92] || Heap[null, tree#sm(tmp)][o_84, f_92] ==> newPMask[o_84, f_92]
              );
              Heap := Heap[null, heapseg#sm(tmp, x):=newPMask];
              Heap := Heap[null, heapseg#sm(tmp, x):=Heap[null, heapseg#sm(tmp, x)][tmp, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_63: Ref, f_48: (Field A B) ::
                { newPMask[o_63, f_48] }
                Heap[null, heapseg#sm(tmp, x)][o_63, f_48] || Heap[null, heapseg#sm(Heap[tmp, sibling], x)][o_63, f_48] ==> newPMask[o_63, f_48]
              );
              Heap := Heap[null, heapseg#sm(tmp, x):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: unfold acc(heapseg(x, null), write) -- BinomialHeap.vpr@222.3--222.26
            assume heapseg#trigger(Heap, heapseg(x, null));
            assume Heap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(Heap[null, tree_1(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], null)], FrameFragment((if Heap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(x, null) might fail. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@222.3--222.26) [196972]"}
                perm <= Mask[null, heapseg(x, null)];
            }
            Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(x, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(x, null):=newVersion];
              }
            if (x != null) {
              perm := FullPerm;
              Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], tree_1(x), Heap[null, tree_1(x)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume x != null;
              Mask := Mask[x, sibling:=Mask[x, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[x, sibling], null):=Mask[null, heapseg(Heap[x, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], heapseg(Heap[x, sibling], null), Heap[null, heapseg(Heap[x, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[x, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: concat(res, tmp, x) -- BinomialHeap.vpr@224.3--224.22
            PreCallHeap := Heap;
            PreCallMask := Mask;
            
            // -- Exhaling precondition
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(res, tmp) (BinomialHeap.vpr@224.3--224.22) [196973]"}
                  perm <= Mask[null, heapseg(res, tmp)];
              }
              Mask := Mask[null, heapseg(res, tmp):=Mask[null, heapseg(res, tmp)] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(tmp, x) (BinomialHeap.vpr@224.3--224.22) [196974]"}
                  perm <= Mask[null, heapseg(tmp, x)];
              }
              Mask := Mask[null, heapseg(tmp, x):=Mask[null, heapseg(tmp, x)] - perm];
              if (x != null) {
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@224.3--224.22) [196975]"}
                    perm <= Mask[null, tree_1(x)];
                }
                Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] - perm];
              }
              if (res != tmp && tmp != x) {
                assert {:msg "  The precondition of method concat might not hold. Assertion segParent(res, tmp) == segParent(tmp, x) might not hold. (BinomialHeap.vpr@224.3--224.22) [196976]"}
                  segParent(Heap, res, tmp) == segParent(Heap, tmp, x);
              }
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
            
            // -- Inhaling postcondition
              perm := FullPerm;
              Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume segLength(Heap, res, x) == segLength(PreCallHeap, res, tmp) + segLength(PreCallHeap, tmp, x);
              assume state(Heap, Mask);
              assume (forall i_2: int ::
                { segDegree#frame(Heap[null, heapseg(res, x)], res, x, i_2) } { segDegree#frame(PreCallHeap[null, heapseg(res, tmp)], res, tmp, i_2) }
                0 <= i_2 && i_2 < segLength(PreCallHeap, res, tmp) ==> segDegree(Heap, res, x, i_2) == segDegree(PreCallHeap, res, tmp, i_2)
              );
              assume state(Heap, Mask);
              assume (forall i_3_2: int ::
                { segDegree#frame(Heap[null, heapseg(res, x)], res, x, i_3_2) }
                segLength(PreCallHeap, res, tmp) <= i_3_2 && i_3_2 < segLength(Heap, res, x) ==> segDegree(Heap, res, x, i_3_2) == segDegree(PreCallHeap, tmp, x, i_3_2 - segLength(PreCallHeap, res, tmp))
              );
              if (x != null) {
                perm := FullPerm;
                Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume treeDegree(Heap, x) == treeDegree(PreCallHeap, x);
                assume state(Heap, Mask);
                assume treeSize(Heap, x) == treeSize(PreCallHeap, x);
                assume state(Heap, Mask);
                assume treeParent(Heap, x) == treeParent(PreCallHeap, x);
              }
              if (sorted_1(PreCallHeap, res, tmp) && (sorted_1(PreCallHeap, tmp, x) && (0 < segLength(PreCallHeap, res, tmp) && 0 < segLength(PreCallHeap, tmp, x) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) < segDegree(PreCallHeap, tmp, x, 0)))) {
                assume state(Heap, Mask);
                assume sorted_1(Heap, res, x);
              }
              if (presorted(PreCallHeap, res, tmp) && (presorted(PreCallHeap, tmp, x) && (0 < segLength(PreCallHeap, res, tmp) && 0 < segLength(PreCallHeap, tmp, x) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) <= segDegree(PreCallHeap, tmp, x, 0) && ((2 <= segLength(PreCallHeap, res, tmp) && segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) == segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 2) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) < segDegree(PreCallHeap, tmp, x, 0)) && (2 <= segLength(PreCallHeap, tmp, x) && segDegree(PreCallHeap, tmp, x, 0) == segDegree(PreCallHeap, tmp, x, 1) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) < segDegree(PreCallHeap, tmp, x, 0)))))) {
                assume state(Heap, Mask);
                assume presorted(Heap, res, x);
              }
              if (validChildren(PreCallHeap, res, tmp) && (validChildren(PreCallHeap, tmp, x) && (0 < segLength(PreCallHeap, res, tmp) && 0 < segLength(PreCallHeap, tmp, x) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) == segDegree(PreCallHeap, tmp, x, 0) + 1))) {
                assume state(Heap, Mask);
                assume validChildren(Heap, res, x);
              }
              assume state(Heap, Mask);
              assume segSize(Heap, res, x) == segSize(PreCallHeap, res, tmp) + segSize(PreCallHeap, tmp, x);
              if (res != tmp) {
                assume state(Heap, Mask);
                assume segParent(Heap, res, x) == segParent(PreCallHeap, res, tmp);
              }
              if (tmp != x) {
                assume state(Heap, Mask);
                assume segParent(Heap, res, x) == segParent(PreCallHeap, tmp, x);
              }
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(x, null), write) -- BinomialHeap.vpr@225.3--225.24
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (x != null) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, null) might fail. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@225.3--225.24) [196977]"}
                  perm <= Mask[null, tree_1(x)];
              }
              Mask := Mask[null, tree_1(x):=Mask[null, tree_1(x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], tree_1(x), Heap[null, tree_1(x)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, null) might fail. There might be insufficient permission to access x.sibling (BinomialHeap.vpr@225.3--225.24) [196978]"}
                  perm <= Mask[x, sibling];
              }
              Mask := Mask[x, sibling:=Mask[x, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, null) might fail. There might be insufficient permission to access heapseg(x.sibling, null) (BinomialHeap.vpr@225.3--225.24) [196979]"}
                  perm <= Mask[null, heapseg(Heap[x, sibling], null)];
              }
              Mask := Mask[null, heapseg(Heap[x, sibling], null):=Mask[null, heapseg(Heap[x, sibling], null)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], heapseg(Heap[x, sibling], null), Heap[null, heapseg(Heap[x, sibling], null)]);
              if (Heap[x, sibling] != null) {
                assert {:msg "  Folding heapseg(x, null) might fail. Assertion treeParent(x) == segParent(x.sibling, null) might not hold. (BinomialHeap.vpr@225.3--225.24) [196980]"}
                  treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], null);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(x, null));
            assume Heap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(Heap[null, tree_1(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], null)], FrameFragment((if Heap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(x, null))) {
              Heap := Heap[null, heapseg#sm(x, null):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(x, null):=freshVersion];
            }
            if (x != null) {
              havoc newPMask;
              assume (forall <A, B> o_28: Ref, f_93: (Field A B) ::
                { newPMask[o_28, f_93] }
                Heap[null, heapseg#sm(x, null)][o_28, f_93] || Heap[null, tree#sm(x)][o_28, f_93] ==> newPMask[o_28, f_93]
              );
              Heap := Heap[null, heapseg#sm(x, null):=newPMask];
              Heap := Heap[null, heapseg#sm(x, null):=Heap[null, heapseg#sm(x, null)][x, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_85: Ref, f_41: (Field A B) ::
                { newPMask[o_85, f_41] }
                Heap[null, heapseg#sm(x, null)][o_85, f_41] || Heap[null, heapseg#sm(Heap[x, sibling], null)][o_85, f_41] ==> newPMask[o_85, f_41]
              );
              Heap := Heap[null, heapseg#sm(x, null):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
        // Exhale invariant
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not be preserved. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@195.13--195.50) [196981]"}
            perm <= Mask[null, heapseg(arg_10, res)];
        }
        Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not be preserved. Assertion sorted(arg, res) might not hold. (BinomialHeap.vpr@195.13--195.50) [196982]"}
          sorted_1(Heap, arg_10, res);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not be preserved. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@196.13--196.46) [196983]"}
            perm <= Mask[null, heapseg(res, x)];
        }
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not be preserved. Assertion sorted(res, x) might not hold. (BinomialHeap.vpr@196.13--196.46) [196984]"}
          sorted_1(Heap, res, x);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not be preserved. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@197.13--197.48) [196985]"}
            perm <= Mask[null, heapseg(x, null)];
        }
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not be preserved. Assertion sorted(x, null) might not hold. (BinomialHeap.vpr@197.13--197.48) [196986]"}
          sorted_1(Heap, x, null);
        if (arg_10 != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not be preserved. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not hold. (BinomialHeap.vpr@198.13--198.107) [196987]"}
            segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, res, x, 0);
        }
        if (x != null && res != x) {
          assert {:msg "  Loop invariant x != null && res != x ==> segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not be preserved. Assertion segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@199.13--199.103) [196988]"}
            segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        if (arg_10 != res && (res == x && x != null)) {
          assert {:msg "  Loop invariant arg != res && (res == x && x != null) ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not be preserved. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@200.13--200.121) [196989]"}
            segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assert {:msg "  Loop invariant res != null might not be preserved. Assertion res != null might not hold. (BinomialHeap.vpr@201.13--201.24) [196990]"}
          res != null;
        assert {:msg "  Loop invariant segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not be preserved. Assertion segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not hold. (BinomialHeap.vpr@202.13--202.94) [196991]"}
          segSize(Heap, arg_10, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg_10, null);
        if (arg_10 != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segParent(arg, res) == segParent(res, x) might not be preserved. Assertion segParent(arg, res) == segParent(res, x) might not hold. (BinomialHeap.vpr@203.13--203.80) [196992]"}
            segParent(Heap, arg_10, res) == segParent(Heap, res, x);
        }
        if (res != x && x != null) {
          assert {:msg "  Loop invariant res != x && x != null ==> segParent(res, x) == segParent(x, null) might not be preserved. Assertion segParent(res, x) == segParent(x, null) might not hold. (BinomialHeap.vpr@204.13--204.78) [196993]"}
            segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        if (arg_10 != res && x != null) {
          assert {:msg "  Loop invariant arg != res && x != null ==> segParent(arg, res) == segParent(x, null) might not be preserved. Assertion segParent(arg, res) == segParent(x, null) might not hold. (BinomialHeap.vpr@205.13--205.82) [196994]"}
            segParent(Heap, arg_10, res) == segParent(Heap, x, null);
        }
        if (arg_10 != res) {
          assert {:msg "  Loop invariant arg != res ==> segParent(arg, res) == old(segParent(arg, null)) might not be preserved. Assertion segParent(arg, res) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@206.13--206.76) [196995]"}
            segParent(Heap, arg_10, res) == segParent(oldHeap, arg_10, null);
        }
        if (res != x) {
          assert {:msg "  Loop invariant res != x ==> segParent(res, x) == old(segParent(arg, null)) might not be preserved. Assertion segParent(res, x) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@207.13--207.72) [196996]"}
            segParent(Heap, res, x) == segParent(oldHeap, arg_10, null);
        }
        if (x != null) {
          assert {:msg "  Loop invariant x != null ==> segParent(x, null) == old(segParent(arg, null)) might not be preserved. Assertion segParent(x, null) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@208.13--208.74) [196997]"}
            segParent(Heap, x, null) == segParent(oldHeap, arg_10, null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Terminate execution
        assume false;
      }
    
    // -- Inhale loop invariant after loop, and assume guard
      assume !(x != null);
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted_1(Heap, arg_10, res);
      perm := FullPerm;
      Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted_1(Heap, res, x);
      perm := FullPerm;
      Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted_1(Heap, x, null);
      if (arg_10 != res && res != x) {
        assume state(Heap, Mask);
        assume segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, res, x, 0);
      }
      if (x != null && res != x) {
        assume state(Heap, Mask);
        assume segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
      }
      if (arg_10 != res && (res == x && x != null)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, x, null, 0);
      }
      assume res != null;
      assume state(Heap, Mask);
      assume segSize(Heap, arg_10, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg_10, null);
      if (arg_10 != res && res != x) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_10, res) == segParent(Heap, res, x);
      }
      if (res != x && x != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, res, x) == segParent(Heap, x, null);
      }
      if (arg_10 != res && x != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_10, res) == segParent(Heap, x, null);
      }
      if (arg_10 != res) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_10, res) == segParent(oldHeap, arg_10, null);
      }
      if (res != x) {
        assume state(Heap, Mask);
        assume segParent(Heap, res, x) == segParent(oldHeap, arg_10, null);
      }
      if (x != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, x, null) == segParent(oldHeap, arg_10, null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@178.10--178.21) [196998]"}
      res != null;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of findMinNode might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@179.10--179.47) [196999]"}
        perm <= Mask[null, heapseg(arg_10, res)];
    }
    Mask := Mask[null, heapseg(arg_10, res):=Mask[null, heapseg(arg_10, res)] - perm];
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion sorted(arg, res) might not hold. (BinomialHeap.vpr@179.10--179.47) [197000]"}
      sorted_1(Heap, arg_10, res);
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of findMinNode might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@180.10--180.49) [197001]"}
        perm <= Mask[null, heapseg(res, null)];
    }
    Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] - perm];
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion sorted(res, null) might not hold. (BinomialHeap.vpr@180.10--180.49) [197002]"}
      sorted_1(Heap, res, null);
    if (arg_10 != res) {
      assert {:msg "  Postcondition of findMinNode might not hold. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, null, 0) might not hold. (BinomialHeap.vpr@181.10--181.95) [197003]"}
        segDegree(Heap, arg_10, res, segLength(Heap, arg_10, res) - 1) < segDegree(Heap, res, null, 0);
    }
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion segSize(arg, res) + segSize(res, null) == old(segSize(arg, null)) might not hold. (BinomialHeap.vpr@182.10--182.75) [197004]"}
      segSize(Heap, arg_10, res) + segSize(Heap, res, null) == segSize(oldHeap, arg_10, null);
    if (arg_10 != res) {
      assert {:msg "  Postcondition of findMinNode might not hold. Assertion segParent(arg, res) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@183.10--183.73) [197005]"}
        segParent(Heap, arg_10, res) == segParent(oldHeap, arg_10, null);
    }
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion segParent(res, null) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@184.10--184.59) [197006]"}
      segParent(Heap, res, null) == segParent(oldHeap, arg_10, null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method merge
// ==================================================

procedure merge(this: Ref, binHeap: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var temp1: Ref;
  var temp2: Ref;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var tmp: Ref;
  var newVersion: FrameType;
  var ExhaleWellDef1Heap: HeapType;
  var ExhaleWellDef1Mask: MaskType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_a: Ref;
  var arg_a_1: Ref;
  var arg_a_2: Ref;
  var t_2: Ref;
  var Unfolding1Heap: HeapType;
  var Unfolding1Mask: MaskType;
  var Unfolding2Heap: HeapType;
  var Unfolding2Mask: MaskType;
  var arg_a_3: Ref;
  var arg_a_4: Ref;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
    assume Heap[binHeap, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@247.11--248.54) [197007]"}
        HasDirectPerm(Mask, this, Nodes_1);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@247.11--248.54) [197008]"}
        HasDirectPerm(Mask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@248.30--248.54) [197009]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(Heap, Heap[this, Nodes_1], null);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@249.11--249.29) [197010]"}
        HasDirectPerm(Mask, this, Nodes_1);
    assume Heap[this, Nodes_1] != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(binHeap, null):=Mask[null, heapseg(binHeap, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(binHeap, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@250.37--250.58) [197011]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(Heap, binHeap, null);
    assume state(Heap, Mask);
    if (binHeap != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.Nodes, null) == segParent(binHeap, null)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@251.11--251.86) [197012]"}
          HasDirectPerm(Mask, this, Nodes_1);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@251.31--251.58) [197013]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@251.31--251.58) [197014]"}
            Heap[this, Nodes_1] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@251.62--251.86) [197015]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion binHeap != null might not hold. (BinomialHeap.vpr@251.62--251.86) [197016]"}
            binHeap != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, Nodes_1], null) == segParent(Heap, binHeap, null);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    assume this != null;
    PostMask := PostMask[this, Nodes_1:=PostMask[this, Nodes_1] + perm];
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [197017]"}
        HasDirectPerm(PostMask, this, Nodes_1);
    assume PostHeap[this, Nodes_1] != null;
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [197018]"}
        HasDirectPerm(PostMask, this, Nodes_1);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(PostHeap[this, Nodes_1], null):=PostMask[null, heapseg(PostHeap[this, Nodes_1], null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of presorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [197019]"}
        HasDirectPerm(PostMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@252.80--252.107) [197020]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume presorted(PostHeap, PostHeap[this, Nodes_1], null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@253.10--253.99) [197021]"}
        HasDirectPerm(PostMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@253.10--253.35) [197022]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@253.10--253.99) [197023]"}
        HasDirectPerm(oldMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@253.43--253.68) [197024]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@253.76--253.98) [197025]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, PostHeap[this, Nodes_1], null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(this.Nodes, null) == old(segParent(this.Nodes, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@254.10--254.73) [197026]"}
        HasDirectPerm(PostMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@254.10--254.37) [197027]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes_1], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@254.10--254.37) [197028]"}
          PostHeap[this, Nodes_1] != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@254.10--254.73) [197029]"}
        HasDirectPerm(oldMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@254.45--254.72) [197030]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@254.45--254.72) [197031]"}
          oldHeap[this, Nodes_1] != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, PostHeap[this, Nodes_1], null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[temp1, $allocated];
    assume Heap[temp2, $allocated];
  
  // -- Translating statement: temp1 := this.Nodes -- BinomialHeap.vpr@258.2--258.21
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@258.2--258.21) [197032]"}
        HasDirectPerm(Mask, this, Nodes_1);
    temp1 := Heap[this, Nodes_1];
    assume state(Heap, Mask);
  
  // -- Translating statement: temp2 := binHeap -- BinomialHeap.vpr@259.2--259.18
    temp2 := binHeap;
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(this.Nodes, temp1), write) -- BinomialHeap.vpr@261.2--261.33
    
    // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
      assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@261.2--261.33) [197033]"}
        HasDirectPerm(Mask, this, Nodes_1);
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (Heap[this, Nodes_1] != temp1) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@261.2--261.33) [197036]"}
          perm <= Mask[null, tree_1(Heap[this, Nodes_1])];
      }
      Mask := Mask[null, tree_1(Heap[this, Nodes_1]):=Mask[null, tree_1(Heap[this, Nodes_1])] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp1), Heap[null, heapseg(Heap[this, Nodes_1], temp1)], tree_1(Heap[this, Nodes_1]), Heap[null, tree_1(Heap[this, Nodes_1])]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@261.2--261.33) [197038]"}
          perm <= Mask[Heap[this, Nodes_1], sibling];
      }
      Mask := Mask[Heap[this, Nodes_1], sibling:=Mask[Heap[this, Nodes_1], sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp1) (BinomialHeap.vpr@261.2--261.33) [197040]"}
          perm <= Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)];
      }
      Mask := Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1):=Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp1), Heap[null, heapseg(Heap[this, Nodes_1], temp1)], heapseg(Heap[Heap[this, Nodes_1], sibling], temp1), Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)]);
      if (Heap[Heap[this, Nodes_1], sibling] != temp1) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp1) might not hold. (BinomialHeap.vpr@261.2--261.33) [197041]"}
          treeParent(Heap, Heap[this, Nodes_1]) == segParent(Heap, Heap[Heap[this, Nodes_1], sibling], temp1);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes_1], temp1));
    assume Heap[null, heapseg(Heap[this, Nodes_1], temp1)] == FrameFragment((if Heap[this, Nodes_1] != temp1 then CombineFrames(Heap[null, tree_1(Heap[this, Nodes_1])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes_1], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)], FrameFragment((if Heap[Heap[this, Nodes_1], sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes_1], temp1))) {
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(Heap[this, Nodes_1], temp1):=freshVersion];
    }
    if (Heap[this, Nodes_1] != temp1) {
      havoc newPMask;
      assume (forall <A, B> o_86: Ref, f_94: (Field A B) ::
        { newPMask[o_86, f_94] }
        Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][o_86, f_94] || Heap[null, tree#sm(Heap[this, Nodes_1])][o_86, f_94] ==> newPMask[o_86, f_94]
      );
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=newPMask];
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][Heap[this, Nodes_1], sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_29: Ref, f_95: (Field A B) ::
        { newPMask[o_29, f_95] }
        Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][o_29, f_95] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes_1], sibling], temp1)][o_29, f_95] ==> newPMask[o_29, f_95]
      );
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: while (temp1 != null && temp2 != null) -- BinomialHeap.vpr@262.2--352.3
    
    // -- Before loop head
      
      // -- Exhale loop invariant before loop
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not hold on entry. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@263.13--263.56) [197043]"}
            perm <= Mask[null, heapseg(temp1, null)];
        }
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not hold on entry. Assertion sorted(temp1, null) might not hold. (BinomialHeap.vpr@263.13--263.56) [197044]"}
          sorted_1(Heap, temp1, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@264.13--264.56) [197045]"}
            perm <= Mask[null, heapseg(temp2, null)];
        }
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@264.13--264.56) [197046]"}
          sorted_1(Heap, temp2, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@265.13--265.50) [197047]"}
            perm <= Mask[this, Nodes_1];
        }
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
        assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@265.13--265.50) [197048]"}
          Heap[this, Nodes_1] != null;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@266.13--266.71) [197049]"}
            perm <= Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
        }
        Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@266.13--266.71) [197050]"}
          presorted(Heap, Heap[this, Nodes_1], temp1);
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp1, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [197051]"}
            segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [197052]"}
              segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp2, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [197053]"}
            segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [197054]"}
              segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@277.13--279.93) [197055]"}
            segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        if (temp1 != Heap[this, Nodes_1] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant temp1 != this.Nodes && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not hold on entry. Assertion segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@280.13--281.56) [197056]"}
            segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@282.13--282.149) [197057]"}
          segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        if (temp1 != null && temp2 != null) {
          assert {:msg "  Loop invariant temp1 != null && temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not hold on entry. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@283.13--283.96) [197058]"}
            segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes_1] != temp1 && temp1 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp1 != null ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@284.13--284.108) [197059]"}
            segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
        }
        if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@285.13--285.108) [197060]"}
            segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes_1] != temp1) {
          assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@286.13--286.101) [197061]"}
            segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        if (temp1 != null) {
          assert {:msg "  Loop invariant temp1 != null ==> segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@287.13--287.89) [197062]"}
            segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        if (temp2 != null) {
          assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@288.13--288.89) [197063]"}
            segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
    
    // -- Havoc loop written variables (except locals)
      havoc temp2, temp1;
      assume Heap[temp2, $allocated];
      assume Heap[temp1, $allocated];
    
    // -- Check definedness of invariant
      if (*) {
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(temp1, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@263.37--263.56) [197064]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted_1(Heap, temp1, null);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(temp2, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@264.37--264.56) [197065]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted_1(Heap, temp2, null);
        assume state(Heap, Mask);
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != null
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@265.13--265.50) [197066]"}
            HasDirectPerm(Mask, this, Nodes_1);
        assume Heap[this, Nodes_1] != null;
        assume state(Heap, Mask);
        
        // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@266.13--266.71) [197067]"}
            HasDirectPerm(Mask, this, Nodes_1);
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of presorted(this.Nodes, temp1)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@266.13--266.71) [197068]"}
            HasDirectPerm(Mask, this, Nodes_1);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@266.43--266.71) [197069]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume presorted(Heap, Heap[this, Nodes_1], temp1);
        assume state(Heap, Mask);
        
        // -- Check definedness of 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197070]"}
            HasDirectPerm(Mask, this, Nodes_1);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@267.17--267.45) [197071]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@267.53--267.75) [197072]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp1, null)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197073]"}
              HasDirectPerm(Mask, this, Nodes_1);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197074]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@268.31--268.59) [197075]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@268.2--268.64) [197076]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@268.2--268.64) [197077]"}
                0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@268.2--268.64) [197078]"}
                segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@268.68--268.93) [197079]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@268.68--268.93) [197080]"}
                0 < segLength(Heap, temp1, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          
          // -- Check definedness of 2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197081]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@269.8--269.36) [197082]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1)) {
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197083]"}
                HasDirectPerm(Mask, this, Nodes_1);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197084]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.31--270.59) [197085]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.2--270.64) [197086]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@270.2--270.64) [197087]"}
                  0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@270.2--270.64) [197088]"}
                  segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197089]"}
                HasDirectPerm(Mask, this, Nodes_1);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197090]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.97--270.125) [197091]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.68--270.130) [197092]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 2 might not hold. (BinomialHeap.vpr@270.68--270.130) [197093]"}
                  0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 2;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 2 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@270.68--270.130) [197094]"}
                  segLength(Heap, Heap[this, Nodes_1], temp1) - 2 < segLength(Heap, Heap[this, Nodes_1], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assume state(Heap, Mask);
            
            // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197095]"}
                HasDirectPerm(Mask, this, Nodes_1);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [197096]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@271.31--271.59) [197097]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@271.2--271.64) [197098]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@271.2--271.64) [197099]"}
                  0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@271.2--271.64) [197100]"}
                  segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@271.67--271.92) [197101]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@271.67--271.92) [197102]"}
                  0 < segLength(Heap, temp1, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197103]"}
            HasDirectPerm(Mask, this, Nodes_1);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@272.17--272.45) [197104]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@272.53--272.75) [197105]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp2, null)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197106]"}
              HasDirectPerm(Mask, this, Nodes_1);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197107]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@273.31--273.59) [197108]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@273.2--273.64) [197109]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@273.2--273.64) [197110]"}
                0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@273.2--273.64) [197111]"}
                segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@273.68--273.93) [197112]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@273.68--273.93) [197113]"}
                0 < segLength(Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          
          // -- Check definedness of 2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197114]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@274.8--274.36) [197115]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1)) {
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197116]"}
                HasDirectPerm(Mask, this, Nodes_1);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197117]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.31--275.59) [197118]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.2--275.64) [197119]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@275.2--275.64) [197120]"}
                  0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@275.2--275.64) [197121]"}
                  segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197122]"}
                HasDirectPerm(Mask, this, Nodes_1);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197123]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.97--275.125) [197124]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.68--275.130) [197125]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 2 might not hold. (BinomialHeap.vpr@275.68--275.130) [197126]"}
                  0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 2;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 2 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@275.68--275.130) [197127]"}
                  segLength(Heap, Heap[this, Nodes_1], temp1) - 2 < segLength(Heap, Heap[this, Nodes_1], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assume state(Heap, Mask);
            
            // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197128]"}
                HasDirectPerm(Mask, this, Nodes_1);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [197129]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@276.31--276.59) [197130]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@276.2--276.64) [197131]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@276.2--276.64) [197132]"}
                  0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@276.2--276.64) [197133]"}
                  segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@276.67--276.92) [197134]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@276.67--276.92) [197135]"}
                  0 < segLength(Heap, temp2, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of 0 < segLength(this.Nodes, temp1) && (0 < segLength(temp1, null) && 0 < segLength(temp2, null))
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [197136]"}
            HasDirectPerm(Mask, this, Nodes_1);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@277.17--277.45) [197137]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@277.53--277.75) [197138]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (0 < segLength(Heap, temp1, null)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@277.83--277.105) [197139]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [197140]"}
              HasDirectPerm(Mask, this, Nodes_1);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [197141]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@278.32--278.60) [197142]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@278.3--278.65) [197143]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@278.3--278.65) [197144]"}
                0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@278.3--278.65) [197145]"}
                segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@278.68--278.93) [197146]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@278.68--278.93) [197147]"}
                0 < segLength(Heap, temp1, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (!(segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0))) {
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [197148]"}
                HasDirectPerm(Mask, this, Nodes_1);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [197149]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@279.31--279.59) [197150]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@279.2--279.64) [197151]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@279.2--279.64) [197152]"}
                  0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@279.2--279.64) [197153]"}
                  segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@279.67--279.92) [197154]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@279.67--279.92) [197155]"}
                  0 < segLength(Heap, temp2, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of temp1 != this.Nodes && (0 < segLength(temp1, null) && 0 < segLength(temp2, null))
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@280.13--281.56) [197156]"}
            HasDirectPerm(Mask, this, Nodes_1);
          if (temp1 != Heap[this, Nodes_1]) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@280.40--280.62) [197157]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (0 < segLength(Heap, temp1, null)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@280.70--280.92) [197158]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          }
        if (temp1 != Heap[this, Nodes_1] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(temp1, null, 0) <= segDegree(temp2, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@281.2--281.27) [197159]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@281.2--281.27) [197160]"}
                0 < segLength(Heap, temp1, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@281.31--281.56) [197161]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@281.31--281.56) [197162]"}
                0 < segLength(Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@282.13--282.149) [197163]"}
            HasDirectPerm(Mask, this, Nodes_1);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@282.13--282.39) [197164]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@282.42--282.62) [197165]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@282.65--282.85) [197166]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@282.13--282.149) [197167]"}
            HasDirectPerm(oldMask, this, Nodes_1);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@282.93--282.118) [197168]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@282.126--282.148) [197169]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
            // Finish exhale
            // Stop execution
            assume false;
          }
        assume segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        assume state(Heap, Mask);
        if (temp1 != null && temp2 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(temp1, null) == segParent(temp2, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@283.48--283.70) [197170]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@283.48--283.70) [197171]"}
                temp1 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@283.74--283.96) [197172]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@283.74--283.96) [197173]"}
                temp2 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != temp1 && temp1 != null
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@284.13--284.108) [197174]"}
            HasDirectPerm(Mask, this, Nodes_1);
        if (Heap[this, Nodes_1] != temp1 && temp1 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp1, null)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@284.13--284.108) [197175]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@284.54--284.82) [197176]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@284.54--284.82) [197177]"}
                Heap[this, Nodes_1] != temp1;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@284.86--284.108) [197178]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@284.86--284.108) [197179]"}
                temp1 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != temp1 && temp2 != null
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@285.13--285.108) [197180]"}
            HasDirectPerm(Mask, this, Nodes_1);
        if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp2, null)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@285.13--285.108) [197181]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@285.54--285.82) [197182]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@285.54--285.82) [197183]"}
                Heap[this, Nodes_1] != temp1;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@285.86--285.108) [197184]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@285.86--285.108) [197185]"}
                temp2 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != temp1
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@286.13--286.101) [197186]"}
            HasDirectPerm(Mask, this, Nodes_1);
        if (Heap[this, Nodes_1] != temp1) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null))
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@286.13--286.101) [197187]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@286.37--286.65) [197188]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@286.37--286.65) [197189]"}
                Heap[this, Nodes_1] != temp1;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@286.13--286.101) [197190]"}
              HasDirectPerm(oldMask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@286.73--286.100) [197191]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@286.73--286.100) [197192]"}
                oldHeap[this, Nodes_1] != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        assume state(Heap, Mask);
        if (temp1 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(temp1, null) == old(segParent(this.Nodes, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@287.31--287.53) [197193]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@287.31--287.53) [197194]"}
                temp1 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@287.13--287.89) [197195]"}
              HasDirectPerm(oldMask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@287.61--287.88) [197196]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@287.61--287.88) [197197]"}
                oldHeap[this, Nodes_1] != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        assume state(Heap, Mask);
        if (temp2 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(temp2, null) == old(segParent(this.Nodes, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@288.31--288.53) [197198]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@288.31--288.53) [197199]"}
                temp2 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@288.13--288.89) [197200]"}
              HasDirectPerm(oldMask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@288.61--288.88) [197201]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@288.61--288.88) [197202]"}
                oldHeap[this, Nodes_1] != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        assume state(Heap, Mask);
        assume false;
      }
    
    // -- Check the loop body
      if (*) {
        // Reset state
        loopHeap := Heap;
        loopMask := Mask;
        Mask := ZeroMask;
        assume state(Heap, Mask);
        // Inhale invariant
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted_1(Heap, temp1, null);
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted_1(Heap, temp2, null);
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
        assume state(Heap, Mask);
        assume Heap[this, Nodes_1] != null;
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume presorted(Heap, Heap[this, Nodes_1], temp1);
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp1, null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp2, null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        if (temp1 != Heap[this, Nodes_1] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          assume segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assume state(Heap, Mask);
        assume segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        if (temp1 != null && temp2 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes_1] != temp1 && temp1 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
        }
        if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes_1] != temp1) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        if (temp1 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        if (temp2 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        assume state(Heap, Mask);
        // Check and assume guard
        assume temp1 != null && temp2 != null;
        assume state(Heap, Mask);
        
        // -- Translate loop body
          
          // -- Assumptions about local variables
            assume Heap[tmp, $allocated];
          
          // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@291.3--291.30
            assume heapseg#trigger(Heap, heapseg(temp1, null));
            assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@291.3--291.30) [197203]"}
                perm <= Mask[null, heapseg(temp1, null)];
            }
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(temp1, null):=newVersion];
              }
            if (temp1 != null) {
              perm := FullPerm;
              Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree_1(temp1), Heap[null, tree_1(temp1)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume temp1 != null;
              Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[temp1, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: unfold acc(heapseg(temp2, null), write) -- BinomialHeap.vpr@292.3--292.30
            assume heapseg#trigger(Heap, heapseg(temp2, null));
            assume Heap[null, heapseg(temp2, null)] == FrameFragment((if temp2 != null then CombineFrames(Heap[null, tree_1(temp2)], CombineFrames(FrameFragment(Heap[temp2, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp2, sibling], null)], FrameFragment((if Heap[temp2, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(temp2, null) might fail. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@292.3--292.30) [197204]"}
                perm <= Mask[null, heapseg(temp2, null)];
            }
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(temp2, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(temp2, null):=newVersion];
              }
            if (temp2 != null) {
              perm := FullPerm;
              Mask := Mask[null, tree_1(temp2):=Mask[null, tree_1(temp2)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], tree_1(temp2), Heap[null, tree_1(temp2)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume temp2 != null;
              Mask := Mask[temp2, sibling:=Mask[temp2, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[temp2, sibling], null):=Mask[null, heapseg(Heap[temp2, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], heapseg(Heap[temp2, sibling], null), Heap[null, heapseg(Heap[temp2, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[temp2, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, temp2) == segParent(Heap, Heap[temp2, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (treeDegree(temp1) == treeDegree(temp2)) -- BinomialHeap.vpr@294.3--351.4
            
            // -- Check definedness of treeDegree(temp1) == treeDegree(temp2)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@294.6--294.23) [197205]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@294.27--294.44) [197206]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp2)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (treeDegree(Heap, temp1) == treeDegree(Heap, temp2)) {
              
              // -- Translating statement: tmp := temp2 -- BinomialHeap.vpr@295.4--295.16
                tmp := temp2;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp2 := temp2.sibling -- BinomialHeap.vpr@296.4--296.26
                
                // -- Check definedness of temp2.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@296.4--296.26) [197207]"}
                    HasDirectPerm(Mask, temp2, sibling);
                temp2 := Heap[temp2, sibling];
                assume state(Heap, Mask);
              
              // -- Translating statement: tmp.sibling := temp1.sibling -- BinomialHeap.vpr@297.4--297.32
                
                // -- Check definedness of temp1.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@297.4--297.32) [197208]"}
                    HasDirectPerm(Mask, temp1, sibling);
                assert {:msg "  Assignment might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@297.4--297.32) [197209]"}
                  FullPerm == Mask[tmp, sibling];
                Heap := Heap[tmp, sibling:=Heap[temp1, sibling]];
                assume state(Heap, Mask);
              
              // -- Translating statement: temp1.sibling := tmp -- BinomialHeap.vpr@298.4--298.24
                assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@298.4--298.24) [197210]"}
                  FullPerm == Mask[temp1, sibling];
                Heap := Heap[temp1, sibling:=tmp];
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(tmp, tmp), write) -- BinomialHeap.vpr@300.4--300.26
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (tmp != tmp) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@300.4--300.26) [197211]"}
                      perm <= Mask[null, tree_1(tmp)];
                  }
                  Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@300.4--300.26) [197212]"}
                      perm <= Mask[tmp, sibling];
                  }
                  Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access heapseg(tmp.sibling, tmp) (BinomialHeap.vpr@300.4--300.26) [197213]"}
                      perm <= Mask[null, heapseg(Heap[tmp, sibling], tmp)];
                  }
                  Mask := Mask[null, heapseg(Heap[tmp, sibling], tmp):=Mask[null, heapseg(Heap[tmp, sibling], tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], heapseg(Heap[tmp, sibling], tmp), Heap[null, heapseg(Heap[tmp, sibling], tmp)]);
                  if (Heap[tmp, sibling] != tmp) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, tmp) might not hold. (BinomialHeap.vpr@300.4--300.26) [197214]"}
                      treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], tmp);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(tmp, tmp):=Mask[null, heapseg(tmp, tmp)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(tmp, tmp));
                assume Heap[null, heapseg(tmp, tmp)] == FrameFragment((if tmp != tmp then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], tmp)], FrameFragment((if Heap[tmp, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(tmp, tmp))) {
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(tmp, tmp):=freshVersion];
                }
                if (tmp != tmp) {
                  havoc newPMask;
                  assume (forall <A, B> o_87: Ref, f_96: (Field A B) ::
                    { newPMask[o_87, f_96] }
                    Heap[null, heapseg#sm(tmp, tmp)][o_87, f_96] || Heap[null, tree#sm(tmp)][o_87, f_96] ==> newPMask[o_87, f_96]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=Heap[null, heapseg#sm(tmp, tmp)][tmp, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_88: Ref, f_97: (Field A B) ::
                    { newPMask[o_88, f_97] }
                    Heap[null, heapseg#sm(tmp, tmp)][o_88, f_97] || Heap[null, heapseg#sm(Heap[tmp, sibling], tmp)][o_88, f_97] ==> newPMask[o_88, f_97]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp1, tmp), write) -- BinomialHeap.vpr@301.4--301.28
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp1 != tmp) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@301.4--301.28) [197215]"}
                      perm <= Mask[null, tree_1(temp1)];
                  }
                  Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@301.4--301.28) [197216]"}
                      perm <= Mask[temp1, sibling];
                  }
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access heapseg(temp1.sibling, tmp) (BinomialHeap.vpr@301.4--301.28) [197217]"}
                      perm <= Mask[null, heapseg(Heap[temp1, sibling], tmp)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], tmp):=Mask[null, heapseg(Heap[temp1, sibling], tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], heapseg(Heap[temp1, sibling], tmp), Heap[null, heapseg(Heap[temp1, sibling], tmp)]);
                  if (Heap[temp1, sibling] != tmp) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, tmp) might not hold. (BinomialHeap.vpr@301.4--301.28) [197218]"}
                      treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], tmp);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp1, tmp));
                assume Heap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], tmp)], FrameFragment((if Heap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp1, tmp))) {
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp1, tmp):=freshVersion];
                }
                if (temp1 != tmp) {
                  havoc newPMask;
                  assume (forall <A, B> o_89: Ref, f_98: (Field A B) ::
                    { newPMask[o_89, f_98] }
                    Heap[null, heapseg#sm(temp1, tmp)][o_89, f_98] || Heap[null, tree#sm(temp1)][o_89, f_98] ==> newPMask[o_89, f_98]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_90: Ref, f_99: (Field A B) ::
                    { newPMask[o_90, f_99] }
                    Heap[null, heapseg#sm(temp1, tmp)][o_90, f_99] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_90, f_99] ==> newPMask[o_90, f_99]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: assert segSize(temp1, tmp) ==
  //   (unfolding acc(heapseg(temp1, tmp), write) in treeSize(temp1)) -- BinomialHeap.vpr@302.4--302.82
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                
                // -- Check definedness of segSize(temp1, tmp) == (unfolding acc(heapseg(temp1, tmp), write) in treeSize(temp1))
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef1Heap := ExhaleWellDef0Heap;
                    ExhaleWellDef1Mask := ExhaleWellDef0Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@302.11--302.30) [197219]"}
                      NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp1, tmp)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
                    ExhaleWellDef0Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  UnfoldingHeap := ExhaleWellDef0Heap;
                  UnfoldingMask := ExhaleWellDef0Mask;
                  assume heapseg#trigger(UnfoldingHeap, heapseg(temp1, tmp));
                  assume UnfoldingHeap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(UnfoldingHeap[null, tree_1(temp1)], CombineFrames(FrameFragment(UnfoldingHeap[temp1, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], tmp)], FrameFragment((if UnfoldingHeap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                  ExhaleWellDef1Heap := UnfoldingHeap;
                  ExhaleWellDef1Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@302.11--302.82) [197220]"}
                      perm <= UnfoldingMask[null, heapseg(temp1, tmp)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heapseg(temp1, tmp):=UnfoldingMask[null, heapseg(temp1, tmp)] - perm];
                  if (temp1 != tmp) {
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, tree_1(temp1):=UnfoldingMask[null, tree_1(temp1)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, tmp), UnfoldingHeap[null, heapseg(temp1, tmp)], tree_1(temp1), UnfoldingHeap[null, tree_1(temp1)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    assume temp1 != null;
                    UnfoldingMask := UnfoldingMask[temp1, sibling:=UnfoldingMask[temp1, sibling] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], tmp):=UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], tmp)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, tmp), UnfoldingHeap[null, heapseg(temp1, tmp)], heapseg(UnfoldingHeap[temp1, sibling], tmp), UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], tmp)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    if (UnfoldingHeap[temp1, sibling] != tmp) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume treeParent(UnfoldingHeap, temp1) == segParent(UnfoldingHeap, UnfoldingHeap[temp1, sibling], tmp);
                    }
                  }
                  assume state(UnfoldingHeap, UnfoldingMask);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef1Heap := UnfoldingHeap;
                    ExhaleWellDef1Mask := UnfoldingMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@302.67--302.82) [197221]"}
                      NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree_1(temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
                    UnfoldingHeap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  
                  // -- Free assumptions (exp module)
                    if (temp1 != tmp) {
                      havoc newPMask;
                      assume (forall <A, B> o_93: Ref, f_105: (Field A B) ::
                        { newPMask[o_93, f_105] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_93, f_105] || Heap[null, tree#sm(temp1)][o_93, f_105] ==> newPMask[o_93, f_105]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_94: Ref, f_44: (Field A B) ::
                        { newPMask[o_94, f_44] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_94, f_44] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_94, f_44] ==> newPMask[o_94, f_44]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                    }
                    assume state(Heap, Mask);
                  
                  // -- Free assumptions (exp module)
                    if (temp1 != tmp) {
                      havoc newPMask;
                      assume (forall <A, B> o_97: Ref, f_107: (Field A B) ::
                        { newPMask[o_97, f_107] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_97, f_107] || Heap[null, tree#sm(temp1)][o_97, f_107] ==> newPMask[o_97, f_107]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_95: Ref, f_106: (Field A B) ::
                        { newPMask[o_95, f_106] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_95, f_106] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_95, f_106] ==> newPMask[o_95, f_106]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                    }
                    assume state(Heap, Mask);
                assert {:msg "  Assert might fail. Assertion segSize(temp1, tmp) == (unfolding acc(heapseg(temp1, tmp), write) in treeSize(temp1)) might not hold. (BinomialHeap.vpr@302.11--302.82) [197222]"}
                  segSize(Heap, temp1, tmp) == treeSize(Heap, temp1);
                
                // -- Free assumptions (exhale module)
                  if (temp1 != tmp) {
                    havoc newPMask;
                    assume (forall <A, B> o_96: Ref, f_45: (Field A B) ::
                      { newPMask[o_96, f_45] }
                      Heap[null, heapseg#sm(temp1, tmp)][o_96, f_45] || Heap[null, tree#sm(temp1)][o_96, f_45] ==> newPMask[o_96, f_45]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                    Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_77: Ref, f_109: (Field A B) ::
                      { newPMask[o_77, f_109] }
                      Heap[null, heapseg#sm(temp1, tmp)][o_77, f_109] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_77, f_109] ==> newPMask[o_77, f_109]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: concat(this.Nodes, temp1, tmp) -- BinomialHeap.vpr@303.4--303.34
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Check definedness of this.Nodes
                  assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@303.4--303.34) [197223]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                arg_a := Heap[this, Nodes_1];
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@303.4--303.34) [197224]"}
                      perm <= Mask[null, heapseg(arg_a, temp1)];
                  }
                  Mask := Mask[null, heapseg(arg_a, temp1):=Mask[null, heapseg(arg_a, temp1)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@303.4--303.34) [197225]"}
                      perm <= Mask[null, heapseg(temp1, tmp)];
                  }
                  Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] - perm];
                  if (tmp != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@303.4--303.34) [197226]"}
                        perm <= Mask[null, tree_1(tmp)];
                    }
                    Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                  }
                  if (arg_a != temp1 && temp1 != tmp) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, tmp) might not hold. (BinomialHeap.vpr@303.4--303.34) [197227]"}
                      segParent(Heap, arg_a, temp1) == segParent(Heap, temp1, tmp);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(arg_a, tmp):=Mask[null, heapseg(arg_a, tmp)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, arg_a, tmp) == segLength(PreCallHeap, arg_a, temp1) + segLength(PreCallHeap, temp1, tmp);
                  assume state(Heap, Mask);
                  assume (forall i: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a, tmp)], arg_a, tmp, i) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a, temp1)], arg_a, temp1, i) }
                    0 <= i && i < segLength(PreCallHeap, arg_a, temp1) ==> segDegree(Heap, arg_a, tmp, i) == segDegree(PreCallHeap, arg_a, temp1, i)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_1: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a, tmp)], arg_a, tmp, i_1) }
                    segLength(PreCallHeap, arg_a, temp1) <= i_1 && i_1 < segLength(Heap, arg_a, tmp) ==> segDegree(Heap, arg_a, tmp, i_1) == segDegree(PreCallHeap, temp1, tmp, i_1 - segLength(PreCallHeap, arg_a, temp1))
                  );
                  if (tmp != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, tmp) == treeDegree(PreCallHeap, tmp);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, tmp) == treeSize(PreCallHeap, tmp);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, tmp) == treeParent(PreCallHeap, tmp);
                  }
                  if (sorted_1(PreCallHeap, arg_a, temp1) && (sorted_1(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted_1(Heap, arg_a, tmp);
                  }
                  if (presorted(PreCallHeap, arg_a, temp1) && (presorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) <= segDegree(PreCallHeap, temp1, tmp, 0) && ((2 <= segLength(PreCallHeap, arg_a, temp1) && segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) == segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 2) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)) && (2 <= segLength(PreCallHeap, temp1, tmp) && segDegree(PreCallHeap, temp1, tmp, 0) == segDegree(PreCallHeap, temp1, tmp, 1) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, arg_a, tmp);
                  }
                  if (validChildren(PreCallHeap, arg_a, temp1) && (validChildren(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) == segDegree(PreCallHeap, temp1, tmp, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, arg_a, tmp);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, arg_a, tmp) == segSize(PreCallHeap, arg_a, temp1) + segSize(PreCallHeap, temp1, tmp);
                  if (arg_a != temp1) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a, tmp) == segParent(PreCallHeap, arg_a, temp1);
                  }
                  if (temp1 != tmp) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a, tmp) == segParent(PreCallHeap, temp1, tmp);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: temp1 := tmp -- BinomialHeap.vpr@305.4--305.16
                temp1 := tmp;
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@309.4--309.27
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (tmp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@309.4--309.27) [197228]"}
                      perm <= Mask[null, tree_1(tmp)];
                  }
                  Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@309.4--309.27) [197229]"}
                      perm <= Mask[tmp, sibling];
                  }
                  Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@309.4--309.27) [197230]"}
                      perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                  }
                  Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                  if (Heap[tmp, sibling] != null) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@309.4--309.27) [197231]"}
                      treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(tmp, null));
                assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                  Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                }
                if (tmp != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_98: Ref, f_87: (Field A B) ::
                    { newPMask[o_98, f_87] }
                    Heap[null, heapseg#sm(tmp, null)][o_98, f_87] || Heap[null, tree#sm(tmp)][o_98, f_87] ==> newPMask[o_98, f_87]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_99: Ref, f_108: (Field A B) ::
                    { newPMask[o_99, f_108] }
                    Heap[null, heapseg#sm(tmp, null)][o_99, f_108] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_99, f_108] ==> newPMask[o_99, f_108]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: if (treeDegree(temp1) < treeDegree(temp2)) -- BinomialHeap.vpr@311.4--350.5
                
                // -- Check definedness of treeDegree(temp1) < treeDegree(temp2)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@311.7--311.24) [197232]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@311.27--311.44) [197233]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp2)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                if (treeDegree(Heap, temp1) < treeDegree(Heap, temp2)) {
                  
                  // -- Translating statement: if (temp1.sibling == null || segDegree(temp1.sibling, null, 0) > treeDegree(temp2)) -- BinomialHeap.vpr@312.5--336.6
                    
                    // -- Check definedness of temp1.sibling == null || segDegree(temp1.sibling, null, 0) > treeDegree(temp2)
                      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@312.8--313.58) [197234]"}
                        HasDirectPerm(Mask, temp1, sibling);
                      if (!(Heap[temp1, sibling] == null)) {
                        assert {:msg "  Conditional statement might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@312.8--313.58) [197235]"}
                          HasDirectPerm(Mask, temp1, sibling);
                        if (*) {
                          // Exhale precondition of function application
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@313.5--313.38) [197236]"}
                            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[temp1, sibling], null)];
                          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1.sibling, null) might not hold. (BinomialHeap.vpr@313.5--313.38) [197237]"}
                            0 < segLength(Heap, Heap[temp1, sibling], null);
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                          // Stop execution
                          assume false;
                        }
                        if (*) {
                          // Exhale precondition of function application
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@313.41--313.58) [197238]"}
                            NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp2)];
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                          // Stop execution
                          assume false;
                        }
                      }
                    if (Heap[temp1, sibling] == null || segDegree(Heap, Heap[temp1, sibling], null, 0) > treeDegree(Heap, temp2)) {
                      
                      // -- Translating statement: tmp := temp2 -- BinomialHeap.vpr@314.6--314.18
                        tmp := temp2;
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp2 := temp2.sibling -- BinomialHeap.vpr@315.6--315.28
                        
                        // -- Check definedness of temp2.sibling
                          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@315.6--315.28) [197239]"}
                            HasDirectPerm(Mask, temp2, sibling);
                        temp2 := Heap[temp2, sibling];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: tmp.sibling := temp1.sibling -- BinomialHeap.vpr@316.6--316.34
                        
                        // -- Check definedness of temp1.sibling
                          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@316.6--316.34) [197240]"}
                            HasDirectPerm(Mask, temp1, sibling);
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@316.6--316.34) [197241]"}
                          FullPerm == Mask[tmp, sibling];
                        Heap := Heap[tmp, sibling:=Heap[temp1, sibling]];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp1.sibling := tmp -- BinomialHeap.vpr@317.6--317.26
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@317.6--317.26) [197242]"}
                          FullPerm == Mask[temp1, sibling];
                        Heap := Heap[temp1, sibling:=tmp];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, tmp), write) -- BinomialHeap.vpr@318.6--318.28
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@318.6--318.28) [197243]"}
                              perm <= Mask[null, tree_1(tmp)];
                          }
                          Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@318.6--318.28) [197244]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access heapseg(tmp.sibling, tmp) (BinomialHeap.vpr@318.6--318.28) [197245]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], tmp):=Mask[null, heapseg(Heap[tmp, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], heapseg(Heap[tmp, sibling], tmp), Heap[null, heapseg(Heap[tmp, sibling], tmp)]);
                          if (Heap[tmp, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, tmp) might not hold. (BinomialHeap.vpr@318.6--318.28) [197246]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, tmp):=Mask[null, heapseg(tmp, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, tmp));
                        assume Heap[null, heapseg(tmp, tmp)] == FrameFragment((if tmp != tmp then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], tmp)], FrameFragment((if Heap[tmp, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, tmp))) {
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, tmp):=freshVersion];
                        }
                        if (tmp != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_78: Ref, f_110: (Field A B) ::
                            { newPMask[o_78, f_110] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_78, f_110] || Heap[null, tree#sm(tmp)][o_78, f_110] ==> newPMask[o_78, f_110]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=Heap[null, heapseg#sm(tmp, tmp)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_100: Ref, f_111: (Field A B) ::
                            { newPMask[o_100, f_111] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_100, f_111] || Heap[null, heapseg#sm(Heap[tmp, sibling], tmp)][o_100, f_111] ==> newPMask[o_100, f_111]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(temp1, tmp), write) -- BinomialHeap.vpr@319.6--319.30
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp1 != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@319.6--319.30) [197247]"}
                              perm <= Mask[null, tree_1(temp1)];
                          }
                          Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@319.6--319.30) [197248]"}
                              perm <= Mask[temp1, sibling];
                          }
                          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access heapseg(temp1.sibling, tmp) (BinomialHeap.vpr@319.6--319.30) [197249]"}
                              perm <= Mask[null, heapseg(Heap[temp1, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp1, sibling], tmp):=Mask[null, heapseg(Heap[temp1, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], heapseg(Heap[temp1, sibling], tmp), Heap[null, heapseg(Heap[temp1, sibling], tmp)]);
                          if (Heap[temp1, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, tmp) might not hold. (BinomialHeap.vpr@319.6--319.30) [197250]"}
                              treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp1, tmp));
                        assume Heap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], tmp)], FrameFragment((if Heap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp1, tmp))) {
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp1, tmp):=freshVersion];
                        }
                        if (temp1 != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_101: Ref, f_112: (Field A B) ::
                            { newPMask[o_101, f_112] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_101, f_112] || Heap[null, tree#sm(temp1)][o_101, f_112] ==> newPMask[o_101, f_112]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_102: Ref, f_113: (Field A B) ::
                            { newPMask[o_102, f_113] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_102, f_113] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_102, f_113] ==> newPMask[o_102, f_113]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: concat(this.Nodes, temp1, tmp) -- BinomialHeap.vpr@320.6--320.36
                        PreCallHeap := Heap;
                        PreCallMask := Mask;
                        
                        // -- Check definedness of this.Nodes
                          assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@320.6--320.36) [197251]"}
                            HasDirectPerm(Mask, this, Nodes_1);
                        arg_a_1 := Heap[this, Nodes_1];
                        
                        // -- Exhaling precondition
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@320.6--320.36) [197252]"}
                              perm <= Mask[null, heapseg(arg_a_1, temp1)];
                          }
                          Mask := Mask[null, heapseg(arg_a_1, temp1):=Mask[null, heapseg(arg_a_1, temp1)] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@320.6--320.36) [197253]"}
                              perm <= Mask[null, heapseg(temp1, tmp)];
                          }
                          Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] - perm];
                          if (tmp != null) {
                            perm := FullPerm;
                            if (perm != NoPerm) {
                              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@320.6--320.36) [197254]"}
                                perm <= Mask[null, tree_1(tmp)];
                            }
                            Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                          }
                          if (arg_a_1 != temp1 && temp1 != tmp) {
                            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, tmp) might not hold. (BinomialHeap.vpr@320.6--320.36) [197255]"}
                              segParent(Heap, arg_a_1, temp1) == segParent(Heap, temp1, tmp);
                          }
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                        
                        // -- Inhaling postcondition
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(arg_a_1, tmp):=Mask[null, heapseg(arg_a_1, tmp)] + perm];
                          assume state(Heap, Mask);
                          assume state(Heap, Mask);
                          assume segLength(Heap, arg_a_1, tmp) == segLength(PreCallHeap, arg_a_1, temp1) + segLength(PreCallHeap, temp1, tmp);
                          assume state(Heap, Mask);
                          assume (forall i_2: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_1, tmp)], arg_a_1, tmp, i_2) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_1, temp1)], arg_a_1, temp1, i_2) }
                            0 <= i_2 && i_2 < segLength(PreCallHeap, arg_a_1, temp1) ==> segDegree(Heap, arg_a_1, tmp, i_2) == segDegree(PreCallHeap, arg_a_1, temp1, i_2)
                          );
                          assume state(Heap, Mask);
                          assume (forall i_3_2: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_1, tmp)], arg_a_1, tmp, i_3_2) }
                            segLength(PreCallHeap, arg_a_1, temp1) <= i_3_2 && i_3_2 < segLength(Heap, arg_a_1, tmp) ==> segDegree(Heap, arg_a_1, tmp, i_3_2) == segDegree(PreCallHeap, temp1, tmp, i_3_2 - segLength(PreCallHeap, arg_a_1, temp1))
                          );
                          if (tmp != null) {
                            perm := FullPerm;
                            Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] + perm];
                            assume state(Heap, Mask);
                            assume state(Heap, Mask);
                            assume treeDegree(Heap, tmp) == treeDegree(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeSize(Heap, tmp) == treeSize(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeParent(Heap, tmp) == treeParent(PreCallHeap, tmp);
                          }
                          if (sorted_1(PreCallHeap, arg_a_1, temp1) && (sorted_1(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_1, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))) {
                            assume state(Heap, Mask);
                            assume sorted_1(Heap, arg_a_1, tmp);
                          }
                          if (presorted(PreCallHeap, arg_a_1, temp1) && (presorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_1, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) <= segDegree(PreCallHeap, temp1, tmp, 0) && ((2 <= segLength(PreCallHeap, arg_a_1, temp1) && segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) == segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 2) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)) && (2 <= segLength(PreCallHeap, temp1, tmp) && segDegree(PreCallHeap, temp1, tmp, 0) == segDegree(PreCallHeap, temp1, tmp, 1) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))))) {
                            assume state(Heap, Mask);
                            assume presorted(Heap, arg_a_1, tmp);
                          }
                          if (validChildren(PreCallHeap, arg_a_1, temp1) && (validChildren(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_1, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) == segDegree(PreCallHeap, temp1, tmp, 0) + 1))) {
                            assume state(Heap, Mask);
                            assume validChildren(Heap, arg_a_1, tmp);
                          }
                          assume state(Heap, Mask);
                          assume segSize(Heap, arg_a_1, tmp) == segSize(PreCallHeap, arg_a_1, temp1) + segSize(PreCallHeap, temp1, tmp);
                          if (arg_a_1 != temp1) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_1, tmp) == segParent(PreCallHeap, arg_a_1, temp1);
                          }
                          if (temp1 != tmp) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_1, tmp) == segParent(PreCallHeap, temp1, tmp);
                          }
                          assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp1 := tmp -- BinomialHeap.vpr@322.6--322.18
                        temp1 := tmp;
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@326.6--326.29
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != null) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@326.6--326.29) [197256]"}
                              perm <= Mask[null, tree_1(tmp)];
                          }
                          Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@326.6--326.29) [197257]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@326.6--326.29) [197258]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                          if (Heap[tmp, sibling] != null) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@326.6--326.29) [197259]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, null));
                        assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                          Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                        }
                        if (tmp != null) {
                          havoc newPMask;
                          assume (forall <A, B> o_103: Ref, f_114: (Field A B) ::
                            { newPMask[o_103, f_114] }
                            Heap[null, heapseg#sm(tmp, null)][o_103, f_114] || Heap[null, tree#sm(tmp)][o_103, f_114] ==> newPMask[o_103, f_114]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_104: Ref, f_115: (Field A B) ::
                            { newPMask[o_104, f_115] }
                            Heap[null, heapseg#sm(tmp, null)][o_104, f_115] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_104, f_115] ==> newPMask[o_104, f_115]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: tmp := temp1.sibling -- BinomialHeap.vpr@328.6--328.26
                        
                        // -- Check definedness of temp1.sibling
                          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@328.6--328.26) [197260]"}
                            HasDirectPerm(Mask, temp1, sibling);
                        tmp := Heap[temp1, sibling];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(temp2, null), write) -- BinomialHeap.vpr@329.6--329.31
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp2 != null) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@329.6--329.31) [197261]"}
                              perm <= Mask[null, tree_1(temp2)];
                          }
                          Mask := Mask[null, tree_1(temp2):=Mask[null, tree_1(temp2)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], tree_1(temp2), Heap[null, tree_1(temp2)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@329.6--329.31) [197262]"}
                              perm <= Mask[temp2, sibling];
                          }
                          Mask := Mask[temp2, sibling:=Mask[temp2, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. There might be insufficient permission to access heapseg(temp2.sibling, null) (BinomialHeap.vpr@329.6--329.31) [197263]"}
                              perm <= Mask[null, heapseg(Heap[temp2, sibling], null)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp2, sibling], null):=Mask[null, heapseg(Heap[temp2, sibling], null)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], heapseg(Heap[temp2, sibling], null), Heap[null, heapseg(Heap[temp2, sibling], null)]);
                          if (Heap[temp2, sibling] != null) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. Assertion treeParent(temp2) == segParent(temp2.sibling, null) might not hold. (BinomialHeap.vpr@329.6--329.31) [197264]"}
                              treeParent(Heap, temp2) == segParent(Heap, Heap[temp2, sibling], null);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp2, null));
                        assume Heap[null, heapseg(temp2, null)] == FrameFragment((if temp2 != null then CombineFrames(Heap[null, tree_1(temp2)], CombineFrames(FrameFragment(Heap[temp2, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp2, sibling], null)], FrameFragment((if Heap[temp2, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp2, null))) {
                          Heap := Heap[null, heapseg#sm(temp2, null):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp2, null):=freshVersion];
                        }
                        if (temp2 != null) {
                          havoc newPMask;
                          assume (forall <A, B> o_105: Ref, f_116: (Field A B) ::
                            { newPMask[o_105, f_116] }
                            Heap[null, heapseg#sm(temp2, null)][o_105, f_116] || Heap[null, tree#sm(temp2)][o_105, f_116] ==> newPMask[o_105, f_116]
                          );
                          Heap := Heap[null, heapseg#sm(temp2, null):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp2, null):=Heap[null, heapseg#sm(temp2, null)][temp2, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_106: Ref, f_117: (Field A B) ::
                            { newPMask[o_106, f_117] }
                            Heap[null, heapseg#sm(temp2, null)][o_106, f_117] || Heap[null, heapseg#sm(Heap[temp2, sibling], null)][o_106, f_117] ==> newPMask[o_106, f_117]
                          );
                          Heap := Heap[null, heapseg#sm(temp2, null):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, tmp), write) -- BinomialHeap.vpr@330.6--330.28
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@330.6--330.28) [197265]"}
                              perm <= Mask[null, tree_1(tmp)];
                          }
                          Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@330.6--330.28) [197266]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access heapseg(tmp.sibling, tmp) (BinomialHeap.vpr@330.6--330.28) [197267]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], tmp):=Mask[null, heapseg(Heap[tmp, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], heapseg(Heap[tmp, sibling], tmp), Heap[null, heapseg(Heap[tmp, sibling], tmp)]);
                          if (Heap[tmp, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, tmp) might not hold. (BinomialHeap.vpr@330.6--330.28) [197268]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, tmp):=Mask[null, heapseg(tmp, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, tmp));
                        assume Heap[null, heapseg(tmp, tmp)] == FrameFragment((if tmp != tmp then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], tmp)], FrameFragment((if Heap[tmp, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, tmp))) {
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, tmp):=freshVersion];
                        }
                        if (tmp != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_107: Ref, f_118: (Field A B) ::
                            { newPMask[o_107, f_118] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_107, f_118] || Heap[null, tree#sm(tmp)][o_107, f_118] ==> newPMask[o_107, f_118]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=Heap[null, heapseg#sm(tmp, tmp)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_108: Ref, f_119: (Field A B) ::
                            { newPMask[o_108, f_119] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_108, f_119] || Heap[null, heapseg#sm(Heap[tmp, sibling], tmp)][o_108, f_119] ==> newPMask[o_108, f_119]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(temp1, tmp), write) -- BinomialHeap.vpr@331.6--331.30
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp1 != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@331.6--331.30) [197269]"}
                              perm <= Mask[null, tree_1(temp1)];
                          }
                          Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@331.6--331.30) [197270]"}
                              perm <= Mask[temp1, sibling];
                          }
                          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access heapseg(temp1.sibling, tmp) (BinomialHeap.vpr@331.6--331.30) [197271]"}
                              perm <= Mask[null, heapseg(Heap[temp1, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp1, sibling], tmp):=Mask[null, heapseg(Heap[temp1, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], heapseg(Heap[temp1, sibling], tmp), Heap[null, heapseg(Heap[temp1, sibling], tmp)]);
                          if (Heap[temp1, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, tmp) might not hold. (BinomialHeap.vpr@331.6--331.30) [197272]"}
                              treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp1, tmp));
                        assume Heap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], tmp)], FrameFragment((if Heap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp1, tmp))) {
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp1, tmp):=freshVersion];
                        }
                        if (temp1 != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_109: Ref, f_120: (Field A B) ::
                            { newPMask[o_109, f_120] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_109, f_120] || Heap[null, tree#sm(temp1)][o_109, f_120] ==> newPMask[o_109, f_120]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_110: Ref, f_121: (Field A B) ::
                            { newPMask[o_110, f_121] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_110, f_121] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_110, f_121] ==> newPMask[o_110, f_121]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: unfold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@332.6--332.31
                        assume heapseg#trigger(Heap, heapseg(tmp, null));
                        assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        perm := FullPerm;
                        if (perm != NoPerm) {
                          assert {:msg "  Unfolding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp, null) (BinomialHeap.vpr@332.6--332.31) [197273]"}
                            perm <= Mask[null, heapseg(tmp, null)];
                        }
                        Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] - perm];
                        
                        // -- Update version of predicate
                          if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                            havoc newVersion;
                            Heap := Heap[null, heapseg(tmp, null):=newVersion];
                          }
                        if (tmp != null) {
                          perm := FullPerm;
                          Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] + perm];
                          
                          // -- Extra unfolding of predicate
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                          assume state(Heap, Mask);
                          perm := FullPerm;
                          assume tmp != null;
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] + perm];
                          assume state(Heap, Mask);
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] + perm];
                          
                          // -- Extra unfolding of predicate
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                          assume state(Heap, Mask);
                          if (Heap[tmp, sibling] != null) {
                            assume state(Heap, Mask);
                            assume treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                          }
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: concat(this.Nodes, temp1, tmp) -- BinomialHeap.vpr@333.6--333.36
                        PreCallHeap := Heap;
                        PreCallMask := Mask;
                        
                        // -- Check definedness of this.Nodes
                          assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@333.6--333.36) [197274]"}
                            HasDirectPerm(Mask, this, Nodes_1);
                        arg_a_2 := Heap[this, Nodes_1];
                        
                        // -- Exhaling precondition
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@333.6--333.36) [197275]"}
                              perm <= Mask[null, heapseg(arg_a_2, temp1)];
                          }
                          Mask := Mask[null, heapseg(arg_a_2, temp1):=Mask[null, heapseg(arg_a_2, temp1)] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@333.6--333.36) [197276]"}
                              perm <= Mask[null, heapseg(temp1, tmp)];
                          }
                          Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] - perm];
                          if (tmp != null) {
                            perm := FullPerm;
                            if (perm != NoPerm) {
                              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@333.6--333.36) [197277]"}
                                perm <= Mask[null, tree_1(tmp)];
                            }
                            Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                          }
                          if (arg_a_2 != temp1 && temp1 != tmp) {
                            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, tmp) might not hold. (BinomialHeap.vpr@333.6--333.36) [197278]"}
                              segParent(Heap, arg_a_2, temp1) == segParent(Heap, temp1, tmp);
                          }
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                        
                        // -- Inhaling postcondition
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(arg_a_2, tmp):=Mask[null, heapseg(arg_a_2, tmp)] + perm];
                          assume state(Heap, Mask);
                          assume state(Heap, Mask);
                          assume segLength(Heap, arg_a_2, tmp) == segLength(PreCallHeap, arg_a_2, temp1) + segLength(PreCallHeap, temp1, tmp);
                          assume state(Heap, Mask);
                          assume (forall i_4_1: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_2, tmp)], arg_a_2, tmp, i_4_1) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_2, temp1)], arg_a_2, temp1, i_4_1) }
                            0 <= i_4_1 && i_4_1 < segLength(PreCallHeap, arg_a_2, temp1) ==> segDegree(Heap, arg_a_2, tmp, i_4_1) == segDegree(PreCallHeap, arg_a_2, temp1, i_4_1)
                          );
                          assume state(Heap, Mask);
                          assume (forall i_5_1: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_2, tmp)], arg_a_2, tmp, i_5_1) }
                            segLength(PreCallHeap, arg_a_2, temp1) <= i_5_1 && i_5_1 < segLength(Heap, arg_a_2, tmp) ==> segDegree(Heap, arg_a_2, tmp, i_5_1) == segDegree(PreCallHeap, temp1, tmp, i_5_1 - segLength(PreCallHeap, arg_a_2, temp1))
                          );
                          if (tmp != null) {
                            perm := FullPerm;
                            Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] + perm];
                            assume state(Heap, Mask);
                            assume state(Heap, Mask);
                            assume treeDegree(Heap, tmp) == treeDegree(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeSize(Heap, tmp) == treeSize(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeParent(Heap, tmp) == treeParent(PreCallHeap, tmp);
                          }
                          if (sorted_1(PreCallHeap, arg_a_2, temp1) && (sorted_1(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_2, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))) {
                            assume state(Heap, Mask);
                            assume sorted_1(Heap, arg_a_2, tmp);
                          }
                          if (presorted(PreCallHeap, arg_a_2, temp1) && (presorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_2, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) <= segDegree(PreCallHeap, temp1, tmp, 0) && ((2 <= segLength(PreCallHeap, arg_a_2, temp1) && segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) == segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 2) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)) && (2 <= segLength(PreCallHeap, temp1, tmp) && segDegree(PreCallHeap, temp1, tmp, 0) == segDegree(PreCallHeap, temp1, tmp, 1) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))))) {
                            assume state(Heap, Mask);
                            assume presorted(Heap, arg_a_2, tmp);
                          }
                          if (validChildren(PreCallHeap, arg_a_2, temp1) && (validChildren(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_2, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) == segDegree(PreCallHeap, temp1, tmp, 0) + 1))) {
                            assume state(Heap, Mask);
                            assume validChildren(Heap, arg_a_2, tmp);
                          }
                          assume state(Heap, Mask);
                          assume segSize(Heap, arg_a_2, tmp) == segSize(PreCallHeap, arg_a_2, temp1) + segSize(PreCallHeap, temp1, tmp);
                          if (arg_a_2 != temp1) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_2, tmp) == segParent(PreCallHeap, arg_a_2, temp1);
                          }
                          if (temp1 != tmp) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_2, tmp) == segParent(PreCallHeap, temp1, tmp);
                          }
                          assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@334.6--334.29
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != null) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@334.6--334.29) [197279]"}
                              perm <= Mask[null, tree_1(tmp)];
                          }
                          Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@334.6--334.29) [197280]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@334.6--334.29) [197281]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                          if (Heap[tmp, sibling] != null) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@334.6--334.29) [197282]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, null));
                        assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                          Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                        }
                        if (tmp != null) {
                          havoc newPMask;
                          assume (forall <A, B> o_111: Ref, f_122: (Field A B) ::
                            { newPMask[o_111, f_122] }
                            Heap[null, heapseg#sm(tmp, null)][o_111, f_122] || Heap[null, tree#sm(tmp)][o_111, f_122] ==> newPMask[o_111, f_122]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_112: Ref, f_123: (Field A B) ::
                            { newPMask[o_112, f_123] }
                            Heap[null, heapseg#sm(tmp, null)][o_112, f_123] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_112, f_123] ==> newPMask[o_112, f_123]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp1 := tmp -- BinomialHeap.vpr@335.6--335.18
                        temp1 := tmp;
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: tmp := temp1 -- BinomialHeap.vpr@338.5--338.17
                    tmp := temp1;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp1 := temp2 -- BinomialHeap.vpr@339.5--339.19
                    temp1 := temp2;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp2 := temp2.sibling -- BinomialHeap.vpr@340.5--340.27
                    
                    // -- Check definedness of temp2.sibling
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@340.5--340.27) [197283]"}
                        HasDirectPerm(Mask, temp2, sibling);
                    temp2 := Heap[temp2, sibling];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp1.sibling := tmp -- BinomialHeap.vpr@341.5--341.25
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@341.5--341.25) [197284]"}
                      FullPerm == Mask[temp1, sibling];
                    Heap := Heap[temp1, sibling:=tmp];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@342.5--342.28
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (tmp != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@342.5--342.28) [197285]"}
                          perm <= Mask[null, tree_1(tmp)];
                      }
                      Mask := Mask[null, tree_1(tmp):=Mask[null, tree_1(tmp)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree_1(tmp), Heap[null, tree_1(tmp)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@342.5--342.28) [197286]"}
                          perm <= Mask[tmp, sibling];
                      }
                      Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@342.5--342.28) [197287]"}
                          perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                      if (Heap[tmp, sibling] != null) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@342.5--342.28) [197288]"}
                          treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(tmp, null));
                    assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree_1(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                      Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                    }
                    if (tmp != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_114: Ref, f_125: (Field A B) ::
                        { newPMask[o_114, f_125] }
                        Heap[null, heapseg#sm(tmp, null)][o_114, f_125] || Heap[null, tree#sm(tmp)][o_114, f_125] ==> newPMask[o_114, f_125]
                      );
                      Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_113: Ref, f_124: (Field A B) ::
                        { newPMask[o_113, f_124] }
                        Heap[null, heapseg#sm(tmp, null)][o_113, f_124] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_113, f_124] ==> newPMask[o_113, f_124]
                      );
                      Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@343.5--343.30
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (temp1 != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@343.5--343.30) [197289]"}
                          perm <= Mask[null, tree_1(temp1)];
                      }
                      Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@343.5--343.30) [197290]"}
                          perm <= Mask[temp1, sibling];
                      }
                      Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@343.5--343.30) [197291]"}
                          perm <= Mask[null, heapseg(Heap[temp1, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                      if (Heap[temp1, sibling] != null) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, null) might not hold. (BinomialHeap.vpr@343.5--343.30) [197292]"}
                          treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(temp1, null));
                    assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                      Heap := Heap[null, heapseg#sm(temp1, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(temp1, null):=freshVersion];
                    }
                    if (temp1 != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_115: Ref, f_126: (Field A B) ::
                        { newPMask[o_115, f_126] }
                        Heap[null, heapseg#sm(temp1, null)][o_115, f_126] || Heap[null, tree#sm(temp1)][o_115, f_126] ==> newPMask[o_115, f_126]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_116: Ref, f_127: (Field A B) ::
                        { newPMask[o_116, f_127] }
                        Heap[null, heapseg#sm(temp1, null)][o_116, f_127] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_116, f_127] ==> newPMask[o_116, f_127]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: if (tmp == this.Nodes) -- BinomialHeap.vpr@344.5--349.6
                    
                    // -- Check definedness of tmp == this.Nodes
                      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@344.8--344.25) [197293]"}
                        HasDirectPerm(Mask, this, Nodes_1);
                    if (tmp == Heap[this, Nodes_1]) {
                      
                      // -- Translating statement: this.Nodes := temp1 -- BinomialHeap.vpr@345.6--345.25
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@345.6--345.25) [197294]"}
                          FullPerm == Mask[this, Nodes_1];
                        Heap := Heap[this, Nodes_1:=temp1];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(this.Nodes, temp1), write) -- BinomialHeap.vpr@346.6--346.37
                        
                        // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
                          assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@346.6--346.37) [197295]"}
                            HasDirectPerm(Mask, this, Nodes_1);
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (Heap[this, Nodes_1] != temp1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@346.6--346.37) [197296]"}
                              perm <= Mask[null, tree_1(Heap[this, Nodes_1])];
                          }
                          Mask := Mask[null, tree_1(Heap[this, Nodes_1]):=Mask[null, tree_1(Heap[this, Nodes_1])] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp1), Heap[null, heapseg(Heap[this, Nodes_1], temp1)], tree_1(Heap[this, Nodes_1]), Heap[null, tree_1(Heap[this, Nodes_1])]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@346.6--346.37) [197297]"}
                              perm <= Mask[Heap[this, Nodes_1], sibling];
                          }
                          Mask := Mask[Heap[this, Nodes_1], sibling:=Mask[Heap[this, Nodes_1], sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp1) (BinomialHeap.vpr@346.6--346.37) [197298]"}
                              perm <= Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)];
                          }
                          Mask := Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1):=Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp1), Heap[null, heapseg(Heap[this, Nodes_1], temp1)], heapseg(Heap[Heap[this, Nodes_1], sibling], temp1), Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)]);
                          if (Heap[Heap[this, Nodes_1], sibling] != temp1) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp1) might not hold. (BinomialHeap.vpr@346.6--346.37) [197299]"}
                              treeParent(Heap, Heap[this, Nodes_1]) == segParent(Heap, Heap[Heap[this, Nodes_1], sibling], temp1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes_1], temp1));
                        assume Heap[null, heapseg(Heap[this, Nodes_1], temp1)] == FrameFragment((if Heap[this, Nodes_1] != temp1 then CombineFrames(Heap[null, tree_1(Heap[this, Nodes_1])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes_1], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)], FrameFragment((if Heap[Heap[this, Nodes_1], sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes_1], temp1))) {
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(Heap[this, Nodes_1], temp1):=freshVersion];
                        }
                        if (Heap[this, Nodes_1] != temp1) {
                          havoc newPMask;
                          assume (forall <A, B> o_118: Ref, f_129: (Field A B) ::
                            { newPMask[o_118, f_129] }
                            Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][o_118, f_129] || Heap[null, tree#sm(Heap[this, Nodes_1])][o_118, f_129] ==> newPMask[o_118, f_129]
                          );
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=newPMask];
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][Heap[this, Nodes_1], sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_117: Ref, f_128: (Field A B) ::
                            { newPMask[o_117, f_128] }
                            Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][o_117, f_128] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes_1], sibling], temp1)][o_117, f_128] ==> newPMask[o_117, f_128]
                          );
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: assert false -- BinomialHeap.vpr@348.6--348.18
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        assert {:msg "  Assert might fail. Assertion false might not hold. (BinomialHeap.vpr@348.13--348.18) [197300]"}
                          false;
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        // Exhale invariant
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not be preserved. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@263.13--263.56) [197301]"}
            perm <= Mask[null, heapseg(temp1, null)];
        }
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not be preserved. Assertion sorted(temp1, null) might not hold. (BinomialHeap.vpr@263.13--263.56) [197302]"}
          sorted_1(Heap, temp1, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@264.13--264.56) [197303]"}
            perm <= Mask[null, heapseg(temp2, null)];
        }
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@264.13--264.56) [197304]"}
          sorted_1(Heap, temp2, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@265.13--265.50) [197305]"}
            perm <= Mask[this, Nodes_1];
        }
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
        assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@265.13--265.50) [197306]"}
          Heap[this, Nodes_1] != null;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@266.13--266.71) [197307]"}
            perm <= Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
        }
        Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@266.13--266.71) [197308]"}
          presorted(Heap, Heap[this, Nodes_1], temp1);
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp1, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [197309]"}
            segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [197310]"}
              segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp2, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [197311]"}
            segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [197312]"}
              segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@277.13--279.93) [197313]"}
            segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        if (temp1 != Heap[this, Nodes_1] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant temp1 != this.Nodes && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not be preserved. Assertion segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@280.13--281.56) [197314]"}
            segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@282.13--282.149) [197315]"}
          segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        if (temp1 != null && temp2 != null) {
          assert {:msg "  Loop invariant temp1 != null && temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not be preserved. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@283.13--283.96) [197316]"}
            segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes_1] != temp1 && temp1 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp1 != null ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@284.13--284.108) [197317]"}
            segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
        }
        if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@285.13--285.108) [197318]"}
            segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes_1] != temp1) {
          assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@286.13--286.101) [197319]"}
            segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        if (temp1 != null) {
          assert {:msg "  Loop invariant temp1 != null ==> segParent(temp1, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@287.13--287.89) [197320]"}
            segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        if (temp2 != null) {
          assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@288.13--288.89) [197321]"}
            segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Terminate execution
        assume false;
      }
    
    // -- Inhale loop invariant after loop, and assume guard
      assume !(temp1 != null && temp2 != null);
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted_1(Heap, temp1, null);
      perm := FullPerm;
      Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted_1(Heap, temp2, null);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
      assume state(Heap, Mask);
      assume Heap[this, Nodes_1] != null;
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume presorted(Heap, Heap[this, Nodes_1], temp1);
      if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp1, null)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
        if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
        }
      }
      if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && 0 < segLength(Heap, temp2, null)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
        if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
      }
      if (0 < segLength(Heap, Heap[this, Nodes_1], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp2, null, 0);
      }
      if (temp1 != Heap[this, Nodes_1] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
        assume state(Heap, Mask);
        assume segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
      }
      assume state(Heap, Mask);
      assume segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
      if (temp1 != null && temp2 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
      }
      if (Heap[this, Nodes_1] != temp1 && temp1 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
      }
      if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
      }
      if (Heap[this, Nodes_1] != temp1) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
      }
      if (temp1 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
      }
      if (temp2 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (temp1 == null) -- BinomialHeap.vpr@353.2--406.3
    if (temp1 == null) {
      
      // -- Translating statement: temp1 := this.Nodes -- BinomialHeap.vpr@354.3--354.22
        
        // -- Check definedness of this.Nodes
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@354.3--354.22) [197322]"}
            HasDirectPerm(Mask, this, Nodes_1);
        temp1 := Heap[this, Nodes_1];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(this.Nodes, temp1), write) -- BinomialHeap.vpr@355.3--355.34
        
        // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
          assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@355.3--355.34) [197323]"}
            HasDirectPerm(Mask, this, Nodes_1);
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (Heap[this, Nodes_1] != temp1) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@355.3--355.34) [197326]"}
              perm <= Mask[null, tree_1(Heap[this, Nodes_1])];
          }
          Mask := Mask[null, tree_1(Heap[this, Nodes_1]):=Mask[null, tree_1(Heap[this, Nodes_1])] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp1), Heap[null, heapseg(Heap[this, Nodes_1], temp1)], tree_1(Heap[this, Nodes_1]), Heap[null, tree_1(Heap[this, Nodes_1])]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@355.3--355.34) [197328]"}
              perm <= Mask[Heap[this, Nodes_1], sibling];
          }
          Mask := Mask[Heap[this, Nodes_1], sibling:=Mask[Heap[this, Nodes_1], sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp1) (BinomialHeap.vpr@355.3--355.34) [197330]"}
              perm <= Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)];
          }
          Mask := Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1):=Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp1), Heap[null, heapseg(Heap[this, Nodes_1], temp1)], heapseg(Heap[Heap[this, Nodes_1], sibling], temp1), Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)]);
          if (Heap[Heap[this, Nodes_1], sibling] != temp1) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp1) might not hold. (BinomialHeap.vpr@355.3--355.34) [197331]"}
              treeParent(Heap, Heap[this, Nodes_1]) == segParent(Heap, Heap[Heap[this, Nodes_1], sibling], temp1);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes_1], temp1));
        assume Heap[null, heapseg(Heap[this, Nodes_1], temp1)] == FrameFragment((if Heap[this, Nodes_1] != temp1 then CombineFrames(Heap[null, tree_1(Heap[this, Nodes_1])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes_1], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp1)], FrameFragment((if Heap[Heap[this, Nodes_1], sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes_1], temp1))) {
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(Heap[this, Nodes_1], temp1):=freshVersion];
        }
        if (Heap[this, Nodes_1] != temp1) {
          havoc newPMask;
          assume (forall <A, B> o_122: Ref, f_138: (Field A B) ::
            { newPMask[o_122, f_138] }
            Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][o_122, f_138] || Heap[null, tree#sm(Heap[this, Nodes_1])][o_122, f_138] ==> newPMask[o_122, f_138]
          );
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=newPMask];
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][Heap[this, Nodes_1], sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_123: Ref, f_139: (Field A B) ::
            { newPMask[o_123, f_139] }
            Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1)][o_123, f_139] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes_1], sibling], temp1)][o_123, f_139] ==> newPMask[o_123, f_139]
          );
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp1):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: while ((unfolding acc(heapseg(temp1, null), write) in temp1.sibling != null)) -- BinomialHeap.vpr@357.3--397.4
        
        // -- Before loop head
          
          // -- Exhale loop invariant before loop
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            assert {:msg "  Loop invariant temp1 != null might not hold on entry. Assertion temp1 != null might not hold. (BinomialHeap.vpr@358.14--358.27) [197333]"}
              temp1 != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not hold on entry. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@359.14--359.60) [197334]"}
                perm <= Mask[null, heapseg(temp1, null)];
            }
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not hold on entry. Assertion presorted(temp1, null) might not hold. (BinomialHeap.vpr@359.14--359.60) [197335]"}
              presorted(Heap, temp1, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@360.14--360.57) [197336]"}
                perm <= Mask[null, heapseg(temp2, null)];
            }
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@360.14--360.57) [197337]"}
              sorted_1(Heap, temp2, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@361.14--361.51) [197338]"}
                perm <= Mask[this, Nodes_1];
            }
            Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
            assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@361.14--361.51) [197339]"}
              Heap[this, Nodes_1] != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@362.14--362.72) [197340]"}
                perm <= Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
            }
            Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@362.14--362.72) [197341]"}
              presorted(Heap, Heap[this, Nodes_1], temp1);
            assert {:msg "  Loop invariant 0 < segLength(temp1, null) might not hold on entry. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@363.14--363.40) [197342]"}
              0 < segLength(Heap, temp1, null);
            if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
              assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [197343]"}
                segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [197344]"}
                  segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [197345]"}
                  segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            if (0 < segLength(Heap, temp2, null)) {
              assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [197346]"}
                segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [197347]"}
                  segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@380.14--380.150) [197348]"}
              segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not hold on entry. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@381.14--381.80) [197349]"}
                segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            if (Heap[this, Nodes_1] != temp1) {
              assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@382.14--382.92) [197350]"}
                segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
            }
            if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
              assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@383.14--383.109) [197351]"}
                segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
            }
            assert {:msg "  Loop invariant segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@384.14--384.72) [197352]"}
              segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@385.14--385.90) [197353]"}
                segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            }
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
        
        // -- Havoc loop written variables (except locals)
          havoc temp1;
          assume Heap[temp1, $allocated];
        
        // -- Check definedness of invariant
          if (*) {
            assume temp1 != null;
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of presorted(temp1, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@359.38--359.60) [197354]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume presorted(Heap, temp1, null);
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of sorted(temp2, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@360.38--360.57) [197355]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume sorted_1(Heap, temp2, null);
            assume state(Heap, Mask);
            perm := FullPerm;
            assume this != null;
            Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
            assume state(Heap, Mask);
            
            // -- Check definedness of this.Nodes != null
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@361.14--361.51) [197356]"}
                HasDirectPerm(Mask, this, Nodes_1);
            assume Heap[this, Nodes_1] != null;
            assume state(Heap, Mask);
            
            // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@362.14--362.72) [197357]"}
                HasDirectPerm(Mask, this, Nodes_1);
            perm := FullPerm;
            Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of presorted(this.Nodes, temp1)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@362.14--362.72) [197358]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@362.44--362.72) [197359]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume presorted(Heap, Heap[this, Nodes_1], temp1);
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(temp1, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@363.18--363.40) [197360]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume 0 < segLength(Heap, temp1, null);
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(this.Nodes, temp1)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197361]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@364.18--364.46) [197362]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197363]"}
                  HasDirectPerm(Mask, this, Nodes_1);
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197364]"}
                  HasDirectPerm(Mask, this, Nodes_1);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@365.32--365.60) [197365]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@365.3--365.65) [197366]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@365.3--365.65) [197367]"}
                    0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@365.3--365.65) [197368]"}
                    segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@365.69--365.94) [197369]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@365.69--365.94) [197370]"}
                    0 < segLength(Heap, temp1, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              
              // -- Check definedness of 2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197371]"}
                  HasDirectPerm(Mask, this, Nodes_1);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@367.9--367.37) [197372]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1)) {
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197373]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197374]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.32--368.60) [197375]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.3--368.65) [197376]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@368.3--368.65) [197377]"}
                      0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@368.3--368.65) [197378]"}
                      segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197379]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197380]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.98--368.126) [197381]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.69--368.131) [197382]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 2 might not hold. (BinomialHeap.vpr@368.69--368.131) [197383]"}
                      0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 2;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 2 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@368.69--368.131) [197384]"}
                      segLength(Heap, Heap[this, Nodes_1], temp1) - 2 < segLength(Heap, Heap[this, Nodes_1], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
                assume state(Heap, Mask);
                
                // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197385]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197386]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@369.32--369.60) [197387]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@369.3--369.65) [197388]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@369.3--369.65) [197389]"}
                      0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@369.3--369.65) [197390]"}
                      segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@369.68--369.93) [197391]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@369.68--369.93) [197392]"}
                      0 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              
              // -- Check definedness of 2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1)
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@371.9--371.31) [197393]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(Heap, temp1, null)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@372.3--372.28) [197394]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@372.3--372.28) [197395]"}
                      0 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@372.32--372.57) [197396]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@372.32--372.57) [197397]"}
                      1 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assume state(Heap, Mask);
                
                // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197398]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [197399]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@373.32--373.60) [197400]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@373.3--373.65) [197401]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@373.3--373.65) [197402]"}
                      0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@373.3--373.65) [197403]"}
                      segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@373.68--373.93) [197404]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@373.68--373.93) [197405]"}
                      0 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(temp2, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@374.18--374.40) [197406]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (0 < segLength(Heap, temp2, null)) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0)
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@375.26--375.48) [197407]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@375.3--375.53) [197408]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 1 might not hold. (BinomialHeap.vpr@375.3--375.53) [197409]"}
                    0 <= segLength(Heap, temp1, null) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@375.3--375.53) [197410]"}
                    segLength(Heap, temp1, null) - 1 < segLength(Heap, temp1, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@375.57--375.82) [197411]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@375.57--375.82) [197412]"}
                    0 < segLength(Heap, temp2, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              
              // -- Check definedness of 2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@374.14--379.82) [197413]"}
                  HasDirectPerm(Mask, this, Nodes_1);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@377.9--377.37) [197414]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@377.40--377.62) [197415]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) + segLength(Heap, temp1, null)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.9--378.31) [197416]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (2 <= segLength(Heap, temp1, null)) {
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.57--378.79) [197417]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.34--378.84) [197418]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 2 might not hold. (BinomialHeap.vpr@378.34--378.84) [197419]"}
                        0 <= segLength(Heap, temp1, null) - 2;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 2 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@378.34--378.84) [197420]"}
                        segLength(Heap, temp1, null) - 2 < segLength(Heap, temp1, null);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  } else {
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@374.14--379.82) [197421]"}
                      HasDirectPerm(Mask, this, Nodes_1);
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@374.14--379.82) [197422]"}
                      HasDirectPerm(Mask, this, Nodes_1);
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@378.115--378.143) [197423]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@378.86--378.148) [197424]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@378.86--378.148) [197425]"}
                        0 <= segLength(Heap, Heap[this, Nodes_1], temp1) - 1;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@378.86--378.148) [197426]"}
                        segLength(Heap, Heap[this, Nodes_1], temp1) - 1 < segLength(Heap, Heap[this, Nodes_1], temp1);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.176--378.198) [197427]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.153--378.203) [197428]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 1 might not hold. (BinomialHeap.vpr@378.153--378.203) [197429]"}
                      0 <= segLength(Heap, temp1, null) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@378.153--378.203) [197430]"}
                      segLength(Heap, temp1, null) - 1 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assume state(Heap, Mask);
                
                // -- Check definedness of segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@379.26--379.48) [197431]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@379.3--379.53) [197432]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 1 might not hold. (BinomialHeap.vpr@379.3--379.53) [197433]"}
                      0 <= segLength(Heap, temp1, null) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@379.3--379.53) [197434]"}
                      segLength(Heap, temp1, null) - 1 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@379.56--379.81) [197435]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@379.56--379.81) [197436]"}
                      0 < segLength(Heap, temp2, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@380.14--380.150) [197437]"}
                HasDirectPerm(Mask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@380.14--380.40) [197438]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@380.43--380.63) [197439]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@380.66--380.86) [197440]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@380.14--380.150) [197441]"}
                HasDirectPerm(oldMask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@380.94--380.119) [197442]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
                // Finish exhale
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@380.127--380.149) [197443]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
                // Finish exhale
                // Stop execution
                assume false;
              }
            assume segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
            assume state(Heap, Mask);
            if (temp2 != null) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(temp1, null) == segParent(temp2, null)
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@381.32--381.54) [197444]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@381.32--381.54) [197445]"}
                    temp1 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@381.58--381.80) [197446]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@381.58--381.80) [197447]"}
                    temp2 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            assume state(Heap, Mask);
            
            // -- Check definedness of this.Nodes != temp1
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@382.14--382.92) [197448]"}
                HasDirectPerm(Mask, this, Nodes_1);
            if (Heap[this, Nodes_1] != temp1) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp1, null)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@382.14--382.92) [197449]"}
                  HasDirectPerm(Mask, this, Nodes_1);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@382.38--382.66) [197450]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@382.38--382.66) [197451]"}
                    Heap[this, Nodes_1] != temp1;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@382.70--382.92) [197452]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@382.70--382.92) [197453]"}
                    temp1 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
            }
            assume state(Heap, Mask);
            
            // -- Check definedness of this.Nodes != temp1 && temp2 != null
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@383.14--383.109) [197454]"}
                HasDirectPerm(Mask, this, Nodes_1);
            if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp2, null)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@383.14--383.109) [197455]"}
                  HasDirectPerm(Mask, this, Nodes_1);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@383.55--383.83) [197456]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@383.55--383.83) [197457]"}
                    Heap[this, Nodes_1] != temp1;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@383.87--383.109) [197458]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@383.87--383.109) [197459]"}
                    temp2 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of segParent(temp1, null) == old(segParent(this.Nodes, null))
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@384.14--384.36) [197460]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@384.14--384.36) [197461]"}
                  temp1 != null;
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@384.14--384.72) [197462]"}
                HasDirectPerm(oldMask, this, Nodes_1);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@384.44--384.71) [197463]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
                assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@384.44--384.71) [197464]"}
                  oldHeap[this, Nodes_1] != null;
                // Finish exhale
                // Stop execution
                assume false;
              }
            assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            assume state(Heap, Mask);
            if (temp2 != null) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(temp2, null) == old(segParent(this.Nodes, null))
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@385.32--385.54) [197465]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@385.32--385.54) [197466]"}
                    temp2 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@385.14--385.90) [197467]"}
                  HasDirectPerm(oldMask, this, Nodes_1);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@385.62--385.89) [197468]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@385.62--385.89) [197469]"}
                    oldHeap[this, Nodes_1] != null;
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            }
            assume state(Heap, Mask);
            assume false;
          }
        
        // -- Check the loop body
          if (*) {
            // Reset state
            loopHeap := Heap;
            loopMask := Mask;
            Mask := ZeroMask;
            assume state(Heap, Mask);
            // Inhale invariant
            assume temp1 != null;
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume presorted(Heap, temp1, null);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume sorted_1(Heap, temp2, null);
            perm := FullPerm;
            assume this != null;
            Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
            assume state(Heap, Mask);
            assume Heap[this, Nodes_1] != null;
            perm := FullPerm;
            Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume presorted(Heap, Heap[this, Nodes_1], temp1);
            assume state(Heap, Mask);
            assume 0 < segLength(Heap, temp1, null);
            if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
                assume state(Heap, Mask);
                assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assume state(Heap, Mask);
                assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            if (0 < segLength(Heap, temp2, null)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assume state(Heap, Mask);
                assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assume state(Heap, Mask);
            assume segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
            if (temp2 != null) {
              assume state(Heap, Mask);
              assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            if (Heap[this, Nodes_1] != temp1) {
              assume state(Heap, Mask);
              assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
            }
            if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
              assume state(Heap, Mask);
              assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
            }
            assume state(Heap, Mask);
            assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            if (temp2 != null) {
              assume state(Heap, Mask);
              assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            }
            assume state(Heap, Mask);
            // Check and assume guard
            
            // -- Check definedness of (unfolding acc(heapseg(temp1, null), write) in temp1.sibling != null)
              UnfoldingHeap := Heap;
              UnfoldingMask := Mask;
              assume heapseg#trigger(UnfoldingHeap, heapseg(temp1, null));
              assume UnfoldingHeap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(UnfoldingHeap[null, tree_1(temp1)], CombineFrames(FrameFragment(UnfoldingHeap[temp1, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)], FrameFragment((if UnfoldingHeap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
              ExhaleWellDef0Heap := UnfoldingHeap;
              ExhaleWellDef0Mask := UnfoldingMask;
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  While statement might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@357.9--357.64) [197470]"}
                  perm <= UnfoldingMask[null, heapseg(temp1, null)];
              }
              UnfoldingMask := UnfoldingMask[null, heapseg(temp1, null):=UnfoldingMask[null, heapseg(temp1, null)] - perm];
              if (temp1 != null) {
                perm := FullPerm;
                UnfoldingMask := UnfoldingMask[null, tree_1(temp1):=UnfoldingMask[null, tree_1(temp1)] + perm];
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], tree_1(temp1), UnfoldingHeap[null, tree_1(temp1)]);
                assume state(UnfoldingHeap, UnfoldingMask);
                perm := FullPerm;
                assume temp1 != null;
                UnfoldingMask := UnfoldingMask[temp1, sibling:=UnfoldingMask[temp1, sibling] + perm];
                assume state(UnfoldingHeap, UnfoldingMask);
                perm := FullPerm;
                UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null)] + perm];
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], heapseg(UnfoldingHeap[temp1, sibling], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)]);
                assume state(UnfoldingHeap, UnfoldingMask);
                if (UnfoldingHeap[temp1, sibling] != null) {
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume treeParent(UnfoldingHeap, temp1) == segParent(UnfoldingHeap, UnfoldingHeap[temp1, sibling], null);
                }
              }
              assume state(UnfoldingHeap, UnfoldingMask);
              assert {:msg "  While statement might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@357.9--357.64) [197471]"}
                HasDirectPerm(UnfoldingMask, temp1, sibling);
              
              // -- Free assumptions (exp module)
                if (temp1 != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_124: Ref, f_140: (Field A B) ::
                    { newPMask[o_124, f_140] }
                    Heap[null, heapseg#sm(temp1, null)][o_124, f_140] || Heap[null, tree#sm(temp1)][o_124, f_140] ==> newPMask[o_124, f_140]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_125: Ref, f_141: (Field A B) ::
                    { newPMask[o_125, f_141] }
                    Heap[null, heapseg#sm(temp1, null)][o_125, f_141] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_125, f_141] ==> newPMask[o_125, f_141]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                }
                assume state(Heap, Mask);
            assume Heap[temp1, sibling] != null;
            assume state(Heap, Mask);
            
            // -- Translate loop body
              
              // -- Assumptions about local variables
                assume Heap[t_2, $allocated];
              
              // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@387.4--387.31
                assume heapseg#trigger(Heap, heapseg(temp1, null));
                assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@387.4--387.31) [197472]"}
                    perm <= Mask[null, heapseg(temp1, null)];
                }
                Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp1, null):=newVersion];
                  }
                if (temp1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: t := temp1 -- BinomialHeap.vpr@388.4--388.23
                t_2 := temp1;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp1 := temp1.sibling -- BinomialHeap.vpr@389.4--389.26
                
                // -- Check definedness of temp1.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@389.4--389.26) [197473]"}
                    HasDirectPerm(Mask, temp1, sibling);
                temp1 := Heap[temp1, sibling];
                assume state(Heap, Mask);
              
              // -- Translating statement: assert (unfolding acc(heapseg(temp1, null), write) in
  //     (unfolding acc(tree(t), write) in
  //       (unfolding acc(tree(temp1), write) in t != temp1))) -- BinomialHeap.vpr@390.4--390.101
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                
                // -- Check definedness of (unfolding acc(heapseg(temp1, null), write) in (unfolding acc(tree(t), write) in (unfolding acc(tree(temp1), write) in t != temp1)))
                  UnfoldingHeap := ExhaleWellDef0Heap;
                  UnfoldingMask := ExhaleWellDef0Mask;
                  assume heapseg#trigger(UnfoldingHeap, heapseg(temp1, null));
                  assume UnfoldingHeap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(UnfoldingHeap[null, tree_1(temp1)], CombineFrames(FrameFragment(UnfoldingHeap[temp1, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)], FrameFragment((if UnfoldingHeap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                  ExhaleWellDef1Heap := UnfoldingHeap;
                  ExhaleWellDef1Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@390.11--390.101) [197474]"}
                      perm <= UnfoldingMask[null, heapseg(temp1, null)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heapseg(temp1, null):=UnfoldingMask[null, heapseg(temp1, null)] - perm];
                  if (temp1 != null) {
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, tree_1(temp1):=UnfoldingMask[null, tree_1(temp1)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], tree_1(temp1), UnfoldingHeap[null, tree_1(temp1)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    assume temp1 != null;
                    UnfoldingMask := UnfoldingMask[temp1, sibling:=UnfoldingMask[temp1, sibling] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], heapseg(UnfoldingHeap[temp1, sibling], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    if (UnfoldingHeap[temp1, sibling] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume treeParent(UnfoldingHeap, temp1) == segParent(UnfoldingHeap, UnfoldingHeap[temp1, sibling], null);
                    }
                  }
                  assume state(UnfoldingHeap, UnfoldingMask);
                  Unfolding1Heap := UnfoldingHeap;
                  Unfolding1Mask := UnfoldingMask;
                  assume tree#trigger(Unfolding1Heap, tree_1(t_2));
                  assume Unfolding1Heap[null, tree_1(t_2)] == CombineFrames(FrameFragment(Unfolding1Heap[t_2, key_6]), CombineFrames(FrameFragment(Unfolding1Heap[t_2, degree]), CombineFrames(FrameFragment(Unfolding1Heap[t_2, child]), CombineFrames(FrameFragment(Unfolding1Heap[t_2, parent]), CombineFrames(Unfolding1Heap[null, heapseg(Unfolding1Heap[t_2, child], null)], CombineFrames(FrameFragment((if 0 < Unfolding1Heap[t_2, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Unfolding1Heap[t_2, child] != null then EmptyFrame else EmptyFrame))))))));
                  ExhaleWellDef1Heap := Unfolding1Heap;
                  ExhaleWellDef1Mask := Unfolding1Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access tree(t) (BinomialHeap.vpr@390.11--390.101) [197475]"}
                      perm <= Unfolding1Mask[null, tree_1(t_2)];
                  }
                  Unfolding1Mask := Unfolding1Mask[null, tree_1(t_2):=Unfolding1Mask[null, tree_1(t_2)] - perm];
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, key_6:=Unfolding1Mask[t_2, key_6] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, degree:=Unfolding1Mask[t_2, degree] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, child:=Unfolding1Mask[t_2, child] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, parent:=Unfolding1Mask[t_2, parent] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume 0 <= Unfolding1Heap[t_2, degree];
                  perm := FullPerm;
                  Unfolding1Mask := Unfolding1Mask[null, heapseg(Unfolding1Heap[t_2, child], null):=Unfolding1Mask[null, heapseg(Unfolding1Heap[t_2, child], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(tree_1(t_2), Unfolding1Heap[null, tree_1(t_2)], heapseg(Unfolding1Heap[t_2, child], null), Unfolding1Heap[null, heapseg(Unfolding1Heap[t_2, child], null)]);
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume Unfolding1Heap[t_2, degree] == segLength(Unfolding1Heap, Unfolding1Heap[t_2, child], null);
                  if (0 < Unfolding1Heap[t_2, degree]) {
                    assume state(Unfolding1Heap, Unfolding1Mask);
                    assume segDegree(Unfolding1Heap, Unfolding1Heap[t_2, child], null, 0) == Unfolding1Heap[t_2, degree] - 1;
                  }
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume validChildren(Unfolding1Heap, Unfolding1Heap[t_2, child], null);
                  if (Unfolding1Heap[t_2, child] != null) {
                    assume state(Unfolding1Heap, Unfolding1Mask);
                    assume segParent(Unfolding1Heap, Unfolding1Heap[t_2, child], null) == t_2;
                  }
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  Unfolding2Heap := Unfolding1Heap;
                  Unfolding2Mask := Unfolding1Mask;
                  assume tree#trigger(Unfolding2Heap, tree_1(temp1));
                  assume Unfolding2Heap[null, tree_1(temp1)] == CombineFrames(FrameFragment(Unfolding2Heap[temp1, key_6]), CombineFrames(FrameFragment(Unfolding2Heap[temp1, degree]), CombineFrames(FrameFragment(Unfolding2Heap[temp1, child]), CombineFrames(FrameFragment(Unfolding2Heap[temp1, parent]), CombineFrames(Unfolding2Heap[null, heapseg(Unfolding2Heap[temp1, child], null)], CombineFrames(FrameFragment((if 0 < Unfolding2Heap[temp1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Unfolding2Heap[temp1, child] != null then EmptyFrame else EmptyFrame))))))));
                  ExhaleWellDef1Heap := Unfolding2Heap;
                  ExhaleWellDef1Mask := Unfolding2Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@390.11--390.101) [197476]"}
                      perm <= Unfolding2Mask[null, tree_1(temp1)];
                  }
                  Unfolding2Mask := Unfolding2Mask[null, tree_1(temp1):=Unfolding2Mask[null, tree_1(temp1)] - perm];
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, key_6:=Unfolding2Mask[temp1, key_6] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, degree:=Unfolding2Mask[temp1, degree] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, child:=Unfolding2Mask[temp1, child] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, parent:=Unfolding2Mask[temp1, parent] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume 0 <= Unfolding2Heap[temp1, degree];
                  perm := FullPerm;
                  Unfolding2Mask := Unfolding2Mask[null, heapseg(Unfolding2Heap[temp1, child], null):=Unfolding2Mask[null, heapseg(Unfolding2Heap[temp1, child], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(tree_1(temp1), Unfolding2Heap[null, tree_1(temp1)], heapseg(Unfolding2Heap[temp1, child], null), Unfolding2Heap[null, heapseg(Unfolding2Heap[temp1, child], null)]);
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume Unfolding2Heap[temp1, degree] == segLength(Unfolding2Heap, Unfolding2Heap[temp1, child], null);
                  if (0 < Unfolding2Heap[temp1, degree]) {
                    assume state(Unfolding2Heap, Unfolding2Mask);
                    assume segDegree(Unfolding2Heap, Unfolding2Heap[temp1, child], null, 0) == Unfolding2Heap[temp1, degree] - 1;
                  }
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume validChildren(Unfolding2Heap, Unfolding2Heap[temp1, child], null);
                  if (Unfolding2Heap[temp1, child] != null) {
                    assume state(Unfolding2Heap, Unfolding2Mask);
                    assume segParent(Unfolding2Heap, Unfolding2Heap[temp1, child], null) == temp1;
                  }
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  
                  // -- Free assumptions (exp module)
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key_6:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_126: Ref, f_142: (Field A B) ::
                      { newPMask[o_126, f_142] }
                      Heap[null, tree#sm(temp1)][o_126, f_142] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_126, f_142] ==> newPMask[o_126, f_142]
                    );
                    Heap := Heap[null, tree#sm(temp1):=newPMask];
                    assume state(Heap, Mask);
                  
                  // -- Free assumptions (exp module)
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, key_6:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, degree:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, child:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_91: Ref, f_143: (Field A B) ::
                      { newPMask[o_91, f_143] }
                      Heap[null, tree#sm(t_2)][o_91, f_143] || Heap[null, heapseg#sm(Heap[t_2, child], null)][o_91, f_143] ==> newPMask[o_91, f_143]
                    );
                    Heap := Heap[null, tree#sm(t_2):=newPMask];
                    assume state(Heap, Mask);
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key_6:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_127: Ref, f_104: (Field A B) ::
                      { newPMask[o_127, f_104] }
                      Heap[null, tree#sm(temp1)][o_127, f_104] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_127, f_104] ==> newPMask[o_127, f_104]
                    );
                    Heap := Heap[null, tree#sm(temp1):=newPMask];
                    assume state(Heap, Mask);
                  
                  // -- Free assumptions (exp module)
                    if (temp1 != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_128: Ref, f_144: (Field A B) ::
                        { newPMask[o_128, f_144] }
                        Heap[null, heapseg#sm(temp1, null)][o_128, f_144] || Heap[null, tree#sm(temp1)][o_128, f_144] ==> newPMask[o_128, f_144]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_92: Ref, f_145: (Field A B) ::
                        { newPMask[o_92, f_145] }
                        Heap[null, heapseg#sm(temp1, null)][o_92, f_145] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_92, f_145] ==> newPMask[o_92, f_145]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, key_6:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, degree:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, child:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_129: Ref, f_146: (Field A B) ::
                      { newPMask[o_129, f_146] }
                      Heap[null, tree#sm(t_2)][o_129, f_146] || Heap[null, heapseg#sm(Heap[t_2, child], null)][o_129, f_146] ==> newPMask[o_129, f_146]
                    );
                    Heap := Heap[null, tree#sm(t_2):=newPMask];
                    assume state(Heap, Mask);
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key_6:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_130: Ref, f_147: (Field A B) ::
                      { newPMask[o_130, f_147] }
                      Heap[null, tree#sm(temp1)][o_130, f_147] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_130, f_147] ==> newPMask[o_130, f_147]
                    );
                    Heap := Heap[null, tree#sm(temp1):=newPMask];
                    assume state(Heap, Mask);
                assert {:msg "  Assert might fail. Assertion t != temp1 might not hold. (BinomialHeap.vpr@390.11--390.101) [197477]"}
                  t_2 != temp1;
                
                // -- Free assumptions (exhale module)
                  if (temp1 != null) {
                    havoc newPMask;
                    assume (forall <A, B> o_131: Ref, f_148: (Field A B) ::
                      { newPMask[o_131, f_148] }
                      Heap[null, heapseg#sm(temp1, null)][o_131, f_148] || Heap[null, tree#sm(temp1)][o_131, f_148] ==> newPMask[o_131, f_148]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                    Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_132: Ref, f_149: (Field A B) ::
                      { newPMask[o_132, f_149] }
                      Heap[null, heapseg#sm(temp1, null)][o_132, f_149] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_132, f_149] ==> newPMask[o_132, f_149]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                  }
                  assume state(Heap, Mask);
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, key_6:=true]];
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, degree:=true]];
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, child:=true]];
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, parent:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_133: Ref, f_150: (Field A B) ::
                    { newPMask[o_133, f_150] }
                    Heap[null, tree#sm(t_2)][o_133, f_150] || Heap[null, heapseg#sm(Heap[t_2, child], null)][o_133, f_150] ==> newPMask[o_133, f_150]
                  );
                  Heap := Heap[null, tree#sm(t_2):=newPMask];
                  assume state(Heap, Mask);
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key_6:=true]];
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_134: Ref, f_151: (Field A B) ::
                    { newPMask[o_134, f_151] }
                    Heap[null, tree#sm(temp1)][o_134, f_151] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_134, f_151] ==> newPMask[o_134, f_151]
                  );
                  Heap := Heap[null, tree#sm(temp1):=newPMask];
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp1, temp1), write) -- BinomialHeap.vpr@392.4--392.30
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp1 != temp1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@392.4--392.30) [197478]"}
                      perm <= Mask[null, tree_1(temp1)];
                  }
                  Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, temp1), Heap[null, heapseg(temp1, temp1)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@392.4--392.30) [197479]"}
                      perm <= Mask[temp1, sibling];
                  }
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. There might be insufficient permission to access heapseg(temp1.sibling, temp1) (BinomialHeap.vpr@392.4--392.30) [197480]"}
                      perm <= Mask[null, heapseg(Heap[temp1, sibling], temp1)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], temp1):=Mask[null, heapseg(Heap[temp1, sibling], temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, temp1), Heap[null, heapseg(temp1, temp1)], heapseg(Heap[temp1, sibling], temp1), Heap[null, heapseg(Heap[temp1, sibling], temp1)]);
                  if (Heap[temp1, sibling] != temp1) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, temp1) might not hold. (BinomialHeap.vpr@392.4--392.30) [197481]"}
                      treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], temp1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp1, temp1):=Mask[null, heapseg(temp1, temp1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp1, temp1));
                assume Heap[null, heapseg(temp1, temp1)] == FrameFragment((if temp1 != temp1 then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], temp1)], FrameFragment((if Heap[temp1, sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp1, temp1))) {
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp1, temp1):=freshVersion];
                }
                if (temp1 != temp1) {
                  havoc newPMask;
                  assume (forall <A, B> o_135: Ref, f_152: (Field A B) ::
                    { newPMask[o_135, f_152] }
                    Heap[null, heapseg#sm(temp1, temp1)][o_135, f_152] || Heap[null, tree#sm(temp1)][o_135, f_152] ==> newPMask[o_135, f_152]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=Heap[null, heapseg#sm(temp1, temp1)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_136: Ref, f_153: (Field A B) ::
                    { newPMask[o_136, f_153] }
                    Heap[null, heapseg#sm(temp1, temp1)][o_136, f_153] || Heap[null, heapseg#sm(Heap[temp1, sibling], temp1)][o_136, f_153] ==> newPMask[o_136, f_153]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(t, temp1), write) -- BinomialHeap.vpr@393.4--393.26
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (t_2 != temp1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. There might be insufficient permission to access tree(t) (BinomialHeap.vpr@393.4--393.26) [197482]"}
                      perm <= Mask[null, tree_1(t_2)];
                  }
                  Mask := Mask[null, tree_1(t_2):=Mask[null, tree_1(t_2)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(t_2, temp1), Heap[null, heapseg(t_2, temp1)], tree_1(t_2), Heap[null, tree_1(t_2)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. There might be insufficient permission to access t.sibling (BinomialHeap.vpr@393.4--393.26) [197483]"}
                      perm <= Mask[t_2, sibling];
                  }
                  Mask := Mask[t_2, sibling:=Mask[t_2, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. There might be insufficient permission to access heapseg(t.sibling, temp1) (BinomialHeap.vpr@393.4--393.26) [197484]"}
                      perm <= Mask[null, heapseg(Heap[t_2, sibling], temp1)];
                  }
                  Mask := Mask[null, heapseg(Heap[t_2, sibling], temp1):=Mask[null, heapseg(Heap[t_2, sibling], temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(t_2, temp1), Heap[null, heapseg(t_2, temp1)], heapseg(Heap[t_2, sibling], temp1), Heap[null, heapseg(Heap[t_2, sibling], temp1)]);
                  if (Heap[t_2, sibling] != temp1) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. Assertion treeParent(t) == segParent(t.sibling, temp1) might not hold. (BinomialHeap.vpr@393.4--393.26) [197485]"}
                      treeParent(Heap, t_2) == segParent(Heap, Heap[t_2, sibling], temp1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(t_2, temp1):=Mask[null, heapseg(t_2, temp1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(t_2, temp1));
                assume Heap[null, heapseg(t_2, temp1)] == FrameFragment((if t_2 != temp1 then CombineFrames(Heap[null, tree_1(t_2)], CombineFrames(FrameFragment(Heap[t_2, sibling]), CombineFrames(Heap[null, heapseg(Heap[t_2, sibling], temp1)], FrameFragment((if Heap[t_2, sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(t_2, temp1))) {
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(t_2, temp1):=freshVersion];
                }
                if (t_2 != temp1) {
                  havoc newPMask;
                  assume (forall <A, B> o_137: Ref, f_154: (Field A B) ::
                    { newPMask[o_137, f_154] }
                    Heap[null, heapseg#sm(t_2, temp1)][o_137, f_154] || Heap[null, tree#sm(t_2)][o_137, f_154] ==> newPMask[o_137, f_154]
                  );
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=newPMask];
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=Heap[null, heapseg#sm(t_2, temp1)][t_2, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_138: Ref, f_155: (Field A B) ::
                    { newPMask[o_138, f_155] }
                    Heap[null, heapseg#sm(t_2, temp1)][o_138, f_155] || Heap[null, heapseg#sm(Heap[t_2, sibling], temp1)][o_138, f_155] ==> newPMask[o_138, f_155]
                  );
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@394.4--394.31
                assume heapseg#trigger(Heap, heapseg(temp1, null));
                assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@394.4--394.31) [197486]"}
                    perm <= Mask[null, heapseg(temp1, null)];
                }
                Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp1, null):=newVersion];
                  }
                if (temp1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: concat(this.Nodes, t, temp1) -- BinomialHeap.vpr@395.4--395.32
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Check definedness of this.Nodes
                  assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@395.4--395.32) [197487]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                arg_a_3 := Heap[this, Nodes_1];
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, t) (BinomialHeap.vpr@395.4--395.32) [197488]"}
                      perm <= Mask[null, heapseg(arg_a_3, t_2)];
                  }
                  Mask := Mask[null, heapseg(arg_a_3, t_2):=Mask[null, heapseg(arg_a_3, t_2)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(t, temp1) (BinomialHeap.vpr@395.4--395.32) [197489]"}
                      perm <= Mask[null, heapseg(t_2, temp1)];
                  }
                  Mask := Mask[null, heapseg(t_2, temp1):=Mask[null, heapseg(t_2, temp1)] - perm];
                  if (temp1 != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@395.4--395.32) [197490]"}
                        perm <= Mask[null, tree_1(temp1)];
                    }
                    Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
                  }
                  if (arg_a_3 != t_2 && t_2 != temp1) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, t) == segParent(t, temp1) might not hold. (BinomialHeap.vpr@395.4--395.32) [197491]"}
                      segParent(Heap, arg_a_3, t_2) == segParent(Heap, t_2, temp1);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(arg_a_3, temp1):=Mask[null, heapseg(arg_a_3, temp1)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, arg_a_3, temp1) == segLength(PreCallHeap, arg_a_3, t_2) + segLength(PreCallHeap, t_2, temp1);
                  assume state(Heap, Mask);
                  assume (forall i_6_2: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a_3, temp1)], arg_a_3, temp1, i_6_2) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_3, t_2)], arg_a_3, t_2, i_6_2) }
                    0 <= i_6_2 && i_6_2 < segLength(PreCallHeap, arg_a_3, t_2) ==> segDegree(Heap, arg_a_3, temp1, i_6_2) == segDegree(PreCallHeap, arg_a_3, t_2, i_6_2)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_7_1: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a_3, temp1)], arg_a_3, temp1, i_7_1) }
                    segLength(PreCallHeap, arg_a_3, t_2) <= i_7_1 && i_7_1 < segLength(Heap, arg_a_3, temp1) ==> segDegree(Heap, arg_a_3, temp1, i_7_1) == segDegree(PreCallHeap, t_2, temp1, i_7_1 - segLength(PreCallHeap, arg_a_3, t_2))
                  );
                  if (temp1 != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, temp1) == treeDegree(PreCallHeap, temp1);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, temp1) == treeSize(PreCallHeap, temp1);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp1) == treeParent(PreCallHeap, temp1);
                  }
                  if (sorted_1(PreCallHeap, arg_a_3, t_2) && (sorted_1(PreCallHeap, t_2, temp1) && (0 < segLength(PreCallHeap, arg_a_3, t_2) && 0 < segLength(PreCallHeap, t_2, temp1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) < segDegree(PreCallHeap, t_2, temp1, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted_1(Heap, arg_a_3, temp1);
                  }
                  if (presorted(PreCallHeap, arg_a_3, t_2) && (presorted(PreCallHeap, t_2, temp1) && (0 < segLength(PreCallHeap, arg_a_3, t_2) && 0 < segLength(PreCallHeap, t_2, temp1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) <= segDegree(PreCallHeap, t_2, temp1, 0) && ((2 <= segLength(PreCallHeap, arg_a_3, t_2) && segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) == segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 2) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) < segDegree(PreCallHeap, t_2, temp1, 0)) && (2 <= segLength(PreCallHeap, t_2, temp1) && segDegree(PreCallHeap, t_2, temp1, 0) == segDegree(PreCallHeap, t_2, temp1, 1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) < segDegree(PreCallHeap, t_2, temp1, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, arg_a_3, temp1);
                  }
                  if (validChildren(PreCallHeap, arg_a_3, t_2) && (validChildren(PreCallHeap, t_2, temp1) && (0 < segLength(PreCallHeap, arg_a_3, t_2) && 0 < segLength(PreCallHeap, t_2, temp1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) == segDegree(PreCallHeap, t_2, temp1, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, arg_a_3, temp1);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, arg_a_3, temp1) == segSize(PreCallHeap, arg_a_3, t_2) + segSize(PreCallHeap, t_2, temp1);
                  if (arg_a_3 != t_2) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a_3, temp1) == segParent(PreCallHeap, arg_a_3, t_2);
                  }
                  if (t_2 != temp1) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a_3, temp1) == segParent(PreCallHeap, t_2, temp1);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@396.4--396.29
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp1 != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@396.4--396.29) [197492]"}
                      perm <= Mask[null, tree_1(temp1)];
                  }
                  Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree_1(temp1), Heap[null, tree_1(temp1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@396.4--396.29) [197493]"}
                      perm <= Mask[temp1, sibling];
                  }
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@396.4--396.29) [197494]"}
                      perm <= Mask[null, heapseg(Heap[temp1, sibling], null)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                  if (Heap[temp1, sibling] != null) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, null) might not hold. (BinomialHeap.vpr@396.4--396.29) [197495]"}
                      treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp1, null));
                assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                  Heap := Heap[null, heapseg#sm(temp1, null):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp1, null):=freshVersion];
                }
                if (temp1 != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_154: Ref, f_163: (Field A B) ::
                    { newPMask[o_154, f_163] }
                    Heap[null, heapseg#sm(temp1, null)][o_154, f_163] || Heap[null, tree#sm(temp1)][o_154, f_163] ==> newPMask[o_154, f_163]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_155: Ref, f_164: (Field A B) ::
                    { newPMask[o_155, f_164] }
                    Heap[null, heapseg#sm(temp1, null)][o_155, f_164] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_155, f_164] ==> newPMask[o_155, f_164]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            // Exhale invariant
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            assert {:msg "  Loop invariant temp1 != null might not be preserved. Assertion temp1 != null might not hold. (BinomialHeap.vpr@358.14--358.27) [197496]"}
              temp1 != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not be preserved. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@359.14--359.60) [197497]"}
                perm <= Mask[null, heapseg(temp1, null)];
            }
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not be preserved. Assertion presorted(temp1, null) might not hold. (BinomialHeap.vpr@359.14--359.60) [197498]"}
              presorted(Heap, temp1, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@360.14--360.57) [197499]"}
                perm <= Mask[null, heapseg(temp2, null)];
            }
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@360.14--360.57) [197500]"}
              sorted_1(Heap, temp2, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@361.14--361.51) [197501]"}
                perm <= Mask[this, Nodes_1];
            }
            Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
            assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@361.14--361.51) [197502]"}
              Heap[this, Nodes_1] != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@362.14--362.72) [197503]"}
                perm <= Mask[null, heapseg(Heap[this, Nodes_1], temp1)];
            }
            Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@362.14--362.72) [197504]"}
              presorted(Heap, Heap[this, Nodes_1], temp1);
            assert {:msg "  Loop invariant 0 < segLength(temp1, null) might not be preserved. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@363.14--363.40) [197505]"}
              0 < segLength(Heap, temp1, null);
            if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
              assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [197506]"}
                segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [197507]"}
                  segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [197508]"}
                  segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            if (0 < segLength(Heap, temp2, null)) {
              assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [197509]"}
                segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [197510]"}
                  segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@380.14--380.150) [197511]"}
              segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not be preserved. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@381.14--381.80) [197512]"}
                segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            if (Heap[this, Nodes_1] != temp1) {
              assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@382.14--382.92) [197513]"}
                segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
            }
            if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
              assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@383.14--383.109) [197514]"}
                segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
            }
            assert {:msg "  Loop invariant segParent(temp1, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@384.14--384.72) [197515]"}
              segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@385.14--385.90) [197516]"}
                segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
            }
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Terminate execution
            assume false;
          }
        
        // -- Inhale loop invariant after loop, and assume guard
          assume !(Heap[temp1, sibling] != null);
          assume state(Heap, Mask);
          assume temp1 != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume presorted(Heap, temp1, null);
          perm := FullPerm;
          Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted_1(Heap, temp2, null);
          perm := FullPerm;
          assume this != null;
          Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
          assume state(Heap, Mask);
          assume Heap[this, Nodes_1] != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp1):=Mask[null, heapseg(Heap[this, Nodes_1], temp1)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume presorted(Heap, Heap[this, Nodes_1], temp1);
          assume state(Heap, Mask);
          assume 0 < segLength(Heap, temp1, null);
          if (0 < segLength(Heap, Heap[this, Nodes_1], temp1)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
            if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) && segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) == segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 2)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
            }
            if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1) < segDegree(Heap, temp1, null, 0);
            }
          }
          if (0 < segLength(Heap, temp2, null)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
            if (2 <= segLength(Heap, Heap[this, Nodes_1], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes_1], temp1, segLength(Heap, Heap[this, Nodes_1], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
            }
          }
          assume state(Heap, Mask);
          assume segSize(Heap, Heap[this, Nodes_1], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
          if (temp2 != null) {
            assume state(Heap, Mask);
            assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
          }
          if (Heap[this, Nodes_1] != temp1) {
            assume state(Heap, Mask);
            assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp1, null);
          }
          if (Heap[this, Nodes_1] != temp1 && temp2 != null) {
            assume state(Heap, Mask);
            assume segParent(Heap, Heap[this, Nodes_1], temp1) == segParent(Heap, temp2, null);
          }
          assume state(Heap, Mask);
          assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
          if (temp2 != null) {
            assume state(Heap, Mask);
            assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
          }
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@400.3--400.30
        assume heapseg#trigger(Heap, heapseg(temp1, null));
        assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@400.3--400.30) [197519]"}
            perm <= Mask[null, heapseg(temp1, null)];
        }
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
        
        // -- Update version of predicate
          if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
            havoc newVersion;
            Heap := Heap[null, heapseg(temp1, null):=newVersion];
          }
        if (temp1 != null) {
          perm := FullPerm;
          Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree_1(temp1), Heap[null, tree_1(temp1)]);
          assume state(Heap, Mask);
          perm := FullPerm;
          assume temp1 != null;
          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
          assume state(Heap, Mask);
          if (Heap[temp1, sibling] != null) {
            assume state(Heap, Mask);
            assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
          }
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: assert 1 < segLength(temp2, null) ==>
  //   segDegree(temp2, null, 0) < segDegree(temp2, null, 1) -- BinomialHeap.vpr@403.3--403.94
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        
        // -- Check definedness of 1 < segLength(temp2, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef1Heap := ExhaleWellDef0Heap;
            ExhaleWellDef1Mask := ExhaleWellDef0Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@403.14--403.36) [197523]"}
              NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp2, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
            ExhaleWellDef0Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        if (1 < segLength(Heap, temp2, null)) {
          
          // -- Check definedness of segDegree(temp2, null, 0) < segDegree(temp2, null, 1)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef1Heap := ExhaleWellDef0Heap;
              ExhaleWellDef1Mask := ExhaleWellDef0Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@403.41--403.66) [197524]"}
                NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@403.41--403.66) [197525]"}
                0 < segLength(ExhaleWellDef0Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
              ExhaleWellDef0Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef1Heap := ExhaleWellDef0Heap;
              ExhaleWellDef1Mask := ExhaleWellDef0Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@403.69--403.94) [197526]"}
                NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@403.69--403.94) [197527]"}
                1 < segLength(ExhaleWellDef0Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
              ExhaleWellDef0Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assert {:msg "  Assert might fail. Assertion segDegree(temp2, null, 0) < segDegree(temp2, null, 1) might not hold. (BinomialHeap.vpr@403.10--403.94) [197528]"}
            segDegree(Heap, temp2, null, 0) < segDegree(Heap, temp2, null, 1);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: temp1.sibling := temp2 -- BinomialHeap.vpr@404.3--404.25
        assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@404.3--404.25) [197529]"}
          FullPerm == Mask[temp1, sibling];
        Heap := Heap[temp1, sibling:=temp2];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@405.3--405.28
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (temp1 != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@405.3--405.28) [197532]"}
              perm <= Mask[null, tree_1(temp1)];
          }
          Mask := Mask[null, tree_1(temp1):=Mask[null, tree_1(temp1)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree_1(temp1), Heap[null, tree_1(temp1)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@405.3--405.28) [197534]"}
              perm <= Mask[temp1, sibling];
          }
          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@405.3--405.28) [197536]"}
              perm <= Mask[null, heapseg(Heap[temp1, sibling], null)];
          }
          Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
          if (Heap[temp1, sibling] != null) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, null) might not hold. (BinomialHeap.vpr@405.3--405.28) [197537]"}
              treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(temp1, null));
        assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree_1(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
          Heap := Heap[null, heapseg#sm(temp1, null):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(temp1, null):=freshVersion];
        }
        if (temp1 != null) {
          havoc newPMask;
          assume (forall <A, B> o_156: Ref, f_165: (Field A B) ::
            { newPMask[o_156, f_165] }
            Heap[null, heapseg#sm(temp1, null)][o_156, f_165] || Heap[null, tree#sm(temp1)][o_156, f_165] ==> newPMask[o_156, f_165]
          );
          Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
          Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_157: Ref, f_166: (Field A B) ::
            { newPMask[o_157, f_166] }
            Heap[null, heapseg#sm(temp1, null)][o_157, f_166] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_157, f_166] ==> newPMask[o_157, f_166]
          );
          Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: concat(this.Nodes, temp1, null) -- BinomialHeap.vpr@408.2--408.33
    PreCallHeap := Heap;
    PreCallMask := Mask;
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@408.2--408.33) [197539]"}
        HasDirectPerm(Mask, this, Nodes_1);
    arg_a_4 := Heap[this, Nodes_1];
    
    // -- Exhaling precondition
      ExhaleWellDef0Heap := Heap;
      ExhaleWellDef0Mask := Mask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@408.2--408.33) [197540]"}
          perm <= Mask[null, heapseg(arg_a_4, temp1)];
      }
      Mask := Mask[null, heapseg(arg_a_4, temp1):=Mask[null, heapseg(arg_a_4, temp1)] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@408.2--408.33) [197541]"}
          perm <= Mask[null, heapseg(temp1, null)];
      }
      Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
      if (null != null) {
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@408.2--408.33) [197542]"}
            perm <= Mask[null, tree_1(null)];
        }
        Mask := Mask[null, tree_1(null):=Mask[null, tree_1(null)] - perm];
      }
      if (arg_a_4 != temp1 && temp1 != null) {
        assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@408.2--408.33) [197543]"}
          segParent(Heap, arg_a_4, temp1) == segParent(Heap, temp1, null);
      }
      // Finish exhale
      havoc ExhaleHeap;
      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
      Heap := ExhaleHeap;
    
    // -- Inhaling postcondition
      perm := FullPerm;
      Mask := Mask[null, heapseg(arg_a_4, null):=Mask[null, heapseg(arg_a_4, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume segLength(Heap, arg_a_4, null) == segLength(PreCallHeap, arg_a_4, temp1) + segLength(PreCallHeap, temp1, null);
      assume state(Heap, Mask);
      assume (forall i_8_1: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_4, null)], arg_a_4, null, i_8_1) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_4, temp1)], arg_a_4, temp1, i_8_1) }
        0 <= i_8_1 && i_8_1 < segLength(PreCallHeap, arg_a_4, temp1) ==> segDegree(Heap, arg_a_4, null, i_8_1) == segDegree(PreCallHeap, arg_a_4, temp1, i_8_1)
      );
      assume state(Heap, Mask);
      assume (forall i_9_1: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_4, null)], arg_a_4, null, i_9_1) }
        segLength(PreCallHeap, arg_a_4, temp1) <= i_9_1 && i_9_1 < segLength(Heap, arg_a_4, null) ==> segDegree(Heap, arg_a_4, null, i_9_1) == segDegree(PreCallHeap, temp1, null, i_9_1 - segLength(PreCallHeap, arg_a_4, temp1))
      );
      if (null != null) {
        perm := FullPerm;
        Mask := Mask[null, tree_1(null):=Mask[null, tree_1(null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume treeDegree(Heap, null) == treeDegree(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeSize(Heap, null) == treeSize(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeParent(Heap, null) == treeParent(PreCallHeap, null);
      }
      if (sorted_1(PreCallHeap, arg_a_4, temp1) && (sorted_1(PreCallHeap, temp1, null) && (0 < segLength(PreCallHeap, arg_a_4, temp1) && 0 < segLength(PreCallHeap, temp1, null) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) < segDegree(PreCallHeap, temp1, null, 0)))) {
        assume state(Heap, Mask);
        assume sorted_1(Heap, arg_a_4, null);
      }
      if (presorted(PreCallHeap, arg_a_4, temp1) && (presorted(PreCallHeap, temp1, null) && (0 < segLength(PreCallHeap, arg_a_4, temp1) && 0 < segLength(PreCallHeap, temp1, null) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) <= segDegree(PreCallHeap, temp1, null, 0) && ((2 <= segLength(PreCallHeap, arg_a_4, temp1) && segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) == segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 2) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) < segDegree(PreCallHeap, temp1, null, 0)) && (2 <= segLength(PreCallHeap, temp1, null) && segDegree(PreCallHeap, temp1, null, 0) == segDegree(PreCallHeap, temp1, null, 1) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) < segDegree(PreCallHeap, temp1, null, 0)))))) {
        assume state(Heap, Mask);
        assume presorted(Heap, arg_a_4, null);
      }
      if (validChildren(PreCallHeap, arg_a_4, temp1) && (validChildren(PreCallHeap, temp1, null) && (0 < segLength(PreCallHeap, arg_a_4, temp1) && 0 < segLength(PreCallHeap, temp1, null) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) == segDegree(PreCallHeap, temp1, null, 0) + 1))) {
        assume state(Heap, Mask);
        assume validChildren(Heap, arg_a_4, null);
      }
      assume state(Heap, Mask);
      assume segSize(Heap, arg_a_4, null) == segSize(PreCallHeap, arg_a_4, temp1) + segSize(PreCallHeap, temp1, null);
      if (arg_a_4 != temp1) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_4, null) == segParent(PreCallHeap, arg_a_4, temp1);
      }
      if (temp1 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_4, null) == segParent(PreCallHeap, temp1, null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of merge might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [197544]"}
        perm <= Mask[this, Nodes_1];
    }
    Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
    assert {:msg "  Postcondition of merge might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@252.10--252.107) [197545]"}
      Heap[this, Nodes_1] != null;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of merge might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@252.10--252.107) [197546]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes_1], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] - perm];
    assert {:msg "  Postcondition of merge might not hold. Assertion presorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@252.10--252.107) [197547]"}
      presorted(Heap, Heap[this, Nodes_1], null);
    assert {:msg "  Postcondition of merge might not hold. Assertion segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@253.10--253.99) [197548]"}
      segSize(Heap, Heap[this, Nodes_1], null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
    assert {:msg "  Postcondition of merge might not hold. Assertion segParent(this.Nodes, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@254.10--254.73) [197549]"}
      segParent(Heap, Heap[this, Nodes_1], null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method unionNodes
// ==================================================

procedure unionNodes(this: Ref, binHeap: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var prevTemp: Ref;
  var temp_1: Ref;
  var nextTemp: Ref;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var newVersion: FrameType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var arg_a: Ref;
  var arg_a_1: Ref;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
    assume Heap[binHeap, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@419.11--420.54) [197550]"}
        HasDirectPerm(Mask, this, Nodes_1);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@419.11--420.54) [197551]"}
        HasDirectPerm(Mask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@420.30--420.54) [197552]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(Heap, Heap[this, Nodes_1], null);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@421.11--421.29) [197553]"}
        HasDirectPerm(Mask, this, Nodes_1);
    assume Heap[this, Nodes_1] != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(binHeap, null):=Mask[null, heapseg(binHeap, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(binHeap, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@422.37--422.58) [197554]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(Heap, binHeap, null);
    assume state(Heap, Mask);
    if (binHeap != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.Nodes, null) == segParent(binHeap, null)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@423.11--423.86) [197555]"}
          HasDirectPerm(Mask, this, Nodes_1);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@423.31--423.58) [197556]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@423.31--423.58) [197557]"}
            Heap[this, Nodes_1] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@423.62--423.86) [197558]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion binHeap != null might not hold. (BinomialHeap.vpr@423.62--423.86) [197559]"}
            binHeap != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, Nodes_1], null) == segParent(Heap, binHeap, null);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    assume this != null;
    PostMask := PostMask[this, Nodes_1:=PostMask[this, Nodes_1] + perm];
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@424.10--425.54) [197560]"}
        HasDirectPerm(PostMask, this, Nodes_1);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(PostHeap[this, Nodes_1], null):=PostMask[null, heapseg(PostHeap[this, Nodes_1], null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@424.10--425.54) [197561]"}
        HasDirectPerm(PostMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@425.30--425.54) [197562]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted_1(PostHeap, PostHeap[this, Nodes_1], null);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@426.10--426.28) [197563]"}
        HasDirectPerm(PostMask, this, Nodes_1);
    assume PostHeap[this, Nodes_1] != null;
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@427.10--427.99) [197564]"}
        HasDirectPerm(PostMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@427.10--427.35) [197565]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes_1], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@427.10--427.99) [197566]"}
        HasDirectPerm(oldMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@427.43--427.68) [197567]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@427.76--427.98) [197568]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, PostHeap[this, Nodes_1], null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(this.Nodes, null) == old(segParent(this.Nodes, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@428.10--428.73) [197569]"}
        HasDirectPerm(PostMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@428.10--428.37) [197570]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes_1], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@428.10--428.37) [197571]"}
          PostHeap[this, Nodes_1] != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@428.10--428.73) [197572]"}
        HasDirectPerm(oldMask, this, Nodes_1);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@428.45--428.72) [197573]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@428.45--428.72) [197574]"}
          oldHeap[this, Nodes_1] != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, PostHeap[this, Nodes_1], null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[prevTemp, $allocated];
    assume Heap[temp_1, $allocated];
    assume Heap[nextTemp, $allocated];
  
  // -- Translating statement: merge(this, binHeap) -- BinomialHeap.vpr@430.2--430.22
    PreCallHeap := Heap;
    PreCallMask := Mask;
    
    // -- Exhaling precondition
      ExhaleWellDef0Heap := Heap;
      ExhaleWellDef0Mask := Mask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method merge might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@430.2--430.22) [197575]"}
          perm <= Mask[this, Nodes_1];
      }
      Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method merge might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@430.2--430.22) [197576]"}
          perm <= Mask[null, heapseg(Heap[this, Nodes_1], null)];
      }
      Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] - perm];
      assert {:msg "  The precondition of method merge might not hold. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@430.2--430.22) [197577]"}
        sorted_1(Heap, Heap[this, Nodes_1], null);
      assert {:msg "  The precondition of method merge might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@430.2--430.22) [197578]"}
        Heap[this, Nodes_1] != null;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method merge might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@430.2--430.22) [197579]"}
          perm <= Mask[null, heapseg(binHeap, null)];
      }
      Mask := Mask[null, heapseg(binHeap, null):=Mask[null, heapseg(binHeap, null)] - perm];
      assert {:msg "  The precondition of method merge might not hold. Assertion sorted(binHeap, null) might not hold. (BinomialHeap.vpr@430.2--430.22) [197580]"}
        sorted_1(Heap, binHeap, null);
      if (binHeap != null) {
        assert {:msg "  The precondition of method merge might not hold. Assertion segParent(this.Nodes, null) == segParent(binHeap, null) might not hold. (BinomialHeap.vpr@430.2--430.22) [197581]"}
          segParent(Heap, Heap[this, Nodes_1], null) == segParent(Heap, binHeap, null);
      }
      // Finish exhale
      havoc ExhaleHeap;
      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
      Heap := ExhaleHeap;
    
    // -- Inhaling postcondition
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
      assume state(Heap, Mask);
      assume Heap[this, Nodes_1] != null;
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume presorted(Heap, Heap[this, Nodes_1], null);
      assume state(Heap, Mask);
      assume segSize(Heap, Heap[this, Nodes_1], null) == segSize(PreCallHeap, PreCallHeap[this, Nodes_1], null) + segSize(PreCallHeap, binHeap, null);
      assume state(Heap, Mask);
      assume segParent(Heap, Heap[this, Nodes_1], null) == segParent(PreCallHeap, PreCallHeap[this, Nodes_1], null);
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: prevTemp := null -- BinomialHeap.vpr@435.2--435.18
    prevTemp := null;
    assume state(Heap, Mask);
  
  // -- Translating statement: temp := this.Nodes -- BinomialHeap.vpr@436.2--436.20
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@436.2--436.20) [197582]"}
        HasDirectPerm(Mask, this, Nodes_1);
    temp_1 := Heap[this, Nodes_1];
    assume state(Heap, Mask);
  
  // -- Translating statement: unfold acc(heapseg(this.Nodes, null), write) -- BinomialHeap.vpr@437.2--437.34
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Unfolding heapseg(this.Nodes, null) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@437.2--437.34) [197583]"}
        HasDirectPerm(Mask, this, Nodes_1);
    assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes_1], null));
    assume Heap[null, heapseg(Heap[this, Nodes_1], null)] == FrameFragment((if Heap[this, Nodes_1] != null then CombineFrames(Heap[null, tree_1(Heap[this, Nodes_1])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes_1], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], null)], FrameFragment((if Heap[Heap[this, Nodes_1], sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Unfolding heapseg(this.Nodes, null) might fail. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@437.2--437.34) [197586]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes_1], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] - perm];
    
    // -- Update version of predicate
      if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes_1], null))) {
        havoc newVersion;
        Heap := Heap[null, heapseg(Heap[this, Nodes_1], null):=newVersion];
      }
    if (Heap[this, Nodes_1] != null) {
      perm := FullPerm;
      Mask := Mask[null, tree_1(Heap[this, Nodes_1]):=Mask[null, tree_1(Heap[this, Nodes_1])] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(Heap[this, Nodes_1], null), Heap[null, heapseg(Heap[this, Nodes_1], null)], tree_1(Heap[this, Nodes_1]), Heap[null, tree_1(Heap[this, Nodes_1])]);
      assume state(Heap, Mask);
      perm := FullPerm;
      assume Heap[this, Nodes_1] != null;
      Mask := Mask[Heap[this, Nodes_1], sibling:=Mask[Heap[this, Nodes_1], sibling] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], null):=Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(Heap[this, Nodes_1], null), Heap[null, heapseg(Heap[this, Nodes_1], null)], heapseg(Heap[Heap[this, Nodes_1], sibling], null), Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], null)]);
      assume state(Heap, Mask);
      if (Heap[Heap[this, Nodes_1], sibling] != null) {
        assume state(Heap, Mask);
        assume treeParent(Heap, Heap[this, Nodes_1]) == segParent(Heap, Heap[Heap[this, Nodes_1], sibling], null);
      }
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: nextTemp := temp.sibling -- BinomialHeap.vpr@438.2--438.26
    
    // -- Check definedness of temp.sibling
      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@438.2--438.26) [197590]"}
        HasDirectPerm(Mask, temp_1, sibling);
    nextTemp := Heap[temp_1, sibling];
    assume state(Heap, Mask);
  
  // -- Translating statement: while (nextTemp != null) -- BinomialHeap.vpr@440.2--515.3
    
    // -- Before loop head
      
      // -- Exhale loop invariant before loop
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) might not hold on entry. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@441.13--441.28) [197591]"}
            perm <= Mask[this, Nodes_1];
        }
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not hold on entry. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@442.13--442.95) [197592]"}
              perm <= Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
          }
          Mask := Mask[null, heapseg(Heap[this, Nodes_1], prevTemp):=Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not hold on entry. Assertion sorted(this.Nodes, prevTemp) might not hold. (BinomialHeap.vpr@442.13--442.95) [197593]"}
            sorted_1(Heap, Heap[this, Nodes_1], prevTemp);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> this.Nodes == temp might not hold on entry. Assertion this.Nodes == temp might not hold. (BinomialHeap.vpr@443.13--443.52) [197594]"}
            Heap[this, Nodes_1] == temp_1;
        }
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not hold on entry. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@444.13--444.65) [197595]"}
            perm <= Mask[null, heapseg(nextTemp, null)];
        }
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not hold on entry. Assertion presorted(nextTemp, null) might not hold. (BinomialHeap.vpr@444.13--444.65) [197596]"}
          presorted(Heap, nextTemp, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@445.13--447.48) [197597]"}
            perm <= Mask[null, tree_1(temp_1)];
        }
        Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@445.13--447.48) [197598]"}
            perm <= Mask[temp_1, sibling];
        }
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
        assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. Assertion temp.sibling == nextTemp might not hold. (BinomialHeap.vpr@445.13--447.48) [197599]"}
          Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. Assertion treeDegree(temp) <= segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@445.13--447.48) [197600]"}
            treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. Assertion treeParent(temp) == segParent(nextTemp, null) might not hold. (BinomialHeap.vpr@445.13--447.48) [197601]"}
            treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@448.13--450.42) [197602]"}
              perm <= Mask[null, tree_1(prevTemp)];
          }
          Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@448.13--450.42) [197603]"}
              perm <= Mask[prevTemp, sibling];
          }
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@448.13--450.42) [197604]"}
            Heap[prevTemp, sibling] == temp_1;
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. Assertion treeDegree(prevTemp) <= treeDegree(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [197605]"}
            treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. Assertion treeParent(prevTemp) == treeParent(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [197606]"}
            treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes_1], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assert {:msg "  Loop invariant prevTemp != null && (0 < segLength(this.Nodes, prevTemp) && (2 <= segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && segDegree(nextTemp, null, 0) == segDegree(nextTemp, null, 1)))) ==> treeDegree(prevTemp) < treeDegree(temp) might not hold on entry. Assertion treeDegree(prevTemp) < treeDegree(temp) might not hold. (BinomialHeap.vpr@451.13--454.41) [197607]"}
            treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not hold on entry. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@455.13--458.98) [197608]"}
            0 < segLength(Heap, nextTemp, null);
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not hold on entry. Assertion treeDegree(temp) == segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@455.13--458.98) [197609]"}
            treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          if (2 <= segLength(Heap, nextTemp, null)) {
            assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not hold on entry. Assertion segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1) might not hold. (BinomialHeap.vpr@455.13--458.98) [197610]"}
              segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes_1], prevTemp)) {
          assert {:msg "  Loop invariant prevTemp != null && 0 < segLength(this.Nodes, prevTemp) ==> segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold on entry. Assertion segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@459.13--461.93) [197611]"}
            segDegree(Heap, Heap[this, Nodes_1], prevTemp, segLength(Heap, Heap[this, Nodes_1], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        if (prevTemp != null) {
          assert {:msg "  Loop invariant prevTemp != null ==> segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@462.13--463.159) [197612]"}
            segSize(Heap, Heap[this, Nodes_1], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@464.13--465.106) [197613]"}
            treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp != null && Heap[this, Nodes_1] != prevTemp) {
          assert {:msg "  Loop invariant prevTemp != null && this.Nodes != prevTemp ==> segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not hold on entry. Assertion segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not hold. (BinomialHeap.vpr@466.13--466.115) [197614]"}
            segParent(Heap, Heap[this, Nodes_1], prevTemp) == treeParent(Heap, prevTemp);
        }
        assert {:msg "  Loop invariant treeParent(temp) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion treeParent(temp) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@467.13--467.65) [197615]"}
          treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
    
    // -- Havoc loop written variables (except locals)
      havoc nextTemp, temp_1, prevTemp;
      assume Heap[nextTemp, $allocated];
      assume Heap[temp_1, $allocated];
      assume Heap[prevTemp, $allocated];
    
    // -- Check definedness of invariant
      if (*) {
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        if (prevTemp != null) {
          
          // -- Check definedness of acc(heapseg(this.Nodes, prevTemp), write)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@442.13--442.95) [197616]"}
              HasDirectPerm(Mask, this, Nodes_1);
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[this, Nodes_1], prevTemp):=Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          
          // -- Check definedness of sorted(this.Nodes, prevTemp)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@442.13--442.95) [197617]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@442.67--442.95) [197618]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume sorted_1(Heap, Heap[this, Nodes_1], prevTemp);
        }
        assume state(Heap, Mask);
        if (prevTemp == null) {
          
          // -- Check definedness of this.Nodes == temp
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@443.13--443.52) [197619]"}
              HasDirectPerm(Mask, this, Nodes_1);
          assume Heap[this, Nodes_1] == temp_1;
        }
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of presorted(nextTemp, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@444.40--444.65) [197620]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume presorted(Heap, nextTemp, null);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
        assume state(Heap, Mask);
        
        // -- Check definedness of temp.sibling == nextTemp
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@445.13--447.48) [197621]"}
            HasDirectPerm(Mask, temp_1, sibling);
        assume Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(temp) <= segDegree(nextTemp, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@446.24--446.40) [197622]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@446.44--446.72) [197623]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@446.44--446.72) [197624]"}
                0 < segLength(Heap, nextTemp, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assume state(Heap, Mask);
          
          // -- Check definedness of treeParent(temp) == segParent(nextTemp, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@447.2--447.18) [197625]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@447.22--447.47) [197626]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion nextTemp != null might not hold. (BinomialHeap.vpr@447.22--447.47) [197627]"}
                nextTemp != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        assume state(Heap, Mask);
        if (prevTemp != null) {
          perm := FullPerm;
          Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          assume prevTemp != null;
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
          assume state(Heap, Mask);
          
          // -- Check definedness of prevTemp.sibling == temp
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@448.13--450.42) [197628]"}
              HasDirectPerm(Mask, prevTemp, sibling);
          assume Heap[prevTemp, sibling] == temp_1;
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(prevTemp) <= treeDegree(temp)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@449.2--449.22) [197629]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@449.26--449.42) [197630]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assume state(Heap, Mask);
          
          // -- Check definedness of treeParent(prevTemp) == treeParent(temp)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@450.2--450.22) [197631]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@450.26--450.42) [197632]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && (0 < segLength(this.Nodes, prevTemp) && (2 <= segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && segDegree(nextTemp, null, 0) == segDegree(nextTemp, null, 1))))
          if (prevTemp != null) {
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@451.13--454.41) [197633]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@451.37--451.68) [197634]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (0 < segLength(Heap, Heap[this, Nodes_1], prevTemp)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@451.77--451.102) [197635]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (2 <= segLength(Heap, nextTemp, null)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@452.2--452.18) [197636]"}
                    NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@452.22--452.50) [197637]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@452.22--452.50) [197638]"}
                    0 < segLength(Heap, nextTemp, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@452.54--452.82) [197639]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@452.54--452.82) [197640]"}
                      0 < segLength(Heap, nextTemp, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@452.86--452.114) [197641]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@452.86--452.114) [197642]"}
                      1 < segLength(Heap, nextTemp, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              }
            }
          }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes_1], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(prevTemp) < treeDegree(temp)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@454.2--454.22) [197643]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@454.25--454.41) [197644]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && treeDegree(prevTemp) == treeDegree(temp)
          if (prevTemp != null) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@455.33--455.53) [197645]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@455.57--455.73) [197646]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of 0 < segLength(nextTemp, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@457.6--457.31) [197647]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume 0 < segLength(Heap, nextTemp, null);
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(temp) == segDegree(nextTemp, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@457.35--457.51) [197648]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@457.55--457.83) [197649]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@457.55--457.83) [197650]"}
                0 < segLength(Heap, nextTemp, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          
          // -- Check definedness of 2 <= segLength(nextTemp, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@458.8--458.33) [197651]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          if (2 <= segLength(Heap, nextTemp, null)) {
            assume state(Heap, Mask);
            
            // -- Check definedness of segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@458.38--458.66) [197652]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@458.38--458.66) [197653]"}
                  0 < segLength(Heap, nextTemp, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@458.69--458.97) [197654]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@458.69--458.97) [197655]"}
                  1 < segLength(Heap, nextTemp, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && 0 < segLength(this.Nodes, prevTemp)
          if (prevTemp != null) {
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@459.13--461.93) [197656]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@459.37--459.68) [197657]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes_1], prevTemp)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@459.13--461.93) [197658]"}
              HasDirectPerm(Mask, this, Nodes_1);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@459.13--461.93) [197659]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@461.34--461.65) [197660]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@461.2--461.70) [197661]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, prevTemp) - 1 might not hold. (BinomialHeap.vpr@461.2--461.70) [197662]"}
                0 <= segLength(Heap, Heap[this, Nodes_1], prevTemp) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, prevTemp) - 1 < segLength(this.Nodes, prevTemp) might not hold. (BinomialHeap.vpr@461.2--461.70) [197663]"}
                segLength(Heap, Heap[this, Nodes_1], prevTemp) - 1 < segLength(Heap, Heap[this, Nodes_1], prevTemp);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@461.73--461.93) [197664]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, Heap[this, Nodes_1], prevTemp, segLength(Heap, Heap[this, Nodes_1], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        assume state(Heap, Mask);
        if (prevTemp != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@462.13--463.159) [197665]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@463.2--463.31) [197666]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@463.34--463.52) [197667]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@463.55--463.69) [197668]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@463.72--463.95) [197669]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@462.13--463.159) [197670]"}
              HasDirectPerm(oldMask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@463.103--463.128) [197671]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@463.136--463.158) [197672]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segSize(Heap, Heap[this, Nodes_1], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        assume state(Heap, Mask);
        if (prevTemp == null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@465.2--465.16) [197673]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@465.19--465.42) [197674]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@464.13--465.106) [197675]"}
              HasDirectPerm(oldMask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@465.50--465.75) [197676]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@465.83--465.105) [197677]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && this.Nodes != prevTemp
          if (prevTemp != null) {
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@466.13--466.115) [197678]"}
              HasDirectPerm(Mask, this, Nodes_1);
          }
        if (prevTemp != null && Heap[this, Nodes_1] != prevTemp) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, prevTemp) == treeParent(prevTemp)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@466.13--466.115) [197679]"}
              HasDirectPerm(Mask, this, Nodes_1);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@466.60--466.91) [197680]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != prevTemp might not hold. (BinomialHeap.vpr@466.60--466.91) [197681]"}
                Heap[this, Nodes_1] != prevTemp;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@466.95--466.115) [197682]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes_1], prevTemp) == treeParent(Heap, prevTemp);
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of treeParent(temp) == old(segParent(this.Nodes, null))
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@467.13--467.29) [197683]"}
              NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@467.13--467.65) [197684]"}
            HasDirectPerm(oldMask, this, Nodes_1);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@467.37--467.64) [197685]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes_1], null)];
            assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@467.37--467.64) [197686]"}
              oldHeap[this, Nodes_1] != null;
            // Finish exhale
            // Stop execution
            assume false;
          }
        assume treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        assume state(Heap, Mask);
        assume false;
      }
    
    // -- Check the loop body
      if (*) {
        // Reset state
        loopHeap := Heap;
        loopMask := Mask;
        Mask := ZeroMask;
        assume state(Heap, Mask);
        // Inhale invariant
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
        assume state(Heap, Mask);
        if (prevTemp != null) {
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[this, Nodes_1], prevTemp):=Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted_1(Heap, Heap[this, Nodes_1], prevTemp);
        }
        if (prevTemp == null) {
          assume Heap[this, Nodes_1] == temp_1;
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume presorted(Heap, nextTemp, null);
        perm := FullPerm;
        Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
        assume state(Heap, Mask);
        assume Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assume state(Heap, Mask);
          assume treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assume state(Heap, Mask);
          assume treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        if (prevTemp != null) {
          perm := FullPerm;
          Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          assume prevTemp != null;
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
          assume state(Heap, Mask);
          assume Heap[prevTemp, sibling] == temp_1;
          assume state(Heap, Mask);
          assume treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assume state(Heap, Mask);
          assume treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes_1], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assume state(Heap, Mask);
          assume treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assume state(Heap, Mask);
          assume 0 < segLength(Heap, nextTemp, null);
          assume state(Heap, Mask);
          assume treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          if (2 <= segLength(Heap, nextTemp, null)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes_1], prevTemp)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes_1], prevTemp, segLength(Heap, Heap[this, Nodes_1], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        if (prevTemp != null) {
          assume state(Heap, Mask);
          assume segSize(Heap, Heap[this, Nodes_1], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp == null) {
          assume state(Heap, Mask);
          assume treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp != null && Heap[this, Nodes_1] != prevTemp) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes_1], prevTemp) == treeParent(Heap, prevTemp);
        }
        assume state(Heap, Mask);
        assume treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        assume state(Heap, Mask);
        // Check and assume guard
        assume nextTemp != null;
        assume state(Heap, Mask);
        
        // -- Translate loop body
          
          // -- Translating statement: unfold acc(heapseg(nextTemp, null), write) -- BinomialHeap.vpr@469.3--469.33
            assume heapseg#trigger(Heap, heapseg(nextTemp, null));
            assume Heap[null, heapseg(nextTemp, null)] == FrameFragment((if nextTemp != null then CombineFrames(Heap[null, tree_1(nextTemp)], CombineFrames(FrameFragment(Heap[nextTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, sibling], null)], FrameFragment((if Heap[nextTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(nextTemp, null) might fail. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@469.3--469.33) [197687]"}
                perm <= Mask[null, heapseg(nextTemp, null)];
            }
            Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(nextTemp, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(nextTemp, null):=newVersion];
              }
            if (nextTemp != null) {
              perm := FullPerm;
              Mask := Mask[null, tree_1(nextTemp):=Mask[null, tree_1(nextTemp)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], tree_1(nextTemp), Heap[null, tree_1(nextTemp)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume nextTemp != null;
              Mask := Mask[nextTemp, sibling:=Mask[nextTemp, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[nextTemp, sibling], null):=Mask[null, heapseg(Heap[nextTemp, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], heapseg(Heap[nextTemp, sibling], null), Heap[null, heapseg(Heap[nextTemp, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[nextTemp, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, nextTemp) == segParent(Heap, Heap[nextTemp, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (treeDegree(temp) != treeDegree(nextTemp) || nextTemp.sibling != null && segDegree(nextTemp.sibling, null, 0) == treeDegree(temp)) -- BinomialHeap.vpr@470.3--512.4
            
            // -- Check definedness of treeDegree(temp) != treeDegree(nextTemp) || nextTemp.sibling != null && segDegree(nextTemp.sibling, null, 0) == treeDegree(temp)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@470.6--470.22) [197688]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@470.26--470.46) [197689]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree_1(nextTemp)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (!(treeDegree(Heap, temp_1) != treeDegree(Heap, nextTemp))) {
                assert {:msg "  Conditional statement might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@470.6--471.91) [197690]"}
                  HasDirectPerm(Mask, nextTemp, sibling);
                if (Heap[nextTemp, sibling] != null) {
                  assert {:msg "  Conditional statement might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@470.6--471.91) [197691]"}
                    HasDirectPerm(Mask, nextTemp, sibling);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp.sibling, null) (BinomialHeap.vpr@471.34--471.70) [197692]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[nextTemp, sibling], null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp.sibling, null) might not hold. (BinomialHeap.vpr@471.34--471.70) [197693]"}
                      0 < segLength(Heap, Heap[nextTemp, sibling], null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@471.74--471.90) [197694]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              }
            if (treeDegree(Heap, temp_1) != treeDegree(Heap, nextTemp) || (Heap[nextTemp, sibling] != null && segDegree(Heap, Heap[nextTemp, sibling], null, 0) == treeDegree(Heap, temp_1))) {
              
              // -- Translating statement: if (prevTemp == null) -- BinomialHeap.vpr@472.4--479.5
                if (prevTemp == null) {
                  
                  // -- Translating statement: fold acc(heapseg(this.Nodes, temp), write) -- BinomialHeap.vpr@474.5--474.35
                    
                    // -- Check definedness of acc(heapseg(this.Nodes, temp), write)
                      assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@474.5--474.35) [197695]"}
                        HasDirectPerm(Mask, this, Nodes_1);
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (Heap[this, Nodes_1] != temp_1) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@474.5--474.35) [197696]"}
                          perm <= Mask[null, tree_1(Heap[this, Nodes_1])];
                      }
                      Mask := Mask[null, tree_1(Heap[this, Nodes_1]):=Mask[null, tree_1(Heap[this, Nodes_1])] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp_1), Heap[null, heapseg(Heap[this, Nodes_1], temp_1)], tree_1(Heap[this, Nodes_1]), Heap[null, tree_1(Heap[this, Nodes_1])]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@474.5--474.35) [197697]"}
                          perm <= Mask[Heap[this, Nodes_1], sibling];
                      }
                      Mask := Mask[Heap[this, Nodes_1], sibling:=Mask[Heap[this, Nodes_1], sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp) (BinomialHeap.vpr@474.5--474.35) [197698]"}
                          perm <= Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp_1)];
                      }
                      Mask := Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp_1):=Mask[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[this, Nodes_1], temp_1), Heap[null, heapseg(Heap[this, Nodes_1], temp_1)], heapseg(Heap[Heap[this, Nodes_1], sibling], temp_1), Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp_1)]);
                      if (Heap[Heap[this, Nodes_1], sibling] != temp_1) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp) might not hold. (BinomialHeap.vpr@474.5--474.35) [197699]"}
                          treeParent(Heap, Heap[this, Nodes_1]) == segParent(Heap, Heap[Heap[this, Nodes_1], sibling], temp_1);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[this, Nodes_1], temp_1):=Mask[null, heapseg(Heap[this, Nodes_1], temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes_1], temp_1));
                    assume Heap[null, heapseg(Heap[this, Nodes_1], temp_1)] == FrameFragment((if Heap[this, Nodes_1] != temp_1 then CombineFrames(Heap[null, tree_1(Heap[this, Nodes_1])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes_1], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes_1], sibling], temp_1)], FrameFragment((if Heap[Heap[this, Nodes_1], sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes_1], temp_1))) {
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(Heap[this, Nodes_1], temp_1):=freshVersion];
                    }
                    if (Heap[this, Nodes_1] != temp_1) {
                      havoc newPMask;
                      assume (forall <A, B> o_158: Ref, f_167: (Field A B) ::
                        { newPMask[o_158, f_167] }
                        Heap[null, heapseg#sm(Heap[this, Nodes_1], temp_1)][o_158, f_167] || Heap[null, tree#sm(Heap[this, Nodes_1])][o_158, f_167] ==> newPMask[o_158, f_167]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp_1):=newPMask];
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp_1):=Heap[null, heapseg#sm(Heap[this, Nodes_1], temp_1)][Heap[this, Nodes_1], sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_120: Ref, f_168: (Field A B) ::
                        { newPMask[o_120, f_168] }
                        Heap[null, heapseg#sm(Heap[this, Nodes_1], temp_1)][o_120, f_168] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes_1], sibling], temp_1)][o_120, f_168] ==> newPMask[o_120, f_168]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes_1], temp_1):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: fold acc(heapseg(temp, temp), write) -- BinomialHeap.vpr@476.5--476.29
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (temp_1 != temp_1) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@476.5--476.29) [197700]"}
                          perm <= Mask[null, tree_1(temp_1)];
                      }
                      Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@476.5--476.29) [197701]"}
                          perm <= Mask[temp_1, sibling];
                      }
                      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access heapseg(temp.sibling, temp) (BinomialHeap.vpr@476.5--476.29) [197702]"}
                          perm <= Mask[null, heapseg(Heap[temp_1, sibling], temp_1)];
                      }
                      Mask := Mask[null, heapseg(Heap[temp_1, sibling], temp_1):=Mask[null, heapseg(Heap[temp_1, sibling], temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], heapseg(Heap[temp_1, sibling], temp_1), Heap[null, heapseg(Heap[temp_1, sibling], temp_1)]);
                      if (Heap[temp_1, sibling] != temp_1) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. Assertion treeParent(temp) == segParent(temp.sibling, temp) might not hold. (BinomialHeap.vpr@476.5--476.29) [197703]"}
                          treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], temp_1);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(temp_1, temp_1):=Mask[null, heapseg(temp_1, temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(temp_1, temp_1));
                    assume Heap[null, heapseg(temp_1, temp_1)] == FrameFragment((if temp_1 != temp_1 then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], temp_1)], FrameFragment((if Heap[temp_1, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(temp_1, temp_1))) {
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(temp_1, temp_1):=freshVersion];
                    }
                    if (temp_1 != temp_1) {
                      havoc newPMask;
                      assume (forall <A, B> o_159: Ref, f_137: (Field A B) ::
                        { newPMask[o_159, f_137] }
                        Heap[null, heapseg#sm(temp_1, temp_1)][o_159, f_137] || Heap[null, tree#sm(temp_1)][o_159, f_137] ==> newPMask[o_159, f_137]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=Heap[null, heapseg#sm(temp_1, temp_1)][temp_1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_160: Ref, f_169: (Field A B) ::
                        { newPMask[o_160, f_169] }
                        Heap[null, heapseg#sm(temp_1, temp_1)][o_160, f_169] || Heap[null, heapseg#sm(Heap[temp_1, sibling], temp_1)][o_160, f_169] ==> newPMask[o_160, f_169]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(prevTemp, temp), write) -- BinomialHeap.vpr@477.5--477.33
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (prevTemp != temp_1) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@477.5--477.33) [197704]"}
                          perm <= Mask[null, tree_1(prevTemp)];
                      }
                      Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], tree_1(prevTemp), Heap[null, tree_1(prevTemp)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@477.5--477.33) [197705]"}
                          perm <= Mask[prevTemp, sibling];
                      }
                      Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, temp) (BinomialHeap.vpr@477.5--477.33) [197706]"}
                          perm <= Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)];
                      }
                      Mask := Mask[null, heapseg(Heap[prevTemp, sibling], temp_1):=Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], heapseg(Heap[prevTemp, sibling], temp_1), Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)]);
                      if (Heap[prevTemp, sibling] != temp_1) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, temp) might not hold. (BinomialHeap.vpr@477.5--477.33) [197707]"}
                          treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], temp_1);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(prevTemp, temp_1));
                    assume Heap[null, heapseg(prevTemp, temp_1)] == FrameFragment((if prevTemp != temp_1 then CombineFrames(Heap[null, tree_1(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)], FrameFragment((if Heap[prevTemp, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(prevTemp, temp_1))) {
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(prevTemp, temp_1):=freshVersion];
                    }
                    if (prevTemp != temp_1) {
                      havoc newPMask;
                      assume (forall <A, B> o_121: Ref, f_170: (Field A B) ::
                        { newPMask[o_121, f_170] }
                        Heap[null, heapseg#sm(prevTemp, temp_1)][o_121, f_170] || Heap[null, tree#sm(prevTemp)][o_121, f_170] ==> newPMask[o_121, f_170]
                      );
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=Heap[null, heapseg#sm(prevTemp, temp_1)][prevTemp, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_161: Ref, f_171: (Field A B) ::
                        { newPMask[o_161, f_171] }
                        Heap[null, heapseg#sm(prevTemp, temp_1)][o_161, f_171] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], temp_1)][o_161, f_171] ==> newPMask[o_161, f_171]
                      );
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: concat(this.Nodes, prevTemp, temp) -- BinomialHeap.vpr@478.5--478.39
                    PreCallHeap := Heap;
                    PreCallMask := Mask;
                    
                    // -- Check definedness of this.Nodes
                      assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@478.5--478.39) [197708]"}
                        HasDirectPerm(Mask, this, Nodes_1);
                    arg_a := Heap[this, Nodes_1];
                    
                    // -- Exhaling precondition
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@478.5--478.39) [197709]"}
                          perm <= Mask[null, heapseg(arg_a, prevTemp)];
                      }
                      Mask := Mask[null, heapseg(arg_a, prevTemp):=Mask[null, heapseg(arg_a, prevTemp)] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, temp) (BinomialHeap.vpr@478.5--478.39) [197710]"}
                          perm <= Mask[null, heapseg(prevTemp, temp_1)];
                      }
                      Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] - perm];
                      if (temp_1 != null) {
                        perm := FullPerm;
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@478.5--478.39) [197711]"}
                            perm <= Mask[null, tree_1(temp_1)];
                        }
                        Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                      }
                      if (arg_a != prevTemp && prevTemp != temp_1) {
                        assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, prevTemp) == segParent(prevTemp, temp) might not hold. (BinomialHeap.vpr@478.5--478.39) [197712]"}
                          segParent(Heap, arg_a, prevTemp) == segParent(Heap, prevTemp, temp_1);
                      }
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                    
                    // -- Inhaling postcondition
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(arg_a, temp_1):=Mask[null, heapseg(arg_a, temp_1)] + perm];
                      assume state(Heap, Mask);
                      assume state(Heap, Mask);
                      assume segLength(Heap, arg_a, temp_1) == segLength(PreCallHeap, arg_a, prevTemp) + segLength(PreCallHeap, prevTemp, temp_1);
                      assume state(Heap, Mask);
                      assume (forall i: int ::
                        { segDegree#frame(Heap[null, heapseg(arg_a, temp_1)], arg_a, temp_1, i) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a, prevTemp)], arg_a, prevTemp, i) }
                        0 <= i && i < segLength(PreCallHeap, arg_a, prevTemp) ==> segDegree(Heap, arg_a, temp_1, i) == segDegree(PreCallHeap, arg_a, prevTemp, i)
                      );
                      assume state(Heap, Mask);
                      assume (forall i_1: int ::
                        { segDegree#frame(Heap[null, heapseg(arg_a, temp_1)], arg_a, temp_1, i_1) }
                        segLength(PreCallHeap, arg_a, prevTemp) <= i_1 && i_1 < segLength(Heap, arg_a, temp_1) ==> segDegree(Heap, arg_a, temp_1, i_1) == segDegree(PreCallHeap, prevTemp, temp_1, i_1 - segLength(PreCallHeap, arg_a, prevTemp))
                      );
                      if (temp_1 != null) {
                        perm := FullPerm;
                        Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume treeDegree(Heap, temp_1) == treeDegree(PreCallHeap, temp_1);
                        assume state(Heap, Mask);
                        assume treeSize(Heap, temp_1) == treeSize(PreCallHeap, temp_1);
                        assume state(Heap, Mask);
                        assume treeParent(Heap, temp_1) == treeParent(PreCallHeap, temp_1);
                      }
                      if (sorted_1(PreCallHeap, arg_a, prevTemp) && (sorted_1(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, arg_a, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))) {
                        assume state(Heap, Mask);
                        assume sorted_1(Heap, arg_a, temp_1);
                      }
                      if (presorted(PreCallHeap, arg_a, prevTemp) && (presorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, arg_a, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, temp_1, 0) && ((2 <= segLength(PreCallHeap, arg_a, prevTemp) && segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) == segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 2) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)) && (2 <= segLength(PreCallHeap, prevTemp, temp_1) && segDegree(PreCallHeap, prevTemp, temp_1, 0) == segDegree(PreCallHeap, prevTemp, temp_1, 1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))))) {
                        assume state(Heap, Mask);
                        assume presorted(Heap, arg_a, temp_1);
                      }
                      if (validChildren(PreCallHeap, arg_a, prevTemp) && (validChildren(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, arg_a, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, temp_1, 0) + 1))) {
                        assume state(Heap, Mask);
                        assume validChildren(Heap, arg_a, temp_1);
                      }
                      assume state(Heap, Mask);
                      assume segSize(Heap, arg_a, temp_1) == segSize(PreCallHeap, arg_a, prevTemp) + segSize(PreCallHeap, prevTemp, temp_1);
                      if (arg_a != prevTemp) {
                        assume state(Heap, Mask);
                        assume segParent(Heap, arg_a, temp_1) == segParent(PreCallHeap, arg_a, prevTemp);
                      }
                      if (prevTemp != temp_1) {
                        assume state(Heap, Mask);
                        assume segParent(Heap, arg_a, temp_1) == segParent(PreCallHeap, prevTemp, temp_1);
                      }
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
              
              // -- Translating statement: prevTemp := temp -- BinomialHeap.vpr@480.4--480.20
                prevTemp := temp_1;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp := nextTemp -- BinomialHeap.vpr@481.4--481.20
                temp_1 := nextTemp;
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: if (treeKey(temp) <= treeKey(nextTemp)) -- BinomialHeap.vpr@483.4--511.5
                
                // -- Check definedness of treeKey(temp) <= treeKey(nextTemp)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@483.7--483.20) [197713]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@483.24--483.41) [197714]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree_1(nextTemp)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                if (treeKey(Heap, temp_1) <= treeKey(Heap, nextTemp)) {
                  
                  // -- Translating statement: temp.sibling := nextTemp.sibling -- BinomialHeap.vpr@484.5--484.37
                    
                    // -- Check definedness of nextTemp.sibling
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@484.5--484.37) [197715]"}
                        HasDirectPerm(Mask, nextTemp, sibling);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@484.5--484.37) [197716]"}
                      FullPerm == Mask[temp_1, sibling];
                    Heap := Heap[temp_1, sibling:=Heap[nextTemp, sibling]];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(nextTemp), write) -- BinomialHeap.vpr@485.5--485.26
                    assume tree#trigger(Heap, tree_1(nextTemp));
                    assume Heap[null, tree_1(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key_6]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(nextTemp) might fail. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@485.5--485.26) [197717]"}
                        perm <= Mask[null, tree_1(nextTemp)];
                    }
                    Mask := Mask[null, tree_1(nextTemp):=Mask[null, tree_1(nextTemp)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree_1(nextTemp))) {
                        havoc newVersion;
                        Heap := Heap[null, tree_1(nextTemp):=newVersion];
                      }
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, key_6:=Mask[nextTemp, key_6] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree_1(nextTemp), Heap[null, tree_1(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.parent := temp -- BinomialHeap.vpr@486.5--486.28
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.parent (BinomialHeap.vpr@486.5--486.28) [197718]"}
                      FullPerm == Mask[nextTemp, parent];
                    Heap := Heap[nextTemp, parent:=temp_1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(nextTemp), write) -- BinomialHeap.vpr@487.5--487.24
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.key (BinomialHeap.vpr@487.5--487.24) [197719]"}
                        perm <= Mask[nextTemp, key_6];
                    }
                    Mask := Mask[nextTemp, key_6:=Mask[nextTemp, key_6] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@487.5--487.24) [197720]"}
                        perm <= Mask[nextTemp, degree];
                    }
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@487.5--487.24) [197721]"}
                        perm <= Mask[nextTemp, child];
                    }
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.parent (BinomialHeap.vpr@487.5--487.24) [197722]"}
                        perm <= Mask[nextTemp, parent];
                    }
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] - perm];
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion 0 <= nextTemp.degree might not hold. (BinomialHeap.vpr@487.5--487.24) [197723]"}
                      0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access heapseg(nextTemp.child, null) (BinomialHeap.vpr@487.5--487.24) [197724]"}
                        perm <= Mask[null, heapseg(Heap[nextTemp, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree_1(nextTemp), Heap[null, tree_1(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion nextTemp.degree == segLength(nextTemp.child, null) might not hold. (BinomialHeap.vpr@487.5--487.24) [197725]"}
                      Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segDegree(nextTemp.child, null, 0) == nextTemp.degree - 1 might not hold. (BinomialHeap.vpr@487.5--487.24) [197726]"}
                        segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion validChildren(nextTemp.child, null) might not hold. (BinomialHeap.vpr@487.5--487.24) [197727]"}
                      validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segParent(nextTemp.child, null) == nextTemp might not hold. (BinomialHeap.vpr@487.5--487.24) [197728]"}
                        segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(nextTemp):=Mask[null, tree_1(nextTemp)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree_1(nextTemp));
                    assume Heap[null, tree_1(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key_6]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree_1(nextTemp))) {
                      Heap := Heap[null, tree#sm(nextTemp):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree_1(nextTemp):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, key_6:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, degree:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, child:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_162: Ref, f_172: (Field A B) ::
                      { newPMask[o_162, f_172] }
                      Heap[null, tree#sm(nextTemp)][o_162, f_172] || Heap[null, heapseg#sm(Heap[nextTemp, child], null)][o_162, f_172] ==> newPMask[o_162, f_172]
                    );
                    Heap := Heap[null, tree#sm(nextTemp):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@488.5--488.22
                    assume tree#trigger(Heap, tree_1(temp_1));
                    assume Heap[null, tree_1(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key_6]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@488.5--488.22) [197729]"}
                        perm <= Mask[null, tree_1(temp_1)];
                    }
                    Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree_1(temp_1))) {
                        havoc newVersion;
                        Heap := Heap[null, tree_1(temp_1):=newVersion];
                      }
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, key_6:=Mask[temp_1, key_6] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree_1(temp_1), Heap[null, tree_1(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.sibling := temp.child -- BinomialHeap.vpr@489.5--489.35
                    
                    // -- Check definedness of temp.child
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@489.5--489.35) [197730]"}
                        HasDirectPerm(Mask, temp_1, child);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@489.5--489.35) [197731]"}
                      FullPerm == Mask[nextTemp, sibling];
                    Heap := Heap[nextTemp, sibling:=Heap[temp_1, child]];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.child := nextTemp -- BinomialHeap.vpr@490.5--490.27
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@490.5--490.27) [197732]"}
                      FullPerm == Mask[temp_1, child];
                    Heap := Heap[temp_1, child:=nextTemp];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.degree := temp.degree + 1 -- BinomialHeap.vpr@491.5--491.35
                    
                    // -- Check definedness of temp.degree + 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@491.5--491.35) [197733]"}
                        HasDirectPerm(Mask, temp_1, degree);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@491.5--491.35) [197734]"}
                      FullPerm == Mask[temp_1, degree];
                    Heap := Heap[temp_1, degree:=Heap[temp_1, degree] + 1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(temp.child, null), write) -- BinomialHeap.vpr@492.5--492.35
                    
                    // -- Check definedness of acc(heapseg(temp.child, null), write)
                      assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@492.5--492.35) [197735]"}
                        HasDirectPerm(Mask, temp_1, child);
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (Heap[temp_1, child] != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access tree(temp.child) (BinomialHeap.vpr@492.5--492.35) [197736]"}
                          perm <= Mask[null, tree_1(Heap[temp_1, child])];
                      }
                      Mask := Mask[null, tree_1(Heap[temp_1, child]):=Mask[null, tree_1(Heap[temp_1, child])] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)], tree_1(Heap[temp_1, child]), Heap[null, tree_1(Heap[temp_1, child])]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access temp.child.sibling (BinomialHeap.vpr@492.5--492.35) [197737]"}
                          perm <= Mask[Heap[temp_1, child], sibling];
                      }
                      Mask := Mask[Heap[temp_1, child], sibling:=Mask[Heap[temp_1, child], sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access heapseg(temp.child.sibling, null) (BinomialHeap.vpr@492.5--492.35) [197738]"}
                          perm <= Mask[null, heapseg(Heap[Heap[temp_1, child], sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[Heap[temp_1, child], sibling], null):=Mask[null, heapseg(Heap[Heap[temp_1, child], sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)], heapseg(Heap[Heap[temp_1, child], sibling], null), Heap[null, heapseg(Heap[Heap[temp_1, child], sibling], null)]);
                      if (Heap[Heap[temp_1, child], sibling] != null) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. Assertion treeParent(temp.child) == segParent(temp.child.sibling, null) might not hold. (BinomialHeap.vpr@492.5--492.35) [197739]"}
                          treeParent(Heap, Heap[temp_1, child]) == segParent(Heap, Heap[Heap[temp_1, child], sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(Heap[temp_1, child], null));
                    assume Heap[null, heapseg(Heap[temp_1, child], null)] == FrameFragment((if Heap[temp_1, child] != null then CombineFrames(Heap[null, tree_1(Heap[temp_1, child])], CombineFrames(FrameFragment(Heap[Heap[temp_1, child], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[temp_1, child], sibling], null)], FrameFragment((if Heap[Heap[temp_1, child], sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(Heap[temp_1, child], null))) {
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(Heap[temp_1, child], null):=freshVersion];
                    }
                    if (Heap[temp_1, child] != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_163: Ref, f_173: (Field A B) ::
                        { newPMask[o_163, f_173] }
                        Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_163, f_173] || Heap[null, tree#sm(Heap[temp_1, child])][o_163, f_173] ==> newPMask[o_163, f_173]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=newPMask];
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=Heap[null, heapseg#sm(Heap[temp_1, child], null)][Heap[temp_1, child], sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_164: Ref, f_174: (Field A B) ::
                        { newPMask[o_164, f_174] }
                        Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_164, f_174] || Heap[null, heapseg#sm(Heap[Heap[temp_1, child], sibling], null)][o_164, f_174] ==> newPMask[o_164, f_174]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(temp), write) -- BinomialHeap.vpr@493.5--493.20
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.key (BinomialHeap.vpr@493.5--493.20) [197740]"}
                        perm <= Mask[temp_1, key_6];
                    }
                    Mask := Mask[temp_1, key_6:=Mask[temp_1, key_6] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@493.5--493.20) [197741]"}
                        perm <= Mask[temp_1, degree];
                    }
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@493.5--493.20) [197742]"}
                        perm <= Mask[temp_1, child];
                    }
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@493.5--493.20) [197743]"}
                        perm <= Mask[temp_1, parent];
                    }
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] - perm];
                    assert {:msg "  Folding tree(temp) might fail. Assertion 0 <= temp.degree might not hold. (BinomialHeap.vpr@493.5--493.20) [197744]"}
                      0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access heapseg(temp.child, null) (BinomialHeap.vpr@493.5--493.20) [197745]"}
                        perm <= Mask[null, heapseg(Heap[temp_1, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree_1(temp_1), Heap[null, tree_1(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assert {:msg "  Folding tree(temp) might fail. Assertion temp.degree == segLength(temp.child, null) might not hold. (BinomialHeap.vpr@493.5--493.20) [197746]"}
                      Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segDegree(temp.child, null, 0) == temp.degree - 1 might not hold. (BinomialHeap.vpr@493.5--493.20) [197747]"}
                        segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assert {:msg "  Folding tree(temp) might fail. Assertion validChildren(temp.child, null) might not hold. (BinomialHeap.vpr@493.5--493.20) [197748]"}
                      validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segParent(temp.child, null) == temp might not hold. (BinomialHeap.vpr@493.5--493.20) [197749]"}
                        segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree_1(temp_1));
                    assume Heap[null, tree_1(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key_6]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree_1(temp_1))) {
                      Heap := Heap[null, tree#sm(temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree_1(temp_1):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, key_6:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, child:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_165: Ref, f_175: (Field A B) ::
                      { newPMask[o_165, f_175] }
                      Heap[null, tree#sm(temp_1)][o_165, f_175] || Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_165, f_175] ==> newPMask[o_165, f_175]
                    );
                    Heap := Heap[null, tree#sm(temp_1):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: if (prevTemp == null) -- BinomialHeap.vpr@495.5--499.6
                    if (prevTemp == null) {
                      
                      // -- Translating statement: this.Nodes := nextTemp -- BinomialHeap.vpr@496.6--496.28
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@496.6--496.28) [197750]"}
                          FullPerm == Mask[this, Nodes_1];
                        Heap := Heap[this, Nodes_1:=nextTemp];
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: prevTemp.sibling := nextTemp -- BinomialHeap.vpr@498.6--498.34
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@498.6--498.34) [197751]"}
                          FullPerm == Mask[prevTemp, sibling];
                        Heap := Heap[prevTemp, sibling:=nextTemp];
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@500.5--500.22
                    assume tree#trigger(Heap, tree_1(temp_1));
                    assume Heap[null, tree_1(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key_6]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@500.5--500.22) [197752]"}
                        perm <= Mask[null, tree_1(temp_1)];
                    }
                    Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree_1(temp_1))) {
                        havoc newVersion;
                        Heap := Heap[null, tree_1(temp_1):=newVersion];
                      }
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, key_6:=Mask[temp_1, key_6] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree_1(temp_1), Heap[null, tree_1(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.parent := nextTemp -- BinomialHeap.vpr@501.5--501.28
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@501.5--501.28) [197753]"}
                      FullPerm == Mask[temp_1, parent];
                    Heap := Heap[temp_1, parent:=nextTemp];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(temp), write) -- BinomialHeap.vpr@502.5--502.20
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.key (BinomialHeap.vpr@502.5--502.20) [197754]"}
                        perm <= Mask[temp_1, key_6];
                    }
                    Mask := Mask[temp_1, key_6:=Mask[temp_1, key_6] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@502.5--502.20) [197755]"}
                        perm <= Mask[temp_1, degree];
                    }
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@502.5--502.20) [197756]"}
                        perm <= Mask[temp_1, child];
                    }
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@502.5--502.20) [197757]"}
                        perm <= Mask[temp_1, parent];
                    }
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] - perm];
                    assert {:msg "  Folding tree(temp) might fail. Assertion 0 <= temp.degree might not hold. (BinomialHeap.vpr@502.5--502.20) [197758]"}
                      0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access heapseg(temp.child, null) (BinomialHeap.vpr@502.5--502.20) [197759]"}
                        perm <= Mask[null, heapseg(Heap[temp_1, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree_1(temp_1), Heap[null, tree_1(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assert {:msg "  Folding tree(temp) might fail. Assertion temp.degree == segLength(temp.child, null) might not hold. (BinomialHeap.vpr@502.5--502.20) [197760]"}
                      Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segDegree(temp.child, null, 0) == temp.degree - 1 might not hold. (BinomialHeap.vpr@502.5--502.20) [197761]"}
                        segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assert {:msg "  Folding tree(temp) might fail. Assertion validChildren(temp.child, null) might not hold. (BinomialHeap.vpr@502.5--502.20) [197762]"}
                      validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segParent(temp.child, null) == temp might not hold. (BinomialHeap.vpr@502.5--502.20) [197763]"}
                        segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree_1(temp_1));
                    assume Heap[null, tree_1(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key_6]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree_1(temp_1))) {
                      Heap := Heap[null, tree#sm(temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree_1(temp_1):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, key_6:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, child:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_166: Ref, f_176: (Field A B) ::
                      { newPMask[o_166, f_176] }
                      Heap[null, tree#sm(temp_1)][o_166, f_176] || Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_166, f_176] ==> newPMask[o_166, f_176]
                    );
                    Heap := Heap[null, tree#sm(temp_1):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(nextTemp), write) -- BinomialHeap.vpr@503.5--503.26
                    assume tree#trigger(Heap, tree_1(nextTemp));
                    assume Heap[null, tree_1(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key_6]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(nextTemp) might fail. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@503.5--503.26) [197764]"}
                        perm <= Mask[null, tree_1(nextTemp)];
                    }
                    Mask := Mask[null, tree_1(nextTemp):=Mask[null, tree_1(nextTemp)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree_1(nextTemp))) {
                        havoc newVersion;
                        Heap := Heap[null, tree_1(nextTemp):=newVersion];
                      }
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, key_6:=Mask[nextTemp, key_6] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree_1(nextTemp), Heap[null, tree_1(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.sibling := nextTemp.child -- BinomialHeap.vpr@504.5--504.35
                    
                    // -- Check definedness of nextTemp.child
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@504.5--504.35) [197765]"}
                        HasDirectPerm(Mask, nextTemp, child);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@504.5--504.35) [197766]"}
                      FullPerm == Mask[temp_1, sibling];
                    Heap := Heap[temp_1, sibling:=Heap[nextTemp, child]];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@505.5--505.29
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (temp_1 != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@505.5--505.29) [197767]"}
                          perm <= Mask[null, tree_1(temp_1)];
                      }
                      Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@505.5--505.29) [197768]"}
                          perm <= Mask[temp_1, sibling];
                      }
                      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp.sibling, null) (BinomialHeap.vpr@505.5--505.29) [197769]"}
                          perm <= Mask[null, heapseg(Heap[temp_1, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                      if (Heap[temp_1, sibling] != null) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. Assertion treeParent(temp) == segParent(temp.sibling, null) might not hold. (BinomialHeap.vpr@505.5--505.29) [197770]"}
                          treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(temp_1, null));
                    assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                      Heap := Heap[null, heapseg#sm(temp_1, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(temp_1, null):=freshVersion];
                    }
                    if (temp_1 != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_167: Ref, f_177: (Field A B) ::
                        { newPMask[o_167, f_177] }
                        Heap[null, heapseg#sm(temp_1, null)][o_167, f_177] || Heap[null, tree#sm(temp_1)][o_167, f_177] ==> newPMask[o_167, f_177]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp_1, null):=Heap[null, heapseg#sm(temp_1, null)][temp_1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_168: Ref, f_178: (Field A B) ::
                        { newPMask[o_168, f_178] }
                        Heap[null, heapseg#sm(temp_1, null)][o_168, f_178] || Heap[null, heapseg#sm(Heap[temp_1, sibling], null)][o_168, f_178] ==> newPMask[o_168, f_178]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.child := temp -- BinomialHeap.vpr@506.5--506.27
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@506.5--506.27) [197771]"}
                      FullPerm == Mask[nextTemp, child];
                    Heap := Heap[nextTemp, child:=temp_1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.degree := nextTemp.degree + 1 -- BinomialHeap.vpr@507.5--507.43
                    
                    // -- Check definedness of nextTemp.degree + 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@507.5--507.43) [197772]"}
                        HasDirectPerm(Mask, nextTemp, degree);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@507.5--507.43) [197773]"}
                      FullPerm == Mask[nextTemp, degree];
                    Heap := Heap[nextTemp, degree:=Heap[nextTemp, degree] + 1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(nextTemp), write) -- BinomialHeap.vpr@508.5--508.24
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.key (BinomialHeap.vpr@508.5--508.24) [197774]"}
                        perm <= Mask[nextTemp, key_6];
                    }
                    Mask := Mask[nextTemp, key_6:=Mask[nextTemp, key_6] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@508.5--508.24) [197775]"}
                        perm <= Mask[nextTemp, degree];
                    }
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@508.5--508.24) [197776]"}
                        perm <= Mask[nextTemp, child];
                    }
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.parent (BinomialHeap.vpr@508.5--508.24) [197777]"}
                        perm <= Mask[nextTemp, parent];
                    }
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] - perm];
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion 0 <= nextTemp.degree might not hold. (BinomialHeap.vpr@508.5--508.24) [197778]"}
                      0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access heapseg(nextTemp.child, null) (BinomialHeap.vpr@508.5--508.24) [197779]"}
                        perm <= Mask[null, heapseg(Heap[nextTemp, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree_1(nextTemp), Heap[null, tree_1(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion nextTemp.degree == segLength(nextTemp.child, null) might not hold. (BinomialHeap.vpr@508.5--508.24) [197780]"}
                      Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segDegree(nextTemp.child, null, 0) == nextTemp.degree - 1 might not hold. (BinomialHeap.vpr@508.5--508.24) [197781]"}
                        segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion validChildren(nextTemp.child, null) might not hold. (BinomialHeap.vpr@508.5--508.24) [197782]"}
                      validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segParent(nextTemp.child, null) == nextTemp might not hold. (BinomialHeap.vpr@508.5--508.24) [197783]"}
                        segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(nextTemp):=Mask[null, tree_1(nextTemp)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree_1(nextTemp));
                    assume Heap[null, tree_1(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key_6]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree_1(nextTemp))) {
                      Heap := Heap[null, tree#sm(nextTemp):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree_1(nextTemp):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, key_6:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, degree:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, child:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_169: Ref, f_179: (Field A B) ::
                      { newPMask[o_169, f_179] }
                      Heap[null, tree#sm(nextTemp)][o_169, f_179] || Heap[null, heapseg#sm(Heap[nextTemp, child], null)][o_169, f_179] ==> newPMask[o_169, f_179]
                    );
                    Heap := Heap[null, tree#sm(nextTemp):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp := nextTemp -- BinomialHeap.vpr@510.5--510.21
                    temp_1 := nextTemp;
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
          
          // -- Translating statement: nextTemp := temp.sibling -- BinomialHeap.vpr@514.3--514.27
            
            // -- Check definedness of temp.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@514.3--514.27) [197784]"}
                HasDirectPerm(Mask, temp_1, sibling);
            nextTemp := Heap[temp_1, sibling];
            assume state(Heap, Mask);
        // Exhale invariant
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) might not be preserved. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@441.13--441.28) [197785]"}
            perm <= Mask[this, Nodes_1];
        }
        Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not be preserved. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@442.13--442.95) [197786]"}
              perm <= Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)];
          }
          Mask := Mask[null, heapseg(Heap[this, Nodes_1], prevTemp):=Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not be preserved. Assertion sorted(this.Nodes, prevTemp) might not hold. (BinomialHeap.vpr@442.13--442.95) [197787]"}
            sorted_1(Heap, Heap[this, Nodes_1], prevTemp);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> this.Nodes == temp might not be preserved. Assertion this.Nodes == temp might not hold. (BinomialHeap.vpr@443.13--443.52) [197788]"}
            Heap[this, Nodes_1] == temp_1;
        }
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not be preserved. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@444.13--444.65) [197789]"}
            perm <= Mask[null, heapseg(nextTemp, null)];
        }
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not be preserved. Assertion presorted(nextTemp, null) might not hold. (BinomialHeap.vpr@444.13--444.65) [197790]"}
          presorted(Heap, nextTemp, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@445.13--447.48) [197791]"}
            perm <= Mask[null, tree_1(temp_1)];
        }
        Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@445.13--447.48) [197792]"}
            perm <= Mask[temp_1, sibling];
        }
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
        assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. Assertion temp.sibling == nextTemp might not hold. (BinomialHeap.vpr@445.13--447.48) [197793]"}
          Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. Assertion treeDegree(temp) <= segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@445.13--447.48) [197794]"}
            treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. Assertion treeParent(temp) == segParent(nextTemp, null) might not hold. (BinomialHeap.vpr@445.13--447.48) [197795]"}
            treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@448.13--450.42) [197796]"}
              perm <= Mask[null, tree_1(prevTemp)];
          }
          Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@448.13--450.42) [197797]"}
              perm <= Mask[prevTemp, sibling];
          }
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@448.13--450.42) [197798]"}
            Heap[prevTemp, sibling] == temp_1;
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. Assertion treeDegree(prevTemp) <= treeDegree(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [197799]"}
            treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. Assertion treeParent(prevTemp) == treeParent(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [197800]"}
            treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes_1], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assert {:msg "  Loop invariant prevTemp != null && (0 < segLength(this.Nodes, prevTemp) && (2 <= segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && segDegree(nextTemp, null, 0) == segDegree(nextTemp, null, 1)))) ==> treeDegree(prevTemp) < treeDegree(temp) might not be preserved. Assertion treeDegree(prevTemp) < treeDegree(temp) might not hold. (BinomialHeap.vpr@451.13--454.41) [197801]"}
            treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not be preserved. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@455.13--458.98) [197802]"}
            0 < segLength(Heap, nextTemp, null);
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not be preserved. Assertion treeDegree(temp) == segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@455.13--458.98) [197803]"}
            treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          if (2 <= segLength(Heap, nextTemp, null)) {
            assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not be preserved. Assertion segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1) might not hold. (BinomialHeap.vpr@455.13--458.98) [197804]"}
              segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes_1], prevTemp)) {
          assert {:msg "  Loop invariant prevTemp != null && 0 < segLength(this.Nodes, prevTemp) ==> segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not be preserved. Assertion segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@459.13--461.93) [197805]"}
            segDegree(Heap, Heap[this, Nodes_1], prevTemp, segLength(Heap, Heap[this, Nodes_1], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        if (prevTemp != null) {
          assert {:msg "  Loop invariant prevTemp != null ==> segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@462.13--463.159) [197806]"}
            segSize(Heap, Heap[this, Nodes_1], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@464.13--465.106) [197807]"}
            treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp != null && Heap[this, Nodes_1] != prevTemp) {
          assert {:msg "  Loop invariant prevTemp != null && this.Nodes != prevTemp ==> segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not be preserved. Assertion segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not hold. (BinomialHeap.vpr@466.13--466.115) [197808]"}
            segParent(Heap, Heap[this, Nodes_1], prevTemp) == treeParent(Heap, prevTemp);
        }
        assert {:msg "  Loop invariant treeParent(temp) == old(segParent(this.Nodes, null)) might not be preserved. Assertion treeParent(temp) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@467.13--467.65) [197809]"}
          treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Terminate execution
        assume false;
      }
    
    // -- Inhale loop invariant after loop, and assume guard
      assume !(nextTemp != null);
      assume state(Heap, Mask);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
      assume state(Heap, Mask);
      if (prevTemp != null) {
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes_1], prevTemp):=Mask[null, heapseg(Heap[this, Nodes_1], prevTemp)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted_1(Heap, Heap[this, Nodes_1], prevTemp);
      }
      if (prevTemp == null) {
        assume Heap[this, Nodes_1] == temp_1;
      }
      perm := FullPerm;
      Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume presorted(Heap, nextTemp, null);
      perm := FullPerm;
      Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      assume temp_1 != null;
      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
      assume state(Heap, Mask);
      assume Heap[temp_1, sibling] == nextTemp;
      if (nextTemp != null) {
        assume state(Heap, Mask);
        assume treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
        assume state(Heap, Mask);
        assume treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
      }
      if (prevTemp != null) {
        perm := FullPerm;
        Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume prevTemp != null;
        Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
        assume state(Heap, Mask);
        assume Heap[prevTemp, sibling] == temp_1;
        assume state(Heap, Mask);
        assume treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
        assume state(Heap, Mask);
        assume treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
      }
      if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes_1], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
        assume state(Heap, Mask);
        assume treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
      }
      if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
        assume state(Heap, Mask);
        assume 0 < segLength(Heap, nextTemp, null);
        assume state(Heap, Mask);
        assume treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
        if (2 <= segLength(Heap, nextTemp, null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
        }
      }
      if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes_1], prevTemp)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes_1], prevTemp, segLength(Heap, Heap[this, Nodes_1], prevTemp) - 1) < treeDegree(Heap, prevTemp);
      }
      if (prevTemp != null) {
        assume state(Heap, Mask);
        assume segSize(Heap, Heap[this, Nodes_1], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
      }
      if (prevTemp == null) {
        assume state(Heap, Mask);
        assume treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
      }
      if (prevTemp != null && Heap[this, Nodes_1] != prevTemp) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes_1], prevTemp) == treeParent(Heap, prevTemp);
      }
      assume state(Heap, Mask);
      assume treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(nextTemp, null), write) -- BinomialHeap.vpr@516.2--516.30
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (nextTemp != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@516.2--516.30) [197812]"}
          perm <= Mask[null, tree_1(nextTemp)];
      }
      Mask := Mask[null, tree_1(nextTemp):=Mask[null, tree_1(nextTemp)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], tree_1(nextTemp), Heap[null, tree_1(nextTemp)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@516.2--516.30) [197814]"}
          perm <= Mask[nextTemp, sibling];
      }
      Mask := Mask[nextTemp, sibling:=Mask[nextTemp, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. There might be insufficient permission to access heapseg(nextTemp.sibling, null) (BinomialHeap.vpr@516.2--516.30) [197816]"}
          perm <= Mask[null, heapseg(Heap[nextTemp, sibling], null)];
      }
      Mask := Mask[null, heapseg(Heap[nextTemp, sibling], null):=Mask[null, heapseg(Heap[nextTemp, sibling], null)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], heapseg(Heap[nextTemp, sibling], null), Heap[null, heapseg(Heap[nextTemp, sibling], null)]);
      if (Heap[nextTemp, sibling] != null) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. Assertion treeParent(nextTemp) == segParent(nextTemp.sibling, null) might not hold. (BinomialHeap.vpr@516.2--516.30) [197817]"}
          treeParent(Heap, nextTemp) == segParent(Heap, Heap[nextTemp, sibling], null);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(nextTemp, null));
    assume Heap[null, heapseg(nextTemp, null)] == FrameFragment((if nextTemp != null then CombineFrames(Heap[null, tree_1(nextTemp)], CombineFrames(FrameFragment(Heap[nextTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, sibling], null)], FrameFragment((if Heap[nextTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(nextTemp, null))) {
      Heap := Heap[null, heapseg#sm(nextTemp, null):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(nextTemp, null):=freshVersion];
    }
    if (nextTemp != null) {
      havoc newPMask;
      assume (forall <A, B> o_170: Ref, f_180: (Field A B) ::
        { newPMask[o_170, f_180] }
        Heap[null, heapseg#sm(nextTemp, null)][o_170, f_180] || Heap[null, tree#sm(nextTemp)][o_170, f_180] ==> newPMask[o_170, f_180]
      );
      Heap := Heap[null, heapseg#sm(nextTemp, null):=newPMask];
      Heap := Heap[null, heapseg#sm(nextTemp, null):=Heap[null, heapseg#sm(nextTemp, null)][nextTemp, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_171: Ref, f_181: (Field A B) ::
        { newPMask[o_171, f_181] }
        Heap[null, heapseg#sm(nextTemp, null)][o_171, f_181] || Heap[null, heapseg#sm(Heap[nextTemp, sibling], null)][o_171, f_181] ==> newPMask[o_171, f_181]
      );
      Heap := Heap[null, heapseg#sm(nextTemp, null):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@517.2--517.26
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (temp_1 != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@517.2--517.26) [197821]"}
          perm <= Mask[null, tree_1(temp_1)];
      }
      Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@517.2--517.26) [197823]"}
          perm <= Mask[temp_1, sibling];
      }
      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp.sibling, null) (BinomialHeap.vpr@517.2--517.26) [197825]"}
          perm <= Mask[null, heapseg(Heap[temp_1, sibling], null)];
      }
      Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
      if (Heap[temp_1, sibling] != null) {
        assert {:msg "  Folding heapseg(temp, null) might fail. Assertion treeParent(temp) == segParent(temp.sibling, null) might not hold. (BinomialHeap.vpr@517.2--517.26) [197826]"}
          treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(temp_1, null));
    assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
      Heap := Heap[null, heapseg#sm(temp_1, null):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(temp_1, null):=freshVersion];
    }
    if (temp_1 != null) {
      havoc newPMask;
      assume (forall <A, B> o_172: Ref, f_182: (Field A B) ::
        { newPMask[o_172, f_182] }
        Heap[null, heapseg#sm(temp_1, null)][o_172, f_182] || Heap[null, tree#sm(temp_1)][o_172, f_182] ==> newPMask[o_172, f_182]
      );
      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
      Heap := Heap[null, heapseg#sm(temp_1, null):=Heap[null, heapseg#sm(temp_1, null)][temp_1, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_173: Ref, f_183: (Field A B) ::
        { newPMask[o_173, f_183] }
        Heap[null, heapseg#sm(temp_1, null)][o_173, f_183] || Heap[null, heapseg#sm(Heap[temp_1, sibling], null)][o_173, f_183] ==> newPMask[o_173, f_183]
      );
      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(prevTemp, null), write) -- BinomialHeap.vpr@518.2--518.30
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (prevTemp != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@518.2--518.30) [197830]"}
          perm <= Mask[null, tree_1(prevTemp)];
      }
      Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], tree_1(prevTemp), Heap[null, tree_1(prevTemp)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@518.2--518.30) [197832]"}
          perm <= Mask[prevTemp, sibling];
      }
      Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, null) (BinomialHeap.vpr@518.2--518.30) [197834]"}
          perm <= Mask[null, heapseg(Heap[prevTemp, sibling], null)];
      }
      Mask := Mask[null, heapseg(Heap[prevTemp, sibling], null):=Mask[null, heapseg(Heap[prevTemp, sibling], null)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], heapseg(Heap[prevTemp, sibling], null), Heap[null, heapseg(Heap[prevTemp, sibling], null)]);
      if (Heap[prevTemp, sibling] != null) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, null) might not hold. (BinomialHeap.vpr@518.2--518.30) [197835]"}
          treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], null);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(prevTemp, null));
    assume Heap[null, heapseg(prevTemp, null)] == FrameFragment((if prevTemp != null then CombineFrames(Heap[null, tree_1(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], null)], FrameFragment((if Heap[prevTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(prevTemp, null))) {
      Heap := Heap[null, heapseg#sm(prevTemp, null):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(prevTemp, null):=freshVersion];
    }
    if (prevTemp != null) {
      havoc newPMask;
      assume (forall <A, B> o_174: Ref, f_184: (Field A B) ::
        { newPMask[o_174, f_184] }
        Heap[null, heapseg#sm(prevTemp, null)][o_174, f_184] || Heap[null, tree#sm(prevTemp)][o_174, f_184] ==> newPMask[o_174, f_184]
      );
      Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
      Heap := Heap[null, heapseg#sm(prevTemp, null):=Heap[null, heapseg#sm(prevTemp, null)][prevTemp, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_175: Ref, f_185: (Field A B) ::
        { newPMask[o_175, f_185] }
        Heap[null, heapseg#sm(prevTemp, null)][o_175, f_185] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], null)][o_175, f_185] ==> newPMask[o_175, f_185]
      );
      Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: concat(this.Nodes, prevTemp, null) -- BinomialHeap.vpr@519.2--519.36
    PreCallHeap := Heap;
    PreCallMask := Mask;
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@519.2--519.36) [197837]"}
        HasDirectPerm(Mask, this, Nodes_1);
    arg_a_1 := Heap[this, Nodes_1];
    
    // -- Exhaling precondition
      ExhaleWellDef0Heap := Heap;
      ExhaleWellDef0Mask := Mask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@519.2--519.36) [197838]"}
          perm <= Mask[null, heapseg(arg_a_1, prevTemp)];
      }
      Mask := Mask[null, heapseg(arg_a_1, prevTemp):=Mask[null, heapseg(arg_a_1, prevTemp)] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, null) (BinomialHeap.vpr@519.2--519.36) [197839]"}
          perm <= Mask[null, heapseg(prevTemp, null)];
      }
      Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] - perm];
      if (null != null) {
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@519.2--519.36) [197840]"}
            perm <= Mask[null, tree_1(null)];
        }
        Mask := Mask[null, tree_1(null):=Mask[null, tree_1(null)] - perm];
      }
      if (arg_a_1 != prevTemp && prevTemp != null) {
        assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, prevTemp) == segParent(prevTemp, null) might not hold. (BinomialHeap.vpr@519.2--519.36) [197841]"}
          segParent(Heap, arg_a_1, prevTemp) == segParent(Heap, prevTemp, null);
      }
      // Finish exhale
      havoc ExhaleHeap;
      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
      Heap := ExhaleHeap;
    
    // -- Inhaling postcondition
      perm := FullPerm;
      Mask := Mask[null, heapseg(arg_a_1, null):=Mask[null, heapseg(arg_a_1, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume segLength(Heap, arg_a_1, null) == segLength(PreCallHeap, arg_a_1, prevTemp) + segLength(PreCallHeap, prevTemp, null);
      assume state(Heap, Mask);
      assume (forall i_2: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_1, null)], arg_a_1, null, i_2) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_1, prevTemp)], arg_a_1, prevTemp, i_2) }
        0 <= i_2 && i_2 < segLength(PreCallHeap, arg_a_1, prevTemp) ==> segDegree(Heap, arg_a_1, null, i_2) == segDegree(PreCallHeap, arg_a_1, prevTemp, i_2)
      );
      assume state(Heap, Mask);
      assume (forall i_3_2: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_1, null)], arg_a_1, null, i_3_2) }
        segLength(PreCallHeap, arg_a_1, prevTemp) <= i_3_2 && i_3_2 < segLength(Heap, arg_a_1, null) ==> segDegree(Heap, arg_a_1, null, i_3_2) == segDegree(PreCallHeap, prevTemp, null, i_3_2 - segLength(PreCallHeap, arg_a_1, prevTemp))
      );
      if (null != null) {
        perm := FullPerm;
        Mask := Mask[null, tree_1(null):=Mask[null, tree_1(null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume treeDegree(Heap, null) == treeDegree(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeSize(Heap, null) == treeSize(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeParent(Heap, null) == treeParent(PreCallHeap, null);
      }
      if (sorted_1(PreCallHeap, arg_a_1, prevTemp) && (sorted_1(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, arg_a_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))) {
        assume state(Heap, Mask);
        assume sorted_1(Heap, arg_a_1, null);
      }
      if (presorted(PreCallHeap, arg_a_1, prevTemp) && (presorted(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, arg_a_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, null, 0) && ((2 <= segLength(PreCallHeap, arg_a_1, prevTemp) && segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) == segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 2) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)) && (2 <= segLength(PreCallHeap, prevTemp, null) && segDegree(PreCallHeap, prevTemp, null, 0) == segDegree(PreCallHeap, prevTemp, null, 1) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))))) {
        assume state(Heap, Mask);
        assume presorted(Heap, arg_a_1, null);
      }
      if (validChildren(PreCallHeap, arg_a_1, prevTemp) && (validChildren(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, arg_a_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, null, 0) + 1))) {
        assume state(Heap, Mask);
        assume validChildren(Heap, arg_a_1, null);
      }
      assume state(Heap, Mask);
      assume segSize(Heap, arg_a_1, null) == segSize(PreCallHeap, arg_a_1, prevTemp) + segSize(PreCallHeap, prevTemp, null);
      if (arg_a_1 != prevTemp) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_1, null) == segParent(PreCallHeap, arg_a_1, prevTemp);
      }
      if (prevTemp != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_1, null) == segParent(PreCallHeap, prevTemp, null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of unionNodes might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@424.10--425.54) [197842]"}
        perm <= Mask[this, Nodes_1];
    }
    Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of unionNodes might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@424.10--425.54) [197843]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes_1], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] - perm];
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@424.10--425.54) [197844]"}
      sorted_1(Heap, Heap[this, Nodes_1], null);
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@426.10--426.28) [197845]"}
      Heap[this, Nodes_1] != null;
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@427.10--427.99) [197846]"}
      segSize(Heap, Heap[this, Nodes_1], null) == segSize(oldHeap, oldHeap[this, Nodes_1], null) + segSize(oldHeap, binHeap, null);
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion segParent(this.Nodes, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@428.10--428.73) [197847]"}
      segParent(Heap, Heap[this, Nodes_1], null) == segParent(oldHeap, oldHeap[this, Nodes_1], null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method extractMin
// ==================================================

procedure extractMin(this: Ref) returns (res: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var nodes: Ref;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newVersion: FrameType;
  var temp_1: Ref;
  var prevTemp: Ref;
  var minNode: Ref;
  var fakeNode: Ref;
  var r_1: Ref;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var oldTreeSize: int;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    PostMask := PostMask[null, heap_1(this):=PostMask[null, heap_1(this)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[nodes, $allocated];
  
  // -- Translating statement: unfold acc(heap(this), write) -- BinomialHeap.vpr@532.2--532.19
    assume heap#trigger(Heap, heap_1(this));
    assume Heap[null, heap_1(this)] == CombineFrames(FrameFragment(Heap[this, Nodes_1]), CombineFrames(Heap[null, heapseg(Heap[this, Nodes_1], null)], CombineFrames(FrameFragment((if Heap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(Heap[this, size_3]))));
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Unfolding heap(this) might fail. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@532.2--532.19) [197850]"}
        perm <= Mask[null, heap_1(this)];
    }
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] - perm];
    
    // -- Update version of predicate
      if (!HasDirectPerm(Mask, null, heap_1(this))) {
        havoc newVersion;
        Heap := Heap[null, heap_1(this):=newVersion];
      }
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] + perm];
    
    // -- Extra unfolding of predicate
      assume InsidePredicate(heap_1(this), Heap[null, heap_1(this)], heapseg(Heap[this, Nodes_1], null), Heap[null, heapseg(Heap[this, Nodes_1], null)]);
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume sorted_1(Heap, Heap[this, Nodes_1], null);
    if (Heap[this, Nodes_1] != null) {
      assume state(Heap, Mask);
      assume segParent(Heap, Heap[this, Nodes_1], null) == null;
    }
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, size_3:=Mask[this, size_3] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume Heap[this, size_3] == segSize(Heap, Heap[this, Nodes_1], null);
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: nodes := this.Nodes -- BinomialHeap.vpr@533.2--533.30
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@533.2--533.30) [197854]"}
        HasDirectPerm(Mask, this, Nodes_1);
    nodes := Heap[this, Nodes_1];
    assume state(Heap, Mask);
  
  // -- Translating statement: if (nodes == null) -- BinomialHeap.vpr@534.2--639.3
    if (nodes == null) {
      
      // -- Translating statement: res := null -- BinomialHeap.vpr@535.3--535.14
        res := null;
        assume state(Heap, Mask);
    } else {
      
      // -- Assumptions about local variables
        assume Heap[temp_1, $allocated];
        assume Heap[prevTemp, $allocated];
        assume Heap[minNode, $allocated];
        assume Heap[fakeNode, $allocated];
        assume Heap[r_1, $allocated];
      
      // -- Translating statement: temp := nodes -- BinomialHeap.vpr@537.3--537.25
        temp_1 := nodes;
        assume state(Heap, Mask);
      
      // -- Translating statement: prevTemp := null -- BinomialHeap.vpr@538.3--538.28
        prevTemp := null;
        assume state(Heap, Mask);
      
      // -- Translating statement: minNode := findMinNode(nodes) -- BinomialHeap.vpr@540.3--540.32
        PreCallHeap := Heap;
        PreCallMask := Mask;
        
        // -- Exhaling precondition
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          assert {:msg "  The precondition of method findMinNode might not hold. Assertion nodes != null might not hold. (BinomialHeap.vpr@540.3--540.32) [197855]"}
            nodes != null;
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method findMinNode might not hold. There might be insufficient permission to access heapseg(nodes, null) (BinomialHeap.vpr@540.3--540.32) [197856]"}
              perm <= Mask[null, heapseg(nodes, null)];
          }
          Mask := Mask[null, heapseg(nodes, null):=Mask[null, heapseg(nodes, null)] - perm];
          assert {:msg "  The precondition of method findMinNode might not hold. Assertion sorted(nodes, null) might not hold. (BinomialHeap.vpr@540.3--540.32) [197857]"}
            sorted_1(Heap, nodes, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
        
        // -- Havocing target variables
          havoc minNode;
        
        // -- Inhaling postcondition
          assume minNode != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(nodes, minNode):=Mask[null, heapseg(nodes, minNode)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted_1(Heap, nodes, minNode);
          perm := FullPerm;
          Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted_1(Heap, minNode, null);
          if (nodes != minNode) {
            assume state(Heap, Mask);
            assume segDegree(Heap, nodes, minNode, segLength(Heap, nodes, minNode) - 1) < segDegree(Heap, minNode, null, 0);
          }
          assume state(Heap, Mask);
          assume segSize(Heap, nodes, minNode) + segSize(Heap, minNode, null) == segSize(PreCallHeap, nodes, null);
          if (nodes != minNode) {
            assume state(Heap, Mask);
            assume segParent(Heap, nodes, minNode) == segParent(PreCallHeap, nodes, null);
          }
          assume state(Heap, Mask);
          assume segParent(Heap, minNode, null) == segParent(PreCallHeap, nodes, null);
          assume state(Heap, Mask);
        assume Heap[minNode, $allocated];
        assume state(Heap, Mask);
      
      // -- Translating statement: if (minNode == nodes) -- BinomialHeap.vpr@543.3--582.4
        if (minNode == nodes) {
          
          // -- Translating statement: unfold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@544.4--544.30
            assume heapseg#trigger(Heap, heapseg(temp_1, null));
            assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@544.4--544.30) [197860]"}
                perm <= Mask[null, heapseg(temp_1, null)];
            }
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(temp_1, null):=newVersion];
              }
            if (temp_1 != null) {
              perm := FullPerm;
              Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume temp_1 != null;
              Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[temp_1, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: this.Nodes := temp.sibling -- BinomialHeap.vpr@545.4--545.30
            
            // -- Check definedness of temp.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@545.4--545.30) [197864]"}
                HasDirectPerm(Mask, temp_1, sibling);
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@545.4--545.30) [197865]"}
              FullPerm == Mask[this, Nodes_1];
            Heap := Heap[this, Nodes_1:=Heap[temp_1, sibling]];
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: while (temp != minNode) -- BinomialHeap.vpr@547.4--576.5
            
            // -- Before loop head
              
              // -- Exhale loop invariant before loop
                
                // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp != null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [197866]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                
                // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp == null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [197867]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not hold on entry. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@548.15--548.62) [197868]"}
                    perm <= Mask[null, heapseg(temp_1, minNode)];
                }
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not hold on entry. Assertion sorted(temp, minNode) might not hold. (BinomialHeap.vpr@548.15--548.62) [197869]"}
                  sorted_1(Heap, temp_1, minNode);
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not hold on entry. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@549.15--549.62) [197870]"}
                    perm <= Mask[null, heapseg(minNode, null)];
                }
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not hold on entry. Assertion sorted(minNode, null) might not hold. (BinomialHeap.vpr@549.15--549.62) [197871]"}
                  sorted_1(Heap, minNode, null);
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> temp == nodes might not hold on entry. Assertion temp == nodes might not hold. (BinomialHeap.vpr@550.15--550.49) [197872]"}
                    temp_1 == nodes;
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not hold on entry. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@551.15--551.87) [197873]"}
                      perm <= Mask[null, heapseg(nodes, prevTemp)];
                  }
                  Mask := Mask[null, heapseg(nodes, prevTemp):=Mask[null, heapseg(nodes, prevTemp)] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not hold on entry. Assertion sorted(nodes, prevTemp) might not hold. (BinomialHeap.vpr@551.15--551.87) [197874]"}
                    sorted_1(Heap, nodes, prevTemp);
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not hold on entry. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@552.15--552.103) [197875]"}
                      perm <= Mask[null, tree_1(prevTemp)];
                  }
                  Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not hold on entry. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@552.15--552.103) [197876]"}
                      perm <= Mask[prevTemp, sibling];
                  }
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not hold on entry. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@552.15--552.103) [197877]"}
                    Heap[prevTemp, sibling] == temp_1;
                }
                if (prevTemp != null && prevTemp != nodes) {
                  assert {:msg "  Loop invariant prevTemp != null && prevTemp != nodes ==> segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold on entry. Assertion segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@553.15--553.138) [197878]"}
                    segDegree(Heap, nodes, prevTemp, segLength(Heap, nodes, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                if (prevTemp != null && temp_1 != minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp != minNode ==> treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not hold on entry. Assertion treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not hold. (BinomialHeap.vpr@554.15--554.105) [197879]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                if (prevTemp != null && temp_1 == minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp == minNode ==> treeDegree(prevTemp) < segDegree(minNode, null, 0) might not hold on entry. Assertion treeDegree(prevTemp) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@555.15--555.105) [197880]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not hold on entry. Assertion segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@556.15--556.119) [197881]"}
                    segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. Assertion segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@557.15--557.189) [197882]"}
                    segSize(Heap, nodes, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. Assertion segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@558.15--558.141) [197883]"}
                    segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segParent(temp, minNode) == null might not hold on entry. Assertion segParent(temp, minNode) == null might not hold. (BinomialHeap.vpr@559.15--559.67) [197884]"}
                    segParent(Heap, temp_1, minNode) == null;
                }
                if (minNode != null) {
                  assert {:msg "  Loop invariant minNode != null ==> segParent(minNode, null) == null might not hold on entry. Assertion segParent(minNode, null) == null might not hold. (BinomialHeap.vpr@560.15--560.67) [197885]"}
                    segParent(Heap, minNode, null) == null;
                }
                if (prevTemp != null && nodes != prevTemp) {
                  assert {:msg "  Loop invariant prevTemp != null && nodes != prevTemp ==> segParent(nodes, prevTemp) == null might not hold on entry. Assertion segParent(nodes, prevTemp) == null might not hold. (BinomialHeap.vpr@561.15--561.91) [197886]"}
                    segParent(Heap, nodes, prevTemp) == null;
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> treeParent(prevTemp) == null might not hold on entry. Assertion treeParent(prevTemp) == null might not hold. (BinomialHeap.vpr@562.15--562.64) [197887]"}
                    treeParent(Heap, prevTemp) == null;
                }
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
            
            // -- Havoc loop written variables (except locals)
              havoc temp_1, prevTemp;
              assume Heap[temp_1, $allocated];
              assume Heap[prevTemp, $allocated];
            
            // -- Check definedness of invariant
              if (*) {
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                
                // -- Check definedness of sorted(temp, minNode)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@548.41--548.62) [197888]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume sorted_1(Heap, temp_1, minNode);
                assume state(Heap, Mask);
                perm := FullPerm;
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                
                // -- Check definedness of sorted(minNode, null)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@549.41--549.62) [197889]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume sorted_1(Heap, minNode, null);
                assume state(Heap, Mask);
                if (prevTemp == null) {
                  assume temp_1 == nodes;
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(nodes, prevTemp):=Mask[null, heapseg(nodes, prevTemp)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of sorted(nodes, prevTemp)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@551.64--551.87) [197890]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes, prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume sorted_1(Heap, nodes, prevTemp);
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume prevTemp != null;
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of prevTemp.sibling == temp
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@552.15--552.103) [197891]"}
                      HasDirectPerm(Mask, prevTemp, sibling);
                  assume Heap[prevTemp, sibling] == temp_1;
                }
                assume state(Heap, Mask);
                if (prevTemp != null && prevTemp != nodes) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@553.84--553.110) [197892]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes, prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@553.57--553.115) [197893]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes, prevTemp)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(nodes, prevTemp) - 1 might not hold. (BinomialHeap.vpr@553.57--553.115) [197894]"}
                        0 <= segLength(Heap, nodes, prevTemp) - 1;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(nodes, prevTemp) - 1 < segLength(nodes, prevTemp) might not hold. (BinomialHeap.vpr@553.57--553.115) [197895]"}
                        segLength(Heap, nodes, prevTemp) - 1 < segLength(Heap, nodes, prevTemp);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@553.118--553.138) [197896]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segDegree(Heap, nodes, prevTemp, segLength(Heap, nodes, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                assume state(Heap, Mask);
                if (prevTemp != null && temp_1 != minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of treeDegree(prevTemp) < segDegree(temp, minNode, 0)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@554.55--554.75) [197897]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@554.78--554.105) [197898]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp, minNode) might not hold. (BinomialHeap.vpr@554.78--554.105) [197899]"}
                        0 < segLength(Heap, temp_1, minNode);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                assume state(Heap, Mask);
                if (prevTemp != null && temp_1 == minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of treeDegree(prevTemp) < segDegree(minNode, null, 0)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@555.55--555.75) [197900]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@555.78--555.105) [197901]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(minNode, null) might not hold. (BinomialHeap.vpr@555.78--555.105) [197902]"}
                        0 < segLength(Heap, minNode, null);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                assume state(Heap, Mask);
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@556.60--556.84) [197903]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@556.35--556.89) [197904]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp, minNode) - 1 might not hold. (BinomialHeap.vpr@556.35--556.89) [197905]"}
                        0 <= segLength(Heap, temp_1, minNode) - 1;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp, minNode) - 1 < segLength(temp, minNode) might not hold. (BinomialHeap.vpr@556.35--556.89) [197906]"}
                        segLength(Heap, temp_1, minNode) - 1 < segLength(Heap, temp_1, minNode);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@556.92--556.119) [197907]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(minNode, null) might not hold. (BinomialHeap.vpr@556.92--556.119) [197908]"}
                        0 < segLength(Heap, minNode, null);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null)))
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@557.36--557.60) [197909]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes, prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@557.63--557.81) [197910]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@557.84--557.106) [197911]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@557.109--557.131) [197912]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [197913]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@557.15--557.189) [197914]"}
                      HasDirectPerm(UnfoldingMask, this, Nodes_1);
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := UnfoldingHeap;
                      ExhaleWellDef0Mask := UnfoldingMask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@557.163--557.188) [197915]"}
                        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
                      UnfoldingHeap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segSize(Heap, nodes, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                assume state(Heap, Mask);
                if (prevTemp == null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null)))
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@558.36--558.58) [197916]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@558.61--558.83) [197917]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [197918]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@558.15--558.141) [197919]"}
                      HasDirectPerm(UnfoldingMask, this, Nodes_1);
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := UnfoldingHeap;
                      ExhaleWellDef0Mask := UnfoldingMask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@558.115--558.140) [197920]"}
                        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
                      UnfoldingHeap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                assume state(Heap, Mask);
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segParent(temp, minNode) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@559.35--559.59) [197921]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      assert {:msg "  Precondition of function segParent might not hold. Assertion temp != minNode might not hold. (BinomialHeap.vpr@559.35--559.59) [197922]"}
                        temp_1 != minNode;
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segParent(Heap, temp_1, minNode) == null;
                }
                assume state(Heap, Mask);
                if (minNode != null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segParent(minNode, null) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@560.35--560.59) [197923]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      assert {:msg "  Precondition of function segParent might not hold. Assertion minNode != null might not hold. (BinomialHeap.vpr@560.35--560.59) [197924]"}
                        minNode != null;
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segParent(Heap, minNode, null) == null;
                }
                assume state(Heap, Mask);
                if (prevTemp != null && nodes != prevTemp) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segParent(nodes, prevTemp) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@561.57--561.83) [197925]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes, prevTemp)];
                      assert {:msg "  Precondition of function segParent might not hold. Assertion nodes != prevTemp might not hold. (BinomialHeap.vpr@561.57--561.83) [197926]"}
                        nodes != prevTemp;
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segParent(Heap, nodes, prevTemp) == null;
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of treeParent(prevTemp) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@562.36--562.56) [197927]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree_1(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume treeParent(Heap, prevTemp) == null;
                }
                assume state(Heap, Mask);
                assume false;
              }
            
            // -- Check the loop body
              if (*) {
                // Reset state
                loopHeap := Heap;
                loopMask := Mask;
                Mask := ZeroMask;
                assume state(Heap, Mask);
                // Inhale invariant
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume sorted_1(Heap, temp_1, minNode);
                perm := FullPerm;
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume sorted_1(Heap, minNode, null);
                if (prevTemp == null) {
                  assume temp_1 == nodes;
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(nodes, prevTemp):=Mask[null, heapseg(nodes, prevTemp)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume sorted_1(Heap, nodes, prevTemp);
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume prevTemp != null;
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
                  assume state(Heap, Mask);
                  assume Heap[prevTemp, sibling] == temp_1;
                }
                if (prevTemp != null && prevTemp != nodes) {
                  assume state(Heap, Mask);
                  assume segDegree(Heap, nodes, prevTemp, segLength(Heap, nodes, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                if (prevTemp != null && temp_1 != minNode) {
                  assume state(Heap, Mask);
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                if (prevTemp != null && temp_1 == minNode) {
                  assume state(Heap, Mask);
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  assume segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  assume segSize(Heap, nodes, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                if (prevTemp == null) {
                  assume state(Heap, Mask);
                  assume segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, temp_1, minNode) == null;
                }
                if (minNode != null) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, minNode, null) == null;
                }
                if (prevTemp != null && nodes != prevTemp) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, nodes, prevTemp) == null;
                }
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  assume treeParent(Heap, prevTemp) == null;
                }
                assume state(Heap, Mask);
                
                // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp != null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [197928]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                
                // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp == null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [197929]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                // Check and assume guard
                assume temp_1 != minNode;
                assume state(Heap, Mask);
                
                // -- Translate loop body
                  
                  // -- Translating statement: unfold acc(heapseg(temp, minNode), write) -- BinomialHeap.vpr@564.5--564.34
                    assume heapseg#trigger(Heap, heapseg(temp_1, minNode));
                    assume Heap[null, heapseg(temp_1, minNode)] == FrameFragment((if temp_1 != minNode then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], minNode)], FrameFragment((if Heap[temp_1, sibling] != minNode then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding heapseg(temp, minNode) might fail. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@564.5--564.34) [197930]"}
                        perm <= Mask[null, heapseg(temp_1, minNode)];
                    }
                    Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, heapseg(temp_1, minNode))) {
                        havoc newVersion;
                        Heap := Heap[null, heapseg(temp_1, minNode):=newVersion];
                      }
                    if (temp_1 != minNode) {
                      perm := FullPerm;
                      Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                      
                      // -- Extra unfolding of predicate
                        assume InsidePredicate(heapseg(temp_1, minNode), Heap[null, heapseg(temp_1, minNode)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                      assume state(Heap, Mask);
                      perm := FullPerm;
                      assume temp_1 != null;
                      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
                      assume state(Heap, Mask);
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(Heap[temp_1, sibling], minNode):=Mask[null, heapseg(Heap[temp_1, sibling], minNode)] + perm];
                      
                      // -- Extra unfolding of predicate
                        assume InsidePredicate(heapseg(temp_1, minNode), Heap[null, heapseg(temp_1, minNode)], heapseg(Heap[temp_1, sibling], minNode), Heap[null, heapseg(Heap[temp_1, sibling], minNode)]);
                      assume state(Heap, Mask);
                      if (Heap[temp_1, sibling] != minNode) {
                        assume state(Heap, Mask);
                        assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], minNode);
                      }
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: if (prevTemp == null) -- BinomialHeap.vpr@565.5--572.6
                    if (prevTemp == null) {
                      
                      // -- Translating statement: fold acc(heapseg(nodes, temp), write) -- BinomialHeap.vpr@567.6--567.31
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (nodes != temp_1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. There might be insufficient permission to access tree(nodes) (BinomialHeap.vpr@567.6--567.31) [197931]"}
                              perm <= Mask[null, tree_1(nodes)];
                          }
                          Mask := Mask[null, tree_1(nodes):=Mask[null, tree_1(nodes)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(nodes, temp_1), Heap[null, heapseg(nodes, temp_1)], tree_1(nodes), Heap[null, tree_1(nodes)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. There might be insufficient permission to access nodes.sibling (BinomialHeap.vpr@567.6--567.31) [197932]"}
                              perm <= Mask[nodes, sibling];
                          }
                          Mask := Mask[nodes, sibling:=Mask[nodes, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. There might be insufficient permission to access heapseg(nodes.sibling, temp) (BinomialHeap.vpr@567.6--567.31) [197933]"}
                              perm <= Mask[null, heapseg(Heap[nodes, sibling], temp_1)];
                          }
                          Mask := Mask[null, heapseg(Heap[nodes, sibling], temp_1):=Mask[null, heapseg(Heap[nodes, sibling], temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(nodes, temp_1), Heap[null, heapseg(nodes, temp_1)], heapseg(Heap[nodes, sibling], temp_1), Heap[null, heapseg(Heap[nodes, sibling], temp_1)]);
                          if (Heap[nodes, sibling] != temp_1) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. Assertion treeParent(nodes) == segParent(nodes.sibling, temp) might not hold. (BinomialHeap.vpr@567.6--567.31) [197934]"}
                              treeParent(Heap, nodes) == segParent(Heap, Heap[nodes, sibling], temp_1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(nodes, temp_1):=Mask[null, heapseg(nodes, temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(nodes, temp_1));
                        assume Heap[null, heapseg(nodes, temp_1)] == FrameFragment((if nodes != temp_1 then CombineFrames(Heap[null, tree_1(nodes)], CombineFrames(FrameFragment(Heap[nodes, sibling]), CombineFrames(Heap[null, heapseg(Heap[nodes, sibling], temp_1)], FrameFragment((if Heap[nodes, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(nodes, temp_1))) {
                          Heap := Heap[null, heapseg#sm(nodes, temp_1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(nodes, temp_1):=freshVersion];
                        }
                        if (nodes != temp_1) {
                          havoc newPMask;
                          assume (forall <A, B> o_176: Ref, f_186: (Field A B) ::
                            { newPMask[o_176, f_186] }
                            Heap[null, heapseg#sm(nodes, temp_1)][o_176, f_186] || Heap[null, tree#sm(nodes)][o_176, f_186] ==> newPMask[o_176, f_186]
                          );
                          Heap := Heap[null, heapseg#sm(nodes, temp_1):=newPMask];
                          Heap := Heap[null, heapseg#sm(nodes, temp_1):=Heap[null, heapseg#sm(nodes, temp_1)][nodes, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_177: Ref, f_187: (Field A B) ::
                            { newPMask[o_177, f_187] }
                            Heap[null, heapseg#sm(nodes, temp_1)][o_177, f_187] || Heap[null, heapseg#sm(Heap[nodes, sibling], temp_1)][o_177, f_187] ==> newPMask[o_177, f_187]
                          );
                          Heap := Heap[null, heapseg#sm(nodes, temp_1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: fold acc(heapseg(temp, temp), write) -- BinomialHeap.vpr@569.6--569.30
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp_1 != temp_1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@569.6--569.30) [197935]"}
                              perm <= Mask[null, tree_1(temp_1)];
                          }
                          Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@569.6--569.30) [197936]"}
                              perm <= Mask[temp_1, sibling];
                          }
                          Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access heapseg(temp.sibling, temp) (BinomialHeap.vpr@569.6--569.30) [197937]"}
                              perm <= Mask[null, heapseg(Heap[temp_1, sibling], temp_1)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp_1, sibling], temp_1):=Mask[null, heapseg(Heap[temp_1, sibling], temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], heapseg(Heap[temp_1, sibling], temp_1), Heap[null, heapseg(Heap[temp_1, sibling], temp_1)]);
                          if (Heap[temp_1, sibling] != temp_1) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. Assertion treeParent(temp) == segParent(temp.sibling, temp) might not hold. (BinomialHeap.vpr@569.6--569.30) [197938]"}
                              treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], temp_1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp_1, temp_1):=Mask[null, heapseg(temp_1, temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp_1, temp_1));
                        assume Heap[null, heapseg(temp_1, temp_1)] == FrameFragment((if temp_1 != temp_1 then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], temp_1)], FrameFragment((if Heap[temp_1, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp_1, temp_1))) {
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp_1, temp_1):=freshVersion];
                        }
                        if (temp_1 != temp_1) {
                          havoc newPMask;
                          assume (forall <A, B> o_178: Ref, f_188: (Field A B) ::
                            { newPMask[o_178, f_188] }
                            Heap[null, heapseg#sm(temp_1, temp_1)][o_178, f_188] || Heap[null, tree#sm(temp_1)][o_178, f_188] ==> newPMask[o_178, f_188]
                          );
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=Heap[null, heapseg#sm(temp_1, temp_1)][temp_1, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_179: Ref, f_189: (Field A B) ::
                            { newPMask[o_179, f_189] }
                            Heap[null, heapseg#sm(temp_1, temp_1)][o_179, f_189] || Heap[null, heapseg#sm(Heap[temp_1, sibling], temp_1)][o_179, f_189] ==> newPMask[o_179, f_189]
                          );
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(prevTemp, temp), write) -- BinomialHeap.vpr@570.6--570.34
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (prevTemp != temp_1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@570.6--570.34) [197939]"}
                              perm <= Mask[null, tree_1(prevTemp)];
                          }
                          Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], tree_1(prevTemp), Heap[null, tree_1(prevTemp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@570.6--570.34) [197940]"}
                              perm <= Mask[prevTemp, sibling];
                          }
                          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, temp) (BinomialHeap.vpr@570.6--570.34) [197941]"}
                              perm <= Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)];
                          }
                          Mask := Mask[null, heapseg(Heap[prevTemp, sibling], temp_1):=Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], heapseg(Heap[prevTemp, sibling], temp_1), Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)]);
                          if (Heap[prevTemp, sibling] != temp_1) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, temp) might not hold. (BinomialHeap.vpr@570.6--570.34) [197942]"}
                              treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], temp_1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(prevTemp, temp_1));
                        assume Heap[null, heapseg(prevTemp, temp_1)] == FrameFragment((if prevTemp != temp_1 then CombineFrames(Heap[null, tree_1(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)], FrameFragment((if Heap[prevTemp, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(prevTemp, temp_1))) {
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(prevTemp, temp_1):=freshVersion];
                        }
                        if (prevTemp != temp_1) {
                          havoc newPMask;
                          assume (forall <A, B> o_180: Ref, f_190: (Field A B) ::
                            { newPMask[o_180, f_190] }
                            Heap[null, heapseg#sm(prevTemp, temp_1)][o_180, f_190] || Heap[null, tree#sm(prevTemp)][o_180, f_190] ==> newPMask[o_180, f_190]
                          );
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=Heap[null, heapseg#sm(prevTemp, temp_1)][prevTemp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_181: Ref, f_191: (Field A B) ::
                            { newPMask[o_181, f_191] }
                            Heap[null, heapseg#sm(prevTemp, temp_1)][o_181, f_191] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], temp_1)][o_181, f_191] ==> newPMask[o_181, f_191]
                          );
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: concat(nodes, prevTemp, temp) -- BinomialHeap.vpr@571.6--571.35
                        PreCallHeap := Heap;
                        PreCallMask := Mask;
                        
                        // -- Exhaling precondition
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@571.6--571.35) [197943]"}
                              perm <= Mask[null, heapseg(nodes, prevTemp)];
                          }
                          Mask := Mask[null, heapseg(nodes, prevTemp):=Mask[null, heapseg(nodes, prevTemp)] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, temp) (BinomialHeap.vpr@571.6--571.35) [197944]"}
                              perm <= Mask[null, heapseg(prevTemp, temp_1)];
                          }
                          Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] - perm];
                          if (temp_1 != null) {
                            perm := FullPerm;
                            if (perm != NoPerm) {
                              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@571.6--571.35) [197945]"}
                                perm <= Mask[null, tree_1(temp_1)];
                            }
                            Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                          }
                          if (nodes != prevTemp && prevTemp != temp_1) {
                            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(nodes, prevTemp) == segParent(prevTemp, temp) might not hold. (BinomialHeap.vpr@571.6--571.35) [197946]"}
                              segParent(Heap, nodes, prevTemp) == segParent(Heap, prevTemp, temp_1);
                          }
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                        
                        // -- Inhaling postcondition
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(nodes, temp_1):=Mask[null, heapseg(nodes, temp_1)] + perm];
                          assume state(Heap, Mask);
                          assume state(Heap, Mask);
                          assume segLength(Heap, nodes, temp_1) == segLength(PreCallHeap, nodes, prevTemp) + segLength(PreCallHeap, prevTemp, temp_1);
                          assume state(Heap, Mask);
                          assume (forall i: int ::
                            { segDegree#frame(Heap[null, heapseg(nodes, temp_1)], nodes, temp_1, i) } { segDegree#frame(PreCallHeap[null, heapseg(nodes, prevTemp)], nodes, prevTemp, i) }
                            0 <= i && i < segLength(PreCallHeap, nodes, prevTemp) ==> segDegree(Heap, nodes, temp_1, i) == segDegree(PreCallHeap, nodes, prevTemp, i)
                          );
                          assume state(Heap, Mask);
                          assume (forall i_1: int ::
                            { segDegree#frame(Heap[null, heapseg(nodes, temp_1)], nodes, temp_1, i_1) }
                            segLength(PreCallHeap, nodes, prevTemp) <= i_1 && i_1 < segLength(Heap, nodes, temp_1) ==> segDegree(Heap, nodes, temp_1, i_1) == segDegree(PreCallHeap, prevTemp, temp_1, i_1 - segLength(PreCallHeap, nodes, prevTemp))
                          );
                          if (temp_1 != null) {
                            perm := FullPerm;
                            Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                            assume state(Heap, Mask);
                            assume state(Heap, Mask);
                            assume treeDegree(Heap, temp_1) == treeDegree(PreCallHeap, temp_1);
                            assume state(Heap, Mask);
                            assume treeSize(Heap, temp_1) == treeSize(PreCallHeap, temp_1);
                            assume state(Heap, Mask);
                            assume treeParent(Heap, temp_1) == treeParent(PreCallHeap, temp_1);
                          }
                          if (sorted_1(PreCallHeap, nodes, prevTemp) && (sorted_1(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, nodes, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))) {
                            assume state(Heap, Mask);
                            assume sorted_1(Heap, nodes, temp_1);
                          }
                          if (presorted(PreCallHeap, nodes, prevTemp) && (presorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, nodes, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, temp_1, 0) && ((2 <= segLength(PreCallHeap, nodes, prevTemp) && segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) == segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 2) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)) && (2 <= segLength(PreCallHeap, prevTemp, temp_1) && segDegree(PreCallHeap, prevTemp, temp_1, 0) == segDegree(PreCallHeap, prevTemp, temp_1, 1) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))))) {
                            assume state(Heap, Mask);
                            assume presorted(Heap, nodes, temp_1);
                          }
                          if (validChildren(PreCallHeap, nodes, prevTemp) && (validChildren(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, nodes, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, temp_1, 0) + 1))) {
                            assume state(Heap, Mask);
                            assume validChildren(Heap, nodes, temp_1);
                          }
                          assume state(Heap, Mask);
                          assume segSize(Heap, nodes, temp_1) == segSize(PreCallHeap, nodes, prevTemp) + segSize(PreCallHeap, prevTemp, temp_1);
                          if (nodes != prevTemp) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, nodes, temp_1) == segParent(PreCallHeap, nodes, prevTemp);
                          }
                          if (prevTemp != temp_1) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, nodes, temp_1) == segParent(PreCallHeap, prevTemp, temp_1);
                          }
                          assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: prevTemp := temp -- BinomialHeap.vpr@574.5--574.21
                    prevTemp := temp_1;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp := temp.sibling -- BinomialHeap.vpr@575.5--575.25
                    
                    // -- Check definedness of temp.sibling
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@575.5--575.25) [197947]"}
                        HasDirectPerm(Mask, temp_1, sibling);
                    temp_1 := Heap[temp_1, sibling];
                    assume state(Heap, Mask);
                // Exhale invariant
                
                // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp != null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [197948]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                
                // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp == null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [197949]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    if (UnfoldingHeap[this, Nodes_1] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not be preserved. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@548.15--548.62) [197950]"}
                    perm <= Mask[null, heapseg(temp_1, minNode)];
                }
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not be preserved. Assertion sorted(temp, minNode) might not hold. (BinomialHeap.vpr@548.15--548.62) [197951]"}
                  sorted_1(Heap, temp_1, minNode);
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not be preserved. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@549.15--549.62) [197952]"}
                    perm <= Mask[null, heapseg(minNode, null)];
                }
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not be preserved. Assertion sorted(minNode, null) might not hold. (BinomialHeap.vpr@549.15--549.62) [197953]"}
                  sorted_1(Heap, minNode, null);
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> temp == nodes might not be preserved. Assertion temp == nodes might not hold. (BinomialHeap.vpr@550.15--550.49) [197954]"}
                    temp_1 == nodes;
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not be preserved. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@551.15--551.87) [197955]"}
                      perm <= Mask[null, heapseg(nodes, prevTemp)];
                  }
                  Mask := Mask[null, heapseg(nodes, prevTemp):=Mask[null, heapseg(nodes, prevTemp)] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not be preserved. Assertion sorted(nodes, prevTemp) might not hold. (BinomialHeap.vpr@551.15--551.87) [197956]"}
                    sorted_1(Heap, nodes, prevTemp);
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not be preserved. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@552.15--552.103) [197957]"}
                      perm <= Mask[null, tree_1(prevTemp)];
                  }
                  Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not be preserved. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@552.15--552.103) [197958]"}
                      perm <= Mask[prevTemp, sibling];
                  }
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not be preserved. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@552.15--552.103) [197959]"}
                    Heap[prevTemp, sibling] == temp_1;
                }
                if (prevTemp != null && prevTemp != nodes) {
                  assert {:msg "  Loop invariant prevTemp != null && prevTemp != nodes ==> segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not be preserved. Assertion segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@553.15--553.138) [197960]"}
                    segDegree(Heap, nodes, prevTemp, segLength(Heap, nodes, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                if (prevTemp != null && temp_1 != minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp != minNode ==> treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not be preserved. Assertion treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not hold. (BinomialHeap.vpr@554.15--554.105) [197961]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                if (prevTemp != null && temp_1 == minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp == minNode ==> treeDegree(prevTemp) < segDegree(minNode, null, 0) might not be preserved. Assertion treeDegree(prevTemp) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@555.15--555.105) [197962]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not be preserved. Assertion segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@556.15--556.119) [197963]"}
                    segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. Assertion segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@557.15--557.189) [197964]"}
                    segSize(Heap, nodes, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. Assertion segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@558.15--558.141) [197965]"}
                    segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segParent(temp, minNode) == null might not be preserved. Assertion segParent(temp, minNode) == null might not hold. (BinomialHeap.vpr@559.15--559.67) [197966]"}
                    segParent(Heap, temp_1, minNode) == null;
                }
                if (minNode != null) {
                  assert {:msg "  Loop invariant minNode != null ==> segParent(minNode, null) == null might not be preserved. Assertion segParent(minNode, null) == null might not hold. (BinomialHeap.vpr@560.15--560.67) [197967]"}
                    segParent(Heap, minNode, null) == null;
                }
                if (prevTemp != null && nodes != prevTemp) {
                  assert {:msg "  Loop invariant prevTemp != null && nodes != prevTemp ==> segParent(nodes, prevTemp) == null might not be preserved. Assertion segParent(nodes, prevTemp) == null might not hold. (BinomialHeap.vpr@561.15--561.91) [197968]"}
                    segParent(Heap, nodes, prevTemp) == null;
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> treeParent(prevTemp) == null might not be preserved. Assertion treeParent(prevTemp) == null might not hold. (BinomialHeap.vpr@562.15--562.64) [197969]"}
                    treeParent(Heap, prevTemp) == null;
                }
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Terminate execution
                assume false;
              }
            
            // -- Inhale loop invariant after loop, and assume guard
              assume !(temp_1 != minNode);
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume sorted_1(Heap, temp_1, minNode);
              perm := FullPerm;
              Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume sorted_1(Heap, minNode, null);
              if (prevTemp == null) {
                assume temp_1 == nodes;
              }
              if (prevTemp != null) {
                perm := FullPerm;
                Mask := Mask[null, heapseg(nodes, prevTemp):=Mask[null, heapseg(nodes, prevTemp)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume sorted_1(Heap, nodes, prevTemp);
              }
              if (prevTemp != null) {
                perm := FullPerm;
                Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume prevTemp != null;
                Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
                assume state(Heap, Mask);
                assume Heap[prevTemp, sibling] == temp_1;
              }
              if (prevTemp != null && prevTemp != nodes) {
                assume state(Heap, Mask);
                assume segDegree(Heap, nodes, prevTemp, segLength(Heap, nodes, prevTemp) - 1) < treeDegree(Heap, prevTemp);
              }
              if (prevTemp != null && temp_1 != minNode) {
                assume state(Heap, Mask);
                assume treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
              }
              if (prevTemp != null && temp_1 == minNode) {
                assume state(Heap, Mask);
                assume treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
              }
              if (temp_1 != minNode) {
                assume state(Heap, Mask);
                assume segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
              }
              if (prevTemp != null) {
                assume state(Heap, Mask);
                assume segSize(Heap, nodes, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
              }
              if (prevTemp == null) {
                assume state(Heap, Mask);
                assume segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes_1], null);
              }
              if (temp_1 != minNode) {
                assume state(Heap, Mask);
                assume segParent(Heap, temp_1, minNode) == null;
              }
              if (minNode != null) {
                assume state(Heap, Mask);
                assume segParent(Heap, minNode, null) == null;
              }
              if (prevTemp != null && nodes != prevTemp) {
                assume state(Heap, Mask);
                assume segParent(Heap, nodes, prevTemp) == null;
              }
              if (prevTemp != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, prevTemp) == null;
              }
              assume state(Heap, Mask);
              
              // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                if (prevTemp != null) {
                  UnfoldingHeap := oldHeap;
                  UnfoldingMask := oldMask;
                  assume heap#trigger(UnfoldingHeap, heap_1(this));
                  assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                  ExhaleWellDef0Heap := UnfoldingHeap;
                  ExhaleWellDef0Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [197970]"}
                      perm <= UnfoldingMask[null, heap_1(this)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  perm := FullPerm;
                  UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                  if (UnfoldingHeap[this, Nodes_1] != null) {
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                  }
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                  assume state(UnfoldingHeap, UnfoldingMask);
                }
              
              // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                if (prevTemp == null) {
                  UnfoldingHeap := oldHeap;
                  UnfoldingMask := oldMask;
                  assume heap#trigger(UnfoldingHeap, heap_1(this));
                  assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes_1]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size_3]))));
                  ExhaleWellDef0Heap := UnfoldingHeap;
                  ExhaleWellDef0Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [197971]"}
                      perm <= UnfoldingMask[null, heap_1(this)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, Nodes_1:=UnfoldingMask[this, Nodes_1] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  perm := FullPerm;
                  UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes_1], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes_1], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes_1], null)]);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume sorted_1(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                  if (UnfoldingHeap[this, Nodes_1] != null) {
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null) == null;
                  }
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, size_3:=UnfoldingMask[this, size_3] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume UnfoldingHeap[this, size_3] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes_1], null);
                  assume state(UnfoldingHeap, UnfoldingMask);
                }
            assume state(Heap, Mask);
          
          // -- Translating statement: unfold acc(heapseg(minNode, null), write) -- BinomialHeap.vpr@578.4--578.33
            assume heapseg#trigger(Heap, heapseg(minNode, null));
            assume Heap[null, heapseg(minNode, null)] == FrameFragment((if minNode != null then CombineFrames(Heap[null, tree_1(minNode)], CombineFrames(FrameFragment(Heap[minNode, sibling]), CombineFrames(Heap[null, heapseg(Heap[minNode, sibling], null)], FrameFragment((if Heap[minNode, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(minNode, null) might fail. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@578.4--578.33) [197974]"}
                perm <= Mask[null, heapseg(minNode, null)];
            }
            Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(minNode, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(minNode, null):=newVersion];
              }
            if (minNode != null) {
              perm := FullPerm;
              Mask := Mask[null, tree_1(minNode):=Mask[null, tree_1(minNode)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(minNode, null), Heap[null, heapseg(minNode, null)], tree_1(minNode), Heap[null, tree_1(minNode)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume minNode != null;
              Mask := Mask[minNode, sibling:=Mask[minNode, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[minNode, sibling], null):=Mask[null, heapseg(Heap[minNode, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(minNode, null), Heap[null, heapseg(minNode, null)], heapseg(Heap[minNode, sibling], null), Heap[null, heapseg(Heap[minNode, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[minNode, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, minNode) == segParent(Heap, Heap[minNode, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: prevTemp.sibling := temp.sibling -- BinomialHeap.vpr@579.4--579.36
            
            // -- Check definedness of temp.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@579.4--579.36) [197978]"}
                HasDirectPerm(Mask, temp_1, sibling);
            assert {:msg "  Assignment might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@579.4--579.36) [197979]"}
              FullPerm == Mask[prevTemp, sibling];
            Heap := Heap[prevTemp, sibling:=Heap[temp_1, sibling]];
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(prevTemp, null), write) -- BinomialHeap.vpr@580.4--580.32
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (prevTemp != null) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@580.4--580.32) [197982]"}
                  perm <= Mask[null, tree_1(prevTemp)];
              }
              Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], tree_1(prevTemp), Heap[null, tree_1(prevTemp)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@580.4--580.32) [197984]"}
                  perm <= Mask[prevTemp, sibling];
              }
              Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, null) (BinomialHeap.vpr@580.4--580.32) [197986]"}
                  perm <= Mask[null, heapseg(Heap[prevTemp, sibling], null)];
              }
              Mask := Mask[null, heapseg(Heap[prevTemp, sibling], null):=Mask[null, heapseg(Heap[prevTemp, sibling], null)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], heapseg(Heap[prevTemp, sibling], null), Heap[null, heapseg(Heap[prevTemp, sibling], null)]);
              if (Heap[prevTemp, sibling] != null) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, null) might not hold. (BinomialHeap.vpr@580.4--580.32) [197987]"}
                  treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], null);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(prevTemp, null));
            assume Heap[null, heapseg(prevTemp, null)] == FrameFragment((if prevTemp != null then CombineFrames(Heap[null, tree_1(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], null)], FrameFragment((if Heap[prevTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(prevTemp, null))) {
              Heap := Heap[null, heapseg#sm(prevTemp, null):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(prevTemp, null):=freshVersion];
            }
            if (prevTemp != null) {
              havoc newPMask;
              assume (forall <A, B> o_182: Ref, f_192: (Field A B) ::
                { newPMask[o_182, f_192] }
                Heap[null, heapseg#sm(prevTemp, null)][o_182, f_192] || Heap[null, tree#sm(prevTemp)][o_182, f_192] ==> newPMask[o_182, f_192]
              );
              Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
              Heap := Heap[null, heapseg#sm(prevTemp, null):=Heap[null, heapseg#sm(prevTemp, null)][prevTemp, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_183: Ref, f_193: (Field A B) ::
                { newPMask[o_183, f_193] }
                Heap[null, heapseg#sm(prevTemp, null)][o_183, f_193] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], null)][o_183, f_193] ==> newPMask[o_183, f_193]
              );
              Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: concat(nodes, prevTemp, null) -- BinomialHeap.vpr@581.4--581.33
            PreCallHeap := Heap;
            PreCallMask := Mask;
            
            // -- Exhaling precondition
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@581.4--581.33) [197989]"}
                  perm <= Mask[null, heapseg(nodes, prevTemp)];
              }
              Mask := Mask[null, heapseg(nodes, prevTemp):=Mask[null, heapseg(nodes, prevTemp)] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, null) (BinomialHeap.vpr@581.4--581.33) [197990]"}
                  perm <= Mask[null, heapseg(prevTemp, null)];
              }
              Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] - perm];
              if (null != null) {
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@581.4--581.33) [197991]"}
                    perm <= Mask[null, tree_1(null)];
                }
                Mask := Mask[null, tree_1(null):=Mask[null, tree_1(null)] - perm];
              }
              if (nodes != prevTemp && prevTemp != null) {
                assert {:msg "  The precondition of method concat might not hold. Assertion segParent(nodes, prevTemp) == segParent(prevTemp, null) might not hold. (BinomialHeap.vpr@581.4--581.33) [197992]"}
                  segParent(Heap, nodes, prevTemp) == segParent(Heap, prevTemp, null);
              }
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
            
            // -- Inhaling postcondition
              perm := FullPerm;
              Mask := Mask[null, heapseg(nodes, null):=Mask[null, heapseg(nodes, null)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume segLength(Heap, nodes, null) == segLength(PreCallHeap, nodes, prevTemp) + segLength(PreCallHeap, prevTemp, null);
              assume state(Heap, Mask);
              assume (forall i_2: int ::
                { segDegree#frame(Heap[null, heapseg(nodes, null)], nodes, null, i_2) } { segDegree#frame(PreCallHeap[null, heapseg(nodes, prevTemp)], nodes, prevTemp, i_2) }
                0 <= i_2 && i_2 < segLength(PreCallHeap, nodes, prevTemp) ==> segDegree(Heap, nodes, null, i_2) == segDegree(PreCallHeap, nodes, prevTemp, i_2)
              );
              assume state(Heap, Mask);
              assume (forall i_3_2: int ::
                { segDegree#frame(Heap[null, heapseg(nodes, null)], nodes, null, i_3_2) }
                segLength(PreCallHeap, nodes, prevTemp) <= i_3_2 && i_3_2 < segLength(Heap, nodes, null) ==> segDegree(Heap, nodes, null, i_3_2) == segDegree(PreCallHeap, prevTemp, null, i_3_2 - segLength(PreCallHeap, nodes, prevTemp))
              );
              if (null != null) {
                perm := FullPerm;
                Mask := Mask[null, tree_1(null):=Mask[null, tree_1(null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume treeDegree(Heap, null) == treeDegree(PreCallHeap, null);
                assume state(Heap, Mask);
                assume treeSize(Heap, null) == treeSize(PreCallHeap, null);
                assume state(Heap, Mask);
                assume treeParent(Heap, null) == treeParent(PreCallHeap, null);
              }
              if (sorted_1(PreCallHeap, nodes, prevTemp) && (sorted_1(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, nodes, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))) {
                assume state(Heap, Mask);
                assume sorted_1(Heap, nodes, null);
              }
              if (presorted(PreCallHeap, nodes, prevTemp) && (presorted(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, nodes, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, null, 0) && ((2 <= segLength(PreCallHeap, nodes, prevTemp) && segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) == segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 2) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)) && (2 <= segLength(PreCallHeap, prevTemp, null) && segDegree(PreCallHeap, prevTemp, null, 0) == segDegree(PreCallHeap, prevTemp, null, 1) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))))) {
                assume state(Heap, Mask);
                assume presorted(Heap, nodes, null);
              }
              if (validChildren(PreCallHeap, nodes, prevTemp) && (validChildren(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, nodes, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, nodes, prevTemp, segLength(PreCallHeap, nodes, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, null, 0) + 1))) {
                assume state(Heap, Mask);
                assume validChildren(Heap, nodes, null);
              }
              assume state(Heap, Mask);
              assume segSize(Heap, nodes, null) == segSize(PreCallHeap, nodes, prevTemp) + segSize(PreCallHeap, prevTemp, null);
              if (nodes != prevTemp) {
                assume state(Heap, Mask);
                assume segParent(Heap, nodes, null) == segParent(PreCallHeap, nodes, prevTemp);
              }
              if (prevTemp != null) {
                assume state(Heap, Mask);
                assume segParent(Heap, nodes, null) == segParent(PreCallHeap, prevTemp, null);
              }
              assume state(Heap, Mask);
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: oldTreeSize := treeSize(temp) -- BinomialHeap.vpr@584.3--584.41
        
        // -- Check definedness of treeSize(temp)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@584.27--584.41) [197993]"}
              NoPerm < perm ==> NoPerm < Mask[null, tree_1(temp_1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        oldTreeSize := treeSize(Heap, temp_1);
        assume state(Heap, Mask);
      
      // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@585.3--585.20
        assume tree#trigger(Heap, tree_1(temp_1));
        assume Heap[null, tree_1(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key_6]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@585.3--585.20) [197996]"}
            perm <= Mask[null, tree_1(temp_1)];
        }
        Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
        
        // -- Update version of predicate
          if (!HasDirectPerm(Mask, null, tree_1(temp_1))) {
            havoc newVersion;
            Heap := Heap[null, tree_1(temp_1):=newVersion];
          }
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, key_6:=Mask[temp_1, key_6] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
        assume state(Heap, Mask);
        assume 0 <= Heap[temp_1, degree];
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(tree_1(temp_1), Heap[null, tree_1(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
        if (0 < Heap[temp_1, degree]) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
        }
        assume state(Heap, Mask);
        assume validChildren(Heap, Heap[temp_1, child], null);
        if (Heap[temp_1, child] != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: temp := temp.child -- BinomialHeap.vpr@586.3--586.21
        
        // -- Check definedness of temp.child
          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@586.3--586.21) [198002]"}
            HasDirectPerm(Mask, temp_1, child);
        temp_1 := Heap[temp_1, child];
        assume state(Heap, Mask);
      
      // -- Translating statement: fakeNode := temp -- BinomialHeap.vpr@587.3--587.28
        fakeNode := temp_1;
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(fakeNode, temp), write) -- BinomialHeap.vpr@591.3--591.31
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (fakeNode != temp_1) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. There might be insufficient permission to access tree(fakeNode) (BinomialHeap.vpr@591.3--591.31) [198005]"}
              perm <= Mask[null, tree_1(fakeNode)];
          }
          Mask := Mask[null, tree_1(fakeNode):=Mask[null, tree_1(fakeNode)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(fakeNode, temp_1), Heap[null, heapseg(fakeNode, temp_1)], tree_1(fakeNode), Heap[null, tree_1(fakeNode)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. There might be insufficient permission to access fakeNode.sibling (BinomialHeap.vpr@591.3--591.31) [198007]"}
              perm <= Mask[fakeNode, sibling];
          }
          Mask := Mask[fakeNode, sibling:=Mask[fakeNode, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. There might be insufficient permission to access heapseg(fakeNode.sibling, temp) (BinomialHeap.vpr@591.3--591.31) [198009]"}
              perm <= Mask[null, heapseg(Heap[fakeNode, sibling], temp_1)];
          }
          Mask := Mask[null, heapseg(Heap[fakeNode, sibling], temp_1):=Mask[null, heapseg(Heap[fakeNode, sibling], temp_1)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(fakeNode, temp_1), Heap[null, heapseg(fakeNode, temp_1)], heapseg(Heap[fakeNode, sibling], temp_1), Heap[null, heapseg(Heap[fakeNode, sibling], temp_1)]);
          if (Heap[fakeNode, sibling] != temp_1) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. Assertion treeParent(fakeNode) == segParent(fakeNode.sibling, temp) might not hold. (BinomialHeap.vpr@591.3--591.31) [198010]"}
              treeParent(Heap, fakeNode) == segParent(Heap, Heap[fakeNode, sibling], temp_1);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(fakeNode, temp_1));
        assume Heap[null, heapseg(fakeNode, temp_1)] == FrameFragment((if fakeNode != temp_1 then CombineFrames(Heap[null, tree_1(fakeNode)], CombineFrames(FrameFragment(Heap[fakeNode, sibling]), CombineFrames(Heap[null, heapseg(Heap[fakeNode, sibling], temp_1)], FrameFragment((if Heap[fakeNode, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(fakeNode, temp_1))) {
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(fakeNode, temp_1):=freshVersion];
        }
        if (fakeNode != temp_1) {
          havoc newPMask;
          assume (forall <A, B> o_184: Ref, f_194: (Field A B) ::
            { newPMask[o_184, f_194] }
            Heap[null, heapseg#sm(fakeNode, temp_1)][o_184, f_194] || Heap[null, tree#sm(fakeNode)][o_184, f_194] ==> newPMask[o_184, f_194]
          );
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=newPMask];
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=Heap[null, heapseg#sm(fakeNode, temp_1)][fakeNode, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_185: Ref, f_195: (Field A B) ::
            { newPMask[o_185, f_195] }
            Heap[null, heapseg#sm(fakeNode, temp_1)][o_185, f_195] || Heap[null, heapseg#sm(Heap[fakeNode, sibling], temp_1)][o_185, f_195] ==> newPMask[o_185, f_195]
          );
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: while (temp != null) -- BinomialHeap.vpr@592.3--613.4
        
        // -- Before loop head
          
          // -- Exhale loop invariant before loop
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(fakeNode, temp), write) might not hold on entry. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@593.14--593.37) [198012]"}
                perm <= Mask[null, heapseg(fakeNode, temp_1)];
            }
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] - perm];
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp, null), write) might not hold on entry. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@594.14--594.33) [198013]"}
                perm <= Mask[null, heapseg(temp_1, null)];
            }
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
            assert {:msg "  Loop invariant validChildren(fakeNode, temp) might not hold on entry. Assertion validChildren(fakeNode, temp) might not hold. (BinomialHeap.vpr@595.14--595.43) [198014]"}
              validChildren(Heap, fakeNode, temp_1);
            assert {:msg "  Loop invariant validChildren(temp, null) might not hold on entry. Assertion validChildren(temp, null) might not hold. (BinomialHeap.vpr@596.14--596.39) [198015]"}
              validChildren(Heap, temp_1, null);
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assert {:msg "  Loop invariant 0 < segLength(fakeNode, temp) && 0 < segLength(temp, null) ==> segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not hold on entry. Assertion segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not hold. (BinomialHeap.vpr@597.14--598.95) [198016]"}
                segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            if (fakeNode != temp_1) {
              assert {:msg "  Loop invariant fakeNode != temp ==> segParent(fakeNode, temp) == null might not hold on entry. Assertion segParent(fakeNode, temp) == null might not hold. (BinomialHeap.vpr@599.14--599.68) [198017]"}
                segParent(Heap, fakeNode, temp_1) == null;
            }
            assert {:msg "  Loop invariant segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not hold on entry. Assertion segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not hold. (BinomialHeap.vpr@600.14--600.78) [198018]"}
              segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
        
        // -- Havoc loop written variables (except locals)
          havoc temp_1, prevTemp;
          assume Heap[temp_1, $allocated];
          assume Heap[prevTemp, $allocated];
        
        // -- Check definedness of invariant
          if (*) {
            perm := FullPerm;
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of validChildren(fakeNode, temp)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@595.14--595.43) [198019]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume validChildren(Heap, fakeNode, temp_1);
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of validChildren(temp, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@596.14--596.39) [198020]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume validChildren(Heap, temp_1, null);
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(fakeNode, temp) && 0 < segLength(temp, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@597.18--597.43) [198021]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (0 < segLength(Heap, fakeNode, temp_1)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@597.51--597.72) [198022]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              }
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@598.33--598.58) [198023]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@598.7--598.63) [198024]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(fakeNode, temp) - 1 might not hold. (BinomialHeap.vpr@598.7--598.63) [198025]"}
                    0 <= segLength(Heap, fakeNode, temp_1) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(fakeNode, temp) - 1 < segLength(fakeNode, temp) might not hold. (BinomialHeap.vpr@598.7--598.63) [198026]"}
                    segLength(Heap, fakeNode, temp_1) - 1 < segLength(Heap, fakeNode, temp_1);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@598.67--598.91) [198027]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp, null) might not hold. (BinomialHeap.vpr@598.67--598.91) [198028]"}
                    0 < segLength(Heap, temp_1, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            assume state(Heap, Mask);
            if (fakeNode != temp_1) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(fakeNode, temp) == null
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@599.35--599.60) [198029]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion fakeNode != temp might not hold. (BinomialHeap.vpr@599.35--599.60) [198030]"}
                    fakeNode != temp_1;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, fakeNode, temp_1) == null;
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@600.14--600.37) [198031]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@600.40--600.59) [198032]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            assume state(Heap, Mask);
            assume false;
          }
        
        // -- Check the loop body
          if (*) {
            // Reset state
            loopHeap := Heap;
            loopMask := Mask;
            Mask := ZeroMask;
            assume state(Heap, Mask);
            // Inhale invariant
            perm := FullPerm;
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume validChildren(Heap, fakeNode, temp_1);
            assume state(Heap, Mask);
            assume validChildren(Heap, temp_1, null);
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            if (fakeNode != temp_1) {
              assume state(Heap, Mask);
              assume segParent(Heap, fakeNode, temp_1) == null;
            }
            assume state(Heap, Mask);
            assume segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            assume state(Heap, Mask);
            // Check and assume guard
            assume temp_1 != null;
            assume state(Heap, Mask);
            
            // -- Translate loop body
              
              // -- Translating statement: unfold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@602.4--602.30
                assume heapseg#trigger(Heap, heapseg(temp_1, null));
                assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@602.4--602.30) [198033]"}
                    perm <= Mask[null, heapseg(temp_1, null)];
                }
                Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp_1, null):=newVersion];
                  }
                if (temp_1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp_1 != null;
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp_1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@603.4--603.21
                assume tree#trigger(Heap, tree_1(temp_1));
                assume Heap[null, tree_1(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key_6]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@603.4--603.21) [198034]"}
                    perm <= Mask[null, tree_1(temp_1)];
                }
                Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, tree_1(temp_1))) {
                    havoc newVersion;
                    Heap := Heap[null, tree_1(temp_1):=newVersion];
                  }
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, key_6:=Mask[temp_1, key_6] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
                assume state(Heap, Mask);
                assume 0 <= Heap[temp_1, degree];
                perm := FullPerm;
                Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(tree_1(temp_1), Heap[null, tree_1(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                if (0 < Heap[temp_1, degree]) {
                  assume state(Heap, Mask);
                  assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                }
                assume state(Heap, Mask);
                assume validChildren(Heap, Heap[temp_1, child], null);
                if (Heap[temp_1, child] != null) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: temp.parent := null -- BinomialHeap.vpr@604.4--604.23
                assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@604.4--604.23) [198035]"}
                  FullPerm == Mask[temp_1, parent];
                Heap := Heap[temp_1, parent:=null];
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(tree(temp), write) -- BinomialHeap.vpr@605.4--605.19
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.key (BinomialHeap.vpr@605.4--605.19) [198036]"}
                    perm <= Mask[temp_1, key_6];
                }
                Mask := Mask[temp_1, key_6:=Mask[temp_1, key_6] - perm];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@605.4--605.19) [198037]"}
                    perm <= Mask[temp_1, degree];
                }
                Mask := Mask[temp_1, degree:=Mask[temp_1, degree] - perm];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@605.4--605.19) [198038]"}
                    perm <= Mask[temp_1, child];
                }
                Mask := Mask[temp_1, child:=Mask[temp_1, child] - perm];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@605.4--605.19) [198039]"}
                    perm <= Mask[temp_1, parent];
                }
                Mask := Mask[temp_1, parent:=Mask[temp_1, parent] - perm];
                assert {:msg "  Folding tree(temp) might fail. Assertion 0 <= temp.degree might not hold. (BinomialHeap.vpr@605.4--605.19) [198040]"}
                  0 <= Heap[temp_1, degree];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access heapseg(temp.child, null) (BinomialHeap.vpr@605.4--605.19) [198041]"}
                    perm <= Mask[null, heapseg(Heap[temp_1, child], null)];
                }
                Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] - perm];
                
                // -- Record predicate instance information
                  assume InsidePredicate(tree_1(temp_1), Heap[null, tree_1(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                assert {:msg "  Folding tree(temp) might fail. Assertion temp.degree == segLength(temp.child, null) might not hold. (BinomialHeap.vpr@605.4--605.19) [198042]"}
                  Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                if (0 < Heap[temp_1, degree]) {
                  assert {:msg "  Folding tree(temp) might fail. Assertion segDegree(temp.child, null, 0) == temp.degree - 1 might not hold. (BinomialHeap.vpr@605.4--605.19) [198043]"}
                    segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                }
                assert {:msg "  Folding tree(temp) might fail. Assertion validChildren(temp.child, null) might not hold. (BinomialHeap.vpr@605.4--605.19) [198044]"}
                  validChildren(Heap, Heap[temp_1, child], null);
                if (Heap[temp_1, child] != null) {
                  assert {:msg "  Folding tree(temp) might fail. Assertion segParent(temp.child, null) == temp might not hold. (BinomialHeap.vpr@605.4--605.19) [198045]"}
                    segParent(Heap, Heap[temp_1, child], null) == temp_1;
                }
                perm := FullPerm;
                Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume tree#trigger(Heap, tree_1(temp_1));
                assume Heap[null, tree_1(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key_6]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                if (!HasDirectPerm(Mask, null, tree_1(temp_1))) {
                  Heap := Heap[null, tree#sm(temp_1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, tree_1(temp_1):=freshVersion];
                }
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, key_6:=true]];
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, degree:=true]];
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, child:=true]];
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, parent:=true]];
                havoc newPMask;
                assume (forall <A, B> o_186: Ref, f_196: (Field A B) ::
                  { newPMask[o_186, f_196] }
                  Heap[null, tree#sm(temp_1)][o_186, f_196] || Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_186, f_196] ==> newPMask[o_186, f_196]
                );
                Heap := Heap[null, tree#sm(temp_1):=newPMask];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: prevTemp := temp -- BinomialHeap.vpr@606.4--606.20
                prevTemp := temp_1;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp := temp.sibling -- BinomialHeap.vpr@607.4--607.24
                
                // -- Check definedness of temp.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@607.4--607.24) [198046]"}
                    HasDirectPerm(Mask, temp_1, sibling);
                temp_1 := Heap[temp_1, sibling];
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp, temp), write) -- BinomialHeap.vpr@608.4--608.28
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp_1 != temp_1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@608.4--608.28) [198047]"}
                      perm <= Mask[null, tree_1(temp_1)];
                  }
                  Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@608.4--608.28) [198048]"}
                      perm <= Mask[temp_1, sibling];
                  }
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access heapseg(temp.sibling, temp) (BinomialHeap.vpr@608.4--608.28) [198049]"}
                      perm <= Mask[null, heapseg(Heap[temp_1, sibling], temp_1)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], temp_1):=Mask[null, heapseg(Heap[temp_1, sibling], temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], heapseg(Heap[temp_1, sibling], temp_1), Heap[null, heapseg(Heap[temp_1, sibling], temp_1)]);
                  if (Heap[temp_1, sibling] != temp_1) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. Assertion treeParent(temp) == segParent(temp.sibling, temp) might not hold. (BinomialHeap.vpr@608.4--608.28) [198050]"}
                      treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], temp_1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, temp_1):=Mask[null, heapseg(temp_1, temp_1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp_1, temp_1));
                assume Heap[null, heapseg(temp_1, temp_1)] == FrameFragment((if temp_1 != temp_1 then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], temp_1)], FrameFragment((if Heap[temp_1, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp_1, temp_1))) {
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp_1, temp_1):=freshVersion];
                }
                if (temp_1 != temp_1) {
                  havoc newPMask;
                  assume (forall <A, B> o_187: Ref, f_197: (Field A B) ::
                    { newPMask[o_187, f_197] }
                    Heap[null, heapseg#sm(temp_1, temp_1)][o_187, f_197] || Heap[null, tree#sm(temp_1)][o_187, f_197] ==> newPMask[o_187, f_197]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=Heap[null, heapseg#sm(temp_1, temp_1)][temp_1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_188: Ref, f_198: (Field A B) ::
                    { newPMask[o_188, f_198] }
                    Heap[null, heapseg#sm(temp_1, temp_1)][o_188, f_198] || Heap[null, heapseg#sm(Heap[temp_1, sibling], temp_1)][o_188, f_198] ==> newPMask[o_188, f_198]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(prevTemp, temp), write) -- BinomialHeap.vpr@609.4--609.32
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (prevTemp != temp_1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@609.4--609.32) [198051]"}
                      perm <= Mask[null, tree_1(prevTemp)];
                  }
                  Mask := Mask[null, tree_1(prevTemp):=Mask[null, tree_1(prevTemp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], tree_1(prevTemp), Heap[null, tree_1(prevTemp)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@609.4--609.32) [198052]"}
                      perm <= Mask[prevTemp, sibling];
                  }
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, temp) (BinomialHeap.vpr@609.4--609.32) [198053]"}
                      perm <= Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)];
                  }
                  Mask := Mask[null, heapseg(Heap[prevTemp, sibling], temp_1):=Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], heapseg(Heap[prevTemp, sibling], temp_1), Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)]);
                  if (Heap[prevTemp, sibling] != temp_1) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, temp) might not hold. (BinomialHeap.vpr@609.4--609.32) [198054]"}
                      treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], temp_1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(prevTemp, temp_1));
                assume Heap[null, heapseg(prevTemp, temp_1)] == FrameFragment((if prevTemp != temp_1 then CombineFrames(Heap[null, tree_1(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)], FrameFragment((if Heap[prevTemp, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(prevTemp, temp_1))) {
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(prevTemp, temp_1):=freshVersion];
                }
                if (prevTemp != temp_1) {
                  havoc newPMask;
                  assume (forall <A, B> o_189: Ref, f_199: (Field A B) ::
                    { newPMask[o_189, f_199] }
                    Heap[null, heapseg#sm(prevTemp, temp_1)][o_189, f_199] || Heap[null, tree#sm(prevTemp)][o_189, f_199] ==> newPMask[o_189, f_199]
                  );
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=Heap[null, heapseg#sm(prevTemp, temp_1)][prevTemp, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_190: Ref, f_200: (Field A B) ::
                    { newPMask[o_190, f_200] }
                    Heap[null, heapseg#sm(prevTemp, temp_1)][o_190, f_200] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], temp_1)][o_190, f_200] ==> newPMask[o_190, f_200]
                  );
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: unfold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@610.4--610.30
                assume heapseg#trigger(Heap, heapseg(temp_1, null));
                assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@610.4--610.30) [198055]"}
                    perm <= Mask[null, heapseg(temp_1, null)];
                }
                Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp_1, null):=newVersion];
                  }
                if (temp_1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp_1 != null;
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp_1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: concat(fakeNode, prevTemp, temp) -- BinomialHeap.vpr@611.4--611.36
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(fakeNode, prevTemp) (BinomialHeap.vpr@611.4--611.36) [198056]"}
                      perm <= Mask[null, heapseg(fakeNode, prevTemp)];
                  }
                  Mask := Mask[null, heapseg(fakeNode, prevTemp):=Mask[null, heapseg(fakeNode, prevTemp)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, temp) (BinomialHeap.vpr@611.4--611.36) [198057]"}
                      perm <= Mask[null, heapseg(prevTemp, temp_1)];
                  }
                  Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] - perm];
                  if (temp_1 != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@611.4--611.36) [198058]"}
                        perm <= Mask[null, tree_1(temp_1)];
                    }
                    Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                  }
                  if (fakeNode != prevTemp && prevTemp != temp_1) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(fakeNode, prevTemp) == segParent(prevTemp, temp) might not hold. (BinomialHeap.vpr@611.4--611.36) [198059]"}
                      segParent(Heap, fakeNode, prevTemp) == segParent(Heap, prevTemp, temp_1);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, fakeNode, temp_1) == segLength(PreCallHeap, fakeNode, prevTemp) + segLength(PreCallHeap, prevTemp, temp_1);
                  assume state(Heap, Mask);
                  assume (forall i_4_1: int ::
                    { segDegree#frame(Heap[null, heapseg(fakeNode, temp_1)], fakeNode, temp_1, i_4_1) } { segDegree#frame(PreCallHeap[null, heapseg(fakeNode, prevTemp)], fakeNode, prevTemp, i_4_1) }
                    0 <= i_4_1 && i_4_1 < segLength(PreCallHeap, fakeNode, prevTemp) ==> segDegree(Heap, fakeNode, temp_1, i_4_1) == segDegree(PreCallHeap, fakeNode, prevTemp, i_4_1)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_5_1: int ::
                    { segDegree#frame(Heap[null, heapseg(fakeNode, temp_1)], fakeNode, temp_1, i_5_1) }
                    segLength(PreCallHeap, fakeNode, prevTemp) <= i_5_1 && i_5_1 < segLength(Heap, fakeNode, temp_1) ==> segDegree(Heap, fakeNode, temp_1, i_5_1) == segDegree(PreCallHeap, prevTemp, temp_1, i_5_1 - segLength(PreCallHeap, fakeNode, prevTemp))
                  );
                  if (temp_1 != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, temp_1) == treeDegree(PreCallHeap, temp_1);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, temp_1) == treeSize(PreCallHeap, temp_1);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp_1) == treeParent(PreCallHeap, temp_1);
                  }
                  if (sorted_1(PreCallHeap, fakeNode, prevTemp) && (sorted_1(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, fakeNode, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted_1(Heap, fakeNode, temp_1);
                  }
                  if (presorted(PreCallHeap, fakeNode, prevTemp) && (presorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, fakeNode, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, temp_1, 0) && ((2 <= segLength(PreCallHeap, fakeNode, prevTemp) && segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) == segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 2) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)) && (2 <= segLength(PreCallHeap, prevTemp, temp_1) && segDegree(PreCallHeap, prevTemp, temp_1, 0) == segDegree(PreCallHeap, prevTemp, temp_1, 1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, fakeNode, temp_1);
                  }
                  if (validChildren(PreCallHeap, fakeNode, prevTemp) && (validChildren(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, fakeNode, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, temp_1, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, fakeNode, temp_1);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, fakeNode, temp_1) == segSize(PreCallHeap, fakeNode, prevTemp) + segSize(PreCallHeap, prevTemp, temp_1);
                  if (fakeNode != prevTemp) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, fakeNode, temp_1) == segParent(PreCallHeap, fakeNode, prevTemp);
                  }
                  if (prevTemp != temp_1) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, fakeNode, temp_1) == segParent(PreCallHeap, prevTemp, temp_1);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@612.4--612.28
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp_1 != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@612.4--612.28) [198060]"}
                      perm <= Mask[null, tree_1(temp_1)];
                  }
                  Mask := Mask[null, tree_1(temp_1):=Mask[null, tree_1(temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree_1(temp_1), Heap[null, tree_1(temp_1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@612.4--612.28) [198061]"}
                      perm <= Mask[temp_1, sibling];
                  }
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp.sibling, null) (BinomialHeap.vpr@612.4--612.28) [198062]"}
                      perm <= Mask[null, heapseg(Heap[temp_1, sibling], null)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                  if (Heap[temp_1, sibling] != null) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. Assertion treeParent(temp) == segParent(temp.sibling, null) might not hold. (BinomialHeap.vpr@612.4--612.28) [198063]"}
                      treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp_1, null));
                assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree_1(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                  Heap := Heap[null, heapseg#sm(temp_1, null):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp_1, null):=freshVersion];
                }
                if (temp_1 != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_191: Ref, f_201: (Field A B) ::
                    { newPMask[o_191, f_201] }
                    Heap[null, heapseg#sm(temp_1, null)][o_191, f_201] || Heap[null, tree#sm(temp_1)][o_191, f_201] ==> newPMask[o_191, f_201]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp_1, null):=Heap[null, heapseg#sm(temp_1, null)][temp_1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_192: Ref, f_202: (Field A B) ::
                    { newPMask[o_192, f_202] }
                    Heap[null, heapseg#sm(temp_1, null)][o_192, f_202] || Heap[null, heapseg#sm(Heap[temp_1, sibling], null)][o_192, f_202] ==> newPMask[o_192, f_202]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            // Exhale invariant
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(fakeNode, temp), write) might not be preserved. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@593.14--593.37) [198064]"}
                perm <= Mask[null, heapseg(fakeNode, temp_1)];
            }
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] - perm];
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp, null), write) might not be preserved. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@594.14--594.33) [198065]"}
                perm <= Mask[null, heapseg(temp_1, null)];
            }
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
            assert {:msg "  Loop invariant validChildren(fakeNode, temp) might not be preserved. Assertion validChildren(fakeNode, temp) might not hold. (BinomialHeap.vpr@595.14--595.43) [198066]"}
              validChildren(Heap, fakeNode, temp_1);
            assert {:msg "  Loop invariant validChildren(temp, null) might not be preserved. Assertion validChildren(temp, null) might not hold. (BinomialHeap.vpr@596.14--596.39) [198067]"}
              validChildren(Heap, temp_1, null);
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assert {:msg "  Loop invariant 0 < segLength(fakeNode, temp) && 0 < segLength(temp, null) ==> segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not be preserved. Assertion segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not hold. (BinomialHeap.vpr@597.14--598.95) [198068]"}
                segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            if (fakeNode != temp_1) {
              assert {:msg "  Loop invariant fakeNode != temp ==> segParent(fakeNode, temp) == null might not be preserved. Assertion segParent(fakeNode, temp) == null might not hold. (BinomialHeap.vpr@599.14--599.68) [198069]"}
                segParent(Heap, fakeNode, temp_1) == null;
            }
            assert {:msg "  Loop invariant segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not be preserved. Assertion segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not hold. (BinomialHeap.vpr@600.14--600.78) [198070]"}
              segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Terminate execution
            assume false;
          }
        
        // -- Inhale loop invariant after loop, and assume guard
          assume !(temp_1 != null);
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume validChildren(Heap, fakeNode, temp_1);
          assume state(Heap, Mask);
          assume validChildren(Heap, temp_1, null);
          if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
          }
          if (fakeNode != temp_1) {
            assume state(Heap, Mask);
            assume segParent(Heap, fakeNode, temp_1) == null;
          }
          assume state(Heap, Mask);
          assume segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: if (this.Nodes == null && fakeNode == null) -- BinomialHeap.vpr@616.3--636.4
        
        // -- Check definedness of this.Nodes == null && fakeNode == null
          assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@616.6--616.47) [198071]"}
            HasDirectPerm(Mask, this, Nodes_1);
        if (Heap[this, Nodes_1] == null && fakeNode == null) {
          
          // -- Translating statement: this.size := 0 -- BinomialHeap.vpr@617.4--617.18
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@617.4--617.18) [198072]"}
              FullPerm == Mask[this, size_3];
            Heap := Heap[this, size_3:=0];
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: if (this.Nodes == null && fakeNode != null) -- BinomialHeap.vpr@619.4--635.5
            
            // -- Check definedness of this.Nodes == null && fakeNode != null
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@619.7--619.48) [198073]"}
                HasDirectPerm(Mask, this, Nodes_1);
            if (Heap[this, Nodes_1] == null && fakeNode != null) {
              
              // -- Translating statement: r := reverse2(fakeNode, null) -- BinomialHeap.vpr@622.5--622.34
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(fakeNode, null) (BinomialHeap.vpr@622.5--622.34) [198074]"}
                      perm <= Mask[null, heapseg(fakeNode, null)];
                  }
                  Mask := Mask[null, heapseg(fakeNode, null):=Mask[null, heapseg(fakeNode, null)] - perm];
                  assert {:msg "  The precondition of method reverse2 might not hold. Assertion validChildren(fakeNode, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [198075]"}
                    validChildren(Heap, fakeNode, null);
                  assert {:msg "  The precondition of method reverse2 might not hold. Assertion 0 < segLength(fakeNode, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [198076]"}
                    0 < segLength(Heap, fakeNode, null);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(null, null) (BinomialHeap.vpr@622.5--622.34) [198077]"}
                      perm <= Mask[null, heapseg(null, null)];
                  }
                  Mask := Mask[null, heapseg(null, null):=Mask[null, heapseg(null, null)] - perm];
                  assert {:msg "  The precondition of method reverse2 might not hold. Assertion sorted(null, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [198078]"}
                    sorted_1(Heap, null, null);
                  if (null != null) {
                    assert {:msg "  The precondition of method reverse2 might not hold. Assertion segDegree(fakeNode, null, 0) < segDegree(null, null, 0) might not hold. (BinomialHeap.vpr@622.5--622.34) [198079]"}
                      segDegree(Heap, fakeNode, null, 0) < segDegree(Heap, null, null, 0);
                  }
                  if (null != null) {
                    assert {:msg "  The precondition of method reverse2 might not hold. Assertion segParent(fakeNode, null) == segParent(null, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [198080]"}
                      segParent(Heap, fakeNode, null) == segParent(Heap, null, null);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Havocing target variables
                  havoc r_1;
                
                // -- Inhaling postcondition
                  assume r_1 != null;
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(r_1, null):=Mask[null, heapseg(r_1, null)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume sorted_1(Heap, r_1, null);
                  assume state(Heap, Mask);
                  assume segSize(Heap, r_1, null) == segSize(PreCallHeap, fakeNode, null) + segSize(PreCallHeap, null, null);
                  assume state(Heap, Mask);
                  assume segParent(Heap, r_1, null) == segParent(PreCallHeap, fakeNode, null);
                  assume state(Heap, Mask);
                assume Heap[r_1, $allocated];
                assume state(Heap, Mask);
              
              // -- Translating statement: this.Nodes := r -- BinomialHeap.vpr@623.5--623.20
                assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@623.5--623.20) [198081]"}
                  FullPerm == Mask[this, Nodes_1];
                Heap := Heap[this, Nodes_1:=r_1];
                assume state(Heap, Mask);
              
              // -- Translating statement: this.size := this.size - 1 -- BinomialHeap.vpr@624.5--624.31
                
                // -- Check definedness of this.size - 1
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@624.5--624.31) [198082]"}
                    HasDirectPerm(Mask, this, size_3);
                assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@624.5--624.31) [198083]"}
                  FullPerm == Mask[this, size_3];
                Heap := Heap[this, size_3:=Heap[this, size_3] - 1];
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: if (this.Nodes != null && fakeNode == null) -- BinomialHeap.vpr@626.5--634.6
                
                // -- Check definedness of this.Nodes != null && fakeNode == null
                  assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@626.8--626.49) [198084]"}
                    HasDirectPerm(Mask, this, Nodes_1);
                if (Heap[this, Nodes_1] != null && fakeNode == null) {
                  
                  // -- Translating statement: this.size := this.size - 1 -- BinomialHeap.vpr@628.6--628.32
                    
                    // -- Check definedness of this.size - 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@628.6--628.32) [198085]"}
                        HasDirectPerm(Mask, this, size_3);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@628.6--628.32) [198086]"}
                      FullPerm == Mask[this, size_3];
                    Heap := Heap[this, size_3:=Heap[this, size_3] - 1];
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: fold acc(heapseg(null, null), write) -- BinomialHeap.vpr@630.6--630.30
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (null != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(null, null) might fail. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@630.6--630.30) [198089]"}
                          perm <= Mask[null, tree_1(null)];
                      }
                      Mask := Mask[null, tree_1(null):=Mask[null, tree_1(null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(null, null), Heap[null, heapseg(null, null)], tree_1(null), Heap[null, tree_1(null)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(null, null) might fail. There might be insufficient permission to access null.sibling (BinomialHeap.vpr@630.6--630.30) [198091]"}
                          perm <= Mask[null, sibling];
                      }
                      Mask := Mask[null, sibling:=Mask[null, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(null, null) might fail. There might be insufficient permission to access heapseg(null.sibling, null) (BinomialHeap.vpr@630.6--630.30) [198093]"}
                          perm <= Mask[null, heapseg(Heap[null, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[null, sibling], null):=Mask[null, heapseg(Heap[null, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(null, null), Heap[null, heapseg(null, null)], heapseg(Heap[null, sibling], null), Heap[null, heapseg(Heap[null, sibling], null)]);
                      if (Heap[null, sibling] != null) {
                        assert {:msg "  Folding heapseg(null, null) might fail. Assertion treeParent(null) == segParent(null.sibling, null) might not hold. (BinomialHeap.vpr@630.6--630.30) [198094]"}
                          treeParent(Heap, null) == segParent(Heap, Heap[null, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(null, null):=Mask[null, heapseg(null, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(null, null));
                    assume Heap[null, heapseg(null, null)] == FrameFragment((if null != null then CombineFrames(Heap[null, tree_1(null)], CombineFrames(FrameFragment(Heap[null, sibling]), CombineFrames(Heap[null, heapseg(Heap[null, sibling], null)], FrameFragment((if Heap[null, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(null, null))) {
                      Heap := Heap[null, heapseg#sm(null, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(null, null):=freshVersion];
                    }
                    if (null != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_193: Ref, f_203: (Field A B) ::
                        { newPMask[o_193, f_203] }
                        Heap[null, heapseg#sm(null, null)][o_193, f_203] || Heap[null, tree#sm(null)][o_193, f_203] ==> newPMask[o_193, f_203]
                      );
                      Heap := Heap[null, heapseg#sm(null, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(null, null):=Heap[null, heapseg#sm(null, null)][null, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_194: Ref, f_204: (Field A B) ::
                        { newPMask[o_194, f_204] }
                        Heap[null, heapseg#sm(null, null)][o_194, f_204] || Heap[null, heapseg#sm(Heap[null, sibling], null)][o_194, f_204] ==> newPMask[o_194, f_204]
                      );
                      Heap := Heap[null, heapseg#sm(null, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: r := reverse2(fakeNode, null) -- BinomialHeap.vpr@631.6--631.35
                    PreCallHeap := Heap;
                    PreCallMask := Mask;
                    
                    // -- Exhaling precondition
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(fakeNode, null) (BinomialHeap.vpr@631.6--631.35) [198096]"}
                          perm <= Mask[null, heapseg(fakeNode, null)];
                      }
                      Mask := Mask[null, heapseg(fakeNode, null):=Mask[null, heapseg(fakeNode, null)] - perm];
                      assert {:msg "  The precondition of method reverse2 might not hold. Assertion validChildren(fakeNode, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [198097]"}
                        validChildren(Heap, fakeNode, null);
                      assert {:msg "  The precondition of method reverse2 might not hold. Assertion 0 < segLength(fakeNode, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [198098]"}
                        0 < segLength(Heap, fakeNode, null);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(null, null) (BinomialHeap.vpr@631.6--631.35) [198099]"}
                          perm <= Mask[null, heapseg(null, null)];
                      }
                      Mask := Mask[null, heapseg(null, null):=Mask[null, heapseg(null, null)] - perm];
                      assert {:msg "  The precondition of method reverse2 might not hold. Assertion sorted(null, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [198100]"}
                        sorted_1(Heap, null, null);
                      if (null != null) {
                        assert {:msg "  The precondition of method reverse2 might not hold. Assertion segDegree(fakeNode, null, 0) < segDegree(null, null, 0) might not hold. (BinomialHeap.vpr@631.6--631.35) [198101]"}
                          segDegree(Heap, fakeNode, null, 0) < segDegree(Heap, null, null, 0);
                      }
                      if (null != null) {
                        assert {:msg "  The precondition of method reverse2 might not hold. Assertion segParent(fakeNode, null) == segParent(null, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [198102]"}
                          segParent(Heap, fakeNode, null) == segParent(Heap, null, null);
                      }
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                    
                    // -- Havocing target variables
                      havoc r_1;
                    
                    // -- Inhaling postcondition
                      assume r_1 != null;
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(r_1, null):=Mask[null, heapseg(r_1, null)] + perm];
                      assume state(Heap, Mask);
                      assume state(Heap, Mask);
                      assume sorted_1(Heap, r_1, null);
                      assume state(Heap, Mask);
                      assume segSize(Heap, r_1, null) == segSize(PreCallHeap, fakeNode, null) + segSize(PreCallHeap, null, null);
                      assume state(Heap, Mask);
                      assume segParent(Heap, r_1, null) == segParent(PreCallHeap, fakeNode, null);
                      assume state(Heap, Mask);
                    assume Heap[r_1, $allocated];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unionNodes(this, r) -- BinomialHeap.vpr@632.6--632.25
                    PreCallHeap := Heap;
                    PreCallMask := Mask;
                    
                    // -- Exhaling precondition
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method unionNodes might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@632.6--632.25) [198103]"}
                          perm <= Mask[this, Nodes_1];
                      }
                      Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method unionNodes might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@632.6--632.25) [198104]"}
                          perm <= Mask[null, heapseg(Heap[this, Nodes_1], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] - perm];
                      assert {:msg "  The precondition of method unionNodes might not hold. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@632.6--632.25) [198105]"}
                        sorted_1(Heap, Heap[this, Nodes_1], null);
                      assert {:msg "  The precondition of method unionNodes might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@632.6--632.25) [198106]"}
                        Heap[this, Nodes_1] != null;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method unionNodes might not hold. There might be insufficient permission to access heapseg(r, null) (BinomialHeap.vpr@632.6--632.25) [198107]"}
                          perm <= Mask[null, heapseg(r_1, null)];
                      }
                      Mask := Mask[null, heapseg(r_1, null):=Mask[null, heapseg(r_1, null)] - perm];
                      assert {:msg "  The precondition of method unionNodes might not hold. Assertion sorted(r, null) might not hold. (BinomialHeap.vpr@632.6--632.25) [198108]"}
                        sorted_1(Heap, r_1, null);
                      if (r_1 != null) {
                        assert {:msg "  The precondition of method unionNodes might not hold. Assertion segParent(this.Nodes, null) == segParent(r, null) might not hold. (BinomialHeap.vpr@632.6--632.25) [198109]"}
                          segParent(Heap, Heap[this, Nodes_1], null) == segParent(Heap, r_1, null);
                      }
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                    
                    // -- Inhaling postcondition
                      perm := FullPerm;
                      assume this != null;
                      Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] + perm];
                      assume state(Heap, Mask);
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] + perm];
                      assume state(Heap, Mask);
                      assume state(Heap, Mask);
                      assume sorted_1(Heap, Heap[this, Nodes_1], null);
                      assume Heap[this, Nodes_1] != null;
                      assume state(Heap, Mask);
                      assume segSize(Heap, Heap[this, Nodes_1], null) == segSize(PreCallHeap, PreCallHeap[this, Nodes_1], null) + segSize(PreCallHeap, r_1, null);
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[this, Nodes_1], null) == segParent(PreCallHeap, PreCallHeap[this, Nodes_1], null);
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: this.size := this.size - 1 -- BinomialHeap.vpr@633.6--633.32
                    
                    // -- Check definedness of this.size - 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@633.6--633.32) [198110]"}
                        HasDirectPerm(Mask, this, size_3);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@633.6--633.32) [198111]"}
                      FullPerm == Mask[this, size_3];
                    Heap := Heap[this, size_3:=Heap[this, size_3] - 1];
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: res := minNode -- BinomialHeap.vpr@638.3--638.17
        res := minNode;
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heap(this), write) -- BinomialHeap.vpr@640.2--640.17
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Folding heap(this) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@640.2--640.17) [198114]"}
        perm <= Mask[this, Nodes_1];
    }
    Mask := Mask[this, Nodes_1:=Mask[this, Nodes_1] - perm];
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Folding heap(this) might fail. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@640.2--640.17) [198116]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes_1], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes_1], null):=Mask[null, heapseg(Heap[this, Nodes_1], null)] - perm];
    
    // -- Record predicate instance information
      assume InsidePredicate(heap_1(this), Heap[null, heap_1(this)], heapseg(Heap[this, Nodes_1], null), Heap[null, heapseg(Heap[this, Nodes_1], null)]);
    assert {:msg "  Folding heap(this) might fail. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@640.2--640.17) [198117]"}
      sorted_1(Heap, Heap[this, Nodes_1], null);
    if (Heap[this, Nodes_1] != null) {
      assert {:msg "  Folding heap(this) might fail. Assertion segParent(this.Nodes, null) == null might not hold. (BinomialHeap.vpr@640.2--640.17) [198118]"}
        segParent(Heap, Heap[this, Nodes_1], null) == null;
    }
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Folding heap(this) might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@640.2--640.17) [198120]"}
        perm <= Mask[this, size_3];
    }
    Mask := Mask[this, size_3:=Mask[this, size_3] - perm];
    assert {:msg "  Folding heap(this) might fail. Assertion this.size == segSize(this.Nodes, null) might not hold. (BinomialHeap.vpr@640.2--640.17) [198121]"}
      Heap[this, size_3] == segSize(Heap, Heap[this, Nodes_1], null);
    perm := FullPerm;
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heap#trigger(Heap, heap_1(this));
    assume Heap[null, heap_1(this)] == CombineFrames(FrameFragment(Heap[this, Nodes_1]), CombineFrames(Heap[null, heapseg(Heap[this, Nodes_1], null)], CombineFrames(FrameFragment((if Heap[this, Nodes_1] != null then EmptyFrame else EmptyFrame)), FrameFragment(Heap[this, size_3]))));
    if (!HasDirectPerm(Mask, null, heap_1(this))) {
      Heap := Heap[null, heap#sm(this):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heap_1(this):=freshVersion];
    }
    Heap := Heap[null, heap#sm(this):=Heap[null, heap#sm(this)][this, Nodes_1:=true]];
    havoc newPMask;
    assume (forall <A, B> o_195: Ref, f_205: (Field A B) ::
      { newPMask[o_195, f_205] }
      Heap[null, heap#sm(this)][o_195, f_205] || Heap[null, heapseg#sm(Heap[this, Nodes_1], null)][o_195, f_205] ==> newPMask[o_195, f_205]
    );
    Heap := Heap[null, heap#sm(this):=newPMask];
    Heap := Heap[null, heap#sm(this):=Heap[null, heap#sm(this)][this, size_3:=true]];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of extractMin might not hold. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@530.10--530.20) [198123]"}
        perm <= Mask[null, heap_1(this)];
    }
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] - perm];
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}