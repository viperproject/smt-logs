// 
// Translation of Viper program.
// 
// Date:         2024-12-26 19:54:10
// Tool:         carbon 1.0
// Arguments: :  --disableCaching --boogieExe /home/runner/.dotnet/tools/boogie --timeout 10 --print /home/runner/work/smt-logs/smt-logs/carbon/../smt2/carbon/silver/src/test/resources/transformations/Performance/BinomialHeap.bpl --boogieOpt /proverLog:/home/runner/work/smt-logs/smt-logs/carbon/../smt2/carbon/silver/src/test/resources/transformations/Performance/BinomialHeap-@PROC@.smt2 --ignoreFile dummy-file-to-prevent-cli-parser-from-complaining-about-missing-file-name.silver
// Dependencies:
//   Boogie , located at /home/runner/.dotnet/tools/boogie.
//   Z3 4.12.1 - 64 bit, located at /opt/hostedtoolcache/z3/4.12.1/x64/z3-4.12.1-x64-glibc-2.35/bin/z3.
// 

// ==================================================
// Preamble of State module.
// ==================================================

function  state(Heap: HeapType, Mask: MaskType): bool;
axiom state(dummyHeap, ZeroMask);

// ==================================================
// Preamble of Heap module.
// ==================================================

type Ref;
var Heap: HeapType;
const null: Ref;
type Field A B;
type NormalField;
const dummyHeap: HeapType;
type HeapType = <A, B> [Ref, Field A B]B;
const unique $allocated: Field NormalField bool;
axiom (forall o_74: Ref, f_82: (Field NormalField Ref), Heap: HeapType ::
  { Heap[o_74, f_82] }
  Heap[o_74, $allocated] ==> Heap[Heap[o_74, f_82], $allocated]
);
function  succHeap(Heap0: HeapType, Heap1: HeapType): bool;
function  succHeapTrans(Heap0: HeapType, Heap1: HeapType): bool;
function  IdenticalOnKnownLocations(Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType): bool;
function  IsPredicateField<A, B>(f_1: (Field A B)): bool;
function  IsWandField<A, B>(f_1: (Field A B)): bool;
function  getPredWandId<A, B>(f_1: (Field A B)): int;
// Frame all locations with direct permissions
axiom (forall <A, B> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, o_75: Ref, f_83: (Field A B) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), ExhaleHeap[o_75, f_83] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, o_75, f_83) ==> Heap[o_75, f_83] == ExhaleHeap[o_75, f_83]
);
// Frame all predicate mask locations of predicates with direct permission
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_41: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsPredicateField(pm_f_41), ExhaleHeap[null, PredicateMaskField(pm_f_41)] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_41) && IsPredicateField(pm_f_41) ==> Heap[null, PredicateMaskField(pm_f_41)] == ExhaleHeap[null, PredicateMaskField(pm_f_41)]
);
// Frame all locations with known folded permissions
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_41: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsPredicateField(pm_f_41) }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_41) && IsPredicateField(pm_f_41) ==> (forall <A, B> o2_41: Ref, f_83: (Field A B) ::
    { ExhaleHeap[o2_41, f_83] }
    Heap[null, PredicateMaskField(pm_f_41)][o2_41, f_83] ==> Heap[o2_41, f_83] == ExhaleHeap[o2_41, f_83]
  )
);
// Frame all wand mask locations of wands with direct permission
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_41: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsWandField(pm_f_41), ExhaleHeap[null, WandMaskField(pm_f_41)] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_41) && IsWandField(pm_f_41) ==> Heap[null, WandMaskField(pm_f_41)] == ExhaleHeap[null, WandMaskField(pm_f_41)]
);
// Frame all locations in the footprint of magic wands
axiom (forall <C> Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, pm_f_41: (Field C FrameType) ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), IsWandField(pm_f_41) }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> HasDirectPerm(Mask, null, pm_f_41) && IsWandField(pm_f_41) ==> (forall <A, B> o2_41: Ref, f_83: (Field A B) ::
    { ExhaleHeap[o2_41, f_83] }
    Heap[null, WandMaskField(pm_f_41)][o2_41, f_83] ==> Heap[o2_41, f_83] == ExhaleHeap[o2_41, f_83]
  )
);
// All previously-allocated references are still allocated
axiom (forall Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType, o_75: Ref ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask), ExhaleHeap[o_75, $allocated] }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> Heap[o_75, $allocated] ==> ExhaleHeap[o_75, $allocated]
);
// Updated Heaps are Successor Heaps
axiom (forall <A, B> Heap: HeapType, o_74: Ref, f_84: (Field A B), v: B ::
  { Heap[o_74, f_84:=v] }
  succHeap(Heap, Heap[o_74, f_84:=v])
);
// IdenticalOnKnownLocations Heaps are Successor Heaps
axiom (forall Heap: HeapType, ExhaleHeap: HeapType, Mask: MaskType ::
  { IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) }
  IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask) ==> succHeap(Heap, ExhaleHeap)
);
// Successor Heaps are Transitive Successor Heaps
axiom (forall Heap0: HeapType, Heap1: HeapType ::
  { succHeap(Heap0, Heap1) }
  succHeap(Heap0, Heap1) ==> succHeapTrans(Heap0, Heap1)
);
// Transitivity of Transitive Successor Heaps
axiom (forall Heap0: HeapType, Heap1: HeapType, Heap2: HeapType ::
  { succHeapTrans(Heap0, Heap1), succHeap(Heap1, Heap2) }
  succHeapTrans(Heap0, Heap1) && succHeap(Heap1, Heap2) ==> succHeapTrans(Heap0, Heap2)
);

// ==================================================
// Preamble of Permission module.
// ==================================================

type Perm = real;
type MaskType = <A, B> [Ref, Field A B]Perm;
var Mask: MaskType;
const ZeroMask: MaskType;
axiom (forall <A, B> o_2: Ref, f_4: (Field A B) ::
  { ZeroMask[o_2, f_4] }
  ZeroMask[o_2, f_4] == NoPerm
);
type PMaskType = <A, B> [Ref, Field A B]bool;
const ZeroPMask: PMaskType;
axiom (forall <A, B> o_2: Ref, f_4: (Field A B) ::
  { ZeroPMask[o_2, f_4] }
  !ZeroPMask[o_2, f_4]
);
function  PredicateMaskField<A>(f_5: (Field A FrameType)): Field A PMaskType;
function  WandMaskField<A>(f_5: (Field A FrameType)): Field A PMaskType;
const NoPerm: Perm;
axiom NoPerm == 0.000000000;
const FullPerm: Perm;
axiom FullPerm == 1.000000000;
function  Perm(a: real, b: real): Perm;
const AssumePermUpperBound: bool;
function  GoodMask(Mask: MaskType): bool;
axiom (forall Heap: HeapType, Mask: MaskType ::
  { state(Heap, Mask) }
  state(Heap, Mask) ==> GoodMask(Mask)
);
axiom (forall <A, B> Mask: MaskType, o_2: Ref, f_4: (Field A B) ::
  { GoodMask(Mask), Mask[o_2, f_4] }
  GoodMask(Mask) ==> Mask[o_2, f_4] >= NoPerm && (((GoodMask(Mask) && AssumePermUpperBound) && !IsPredicateField(f_4)) && !IsWandField(f_4) ==> Mask[o_2, f_4] <= FullPerm)
);
function  HasDirectPerm<A, B>(Mask: MaskType, o_2: Ref, f_4: (Field A B)): bool;
axiom (forall <A, B> Mask: MaskType, o_2: Ref, f_4: (Field A B) ::
  { HasDirectPerm(Mask, o_2, f_4) }
  HasDirectPerm(Mask, o_2, f_4) <==> Mask[o_2, f_4] > NoPerm
);
function  sumMask(ResultMask: MaskType, SummandMask1: MaskType, SummandMask2: MaskType): bool;
axiom (forall <A, B> ResultMask: MaskType, SummandMask1: MaskType, SummandMask2: MaskType, o_2: Ref, f_4: (Field A B) ::
  { sumMask(ResultMask, SummandMask1, SummandMask2), ResultMask[o_2, f_4] } { sumMask(ResultMask, SummandMask1, SummandMask2), SummandMask1[o_2, f_4] } { sumMask(ResultMask, SummandMask1, SummandMask2), SummandMask2[o_2, f_4] }
  sumMask(ResultMask, SummandMask1, SummandMask2) ==> ResultMask[o_2, f_4] == SummandMask1[o_2, f_4] + SummandMask2[o_2, f_4]
);

// ==================================================
// Preamble of Function and predicate module.
// ==================================================

// Function heights (higher height means its body is available earlier):
// - height 9: treeDegree
// - height 8: segLength
// - height 7: segDegree
// - height 6: treeParent
// - height 5: presorted
// - height 4: segParent
// - height 3: sorted
// - height 2: treeKey
// - height 1: validChildren
// - height 0: treeSize, segSize
const AssumeFunctionsAbove: int;
// Declarations for function framing
type FrameType;
const EmptyFrame: FrameType;
function  FrameFragment<T>(t: T): FrameType;
function  ConditionalFrame(p: Perm, f_6: FrameType): FrameType;
function  dummyFunction<T>(t: T): bool;
function  CombineFrames(a_1: FrameType, b_1: FrameType): FrameType;
// ==================================================
// Definition of conditional frame fragments
// ==================================================

axiom (forall p: Perm, f_6: FrameType ::
  { ConditionalFrame(p, f_6) }
  ConditionalFrame(p, f_6) == (if p > 0.000000000 then f_6 else EmptyFrame)
);
// Function for recording enclosure of one predicate instance in another
function  InsidePredicate<A, B>(p: (Field A FrameType), v_1: FrameType, q: (Field B FrameType), w: FrameType): bool;
// Transitivity of InsidePredicate
axiom (forall <A, B, C> p: (Field A FrameType), v_1: FrameType, q: (Field B FrameType), w: FrameType, r: (Field C FrameType), u: FrameType ::
  { InsidePredicate(p, v_1, q, w), InsidePredicate(q, w, r, u) }
  InsidePredicate(p, v_1, q, w) && InsidePredicate(q, w, r, u) ==> InsidePredicate(p, v_1, r, u)
);
// Knowledge that two identical instances of the same predicate cannot be inside each other
axiom (forall <A> p: (Field A FrameType), v_1: FrameType, w: FrameType ::
  { InsidePredicate(p, v_1, p, w) }
  !InsidePredicate(p, v_1, p, w)
);

// ==================================================
// Translation of all fields
// ==================================================

const unique key: Field NormalField int;
axiom !IsPredicateField(key);
axiom !IsWandField(key);
const unique degree: Field NormalField int;
axiom !IsPredicateField(degree);
axiom !IsWandField(degree);
const unique parent: Field NormalField Ref;
axiom !IsPredicateField(parent);
axiom !IsWandField(parent);
const unique sibling: Field NormalField Ref;
axiom !IsPredicateField(sibling);
axiom !IsWandField(sibling);
const unique child: Field NormalField Ref;
axiom !IsPredicateField(child);
axiom !IsWandField(child);
const unique Nodes: Field NormalField Ref;
axiom !IsPredicateField(Nodes);
axiom !IsWandField(Nodes);
const unique size: Field NormalField int;
axiom !IsPredicateField(size);
axiom !IsWandField(size);

// ==================================================
// Translation of function treeKey
// ==================================================

// Uninterpreted function definitions
function  treeKey(Heap: HeapType, this: Ref): int;
function  treeKey'(Heap: HeapType, this: Ref): int;
axiom (forall Heap: HeapType, this: Ref ::
  { treeKey(Heap, this) }
  treeKey(Heap, this) == treeKey'(Heap, this) && dummyFunction(treeKey#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeKey'(Heap, this) }
  dummyFunction(treeKey#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeKey(Heap, this) } { state(Heap, Mask), treeKey#triggerStateless(this), tree#trigger(Heap, tree(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 2 ==> treeKey(Heap, this) == Heap[this, key]
);

// Framing axioms
function  treeKey#frame(frame: FrameType, this: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeKey'(Heap, this) }
  state(Heap, Mask) ==> treeKey'(Heap, this) == treeKey#frame(Heap[null, tree(this)], this)
);

// Trigger function (controlling recursive postconditions)
function  treeKey#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeKey#triggerStateless(this: Ref): int;

// Check contract well-formedness and postcondition
procedure treeKey#definedness(this: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 2;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree(this):=Mask[null, tree(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in this.key)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree(this));
      assume UnfoldingHeap[null, tree(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@32.1--36.2) [100101]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key:=UnfoldingMask[this, key] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree(this), UnfoldingHeap[null, tree(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.key (BinomialHeap.vpr@32.1--36.2) [100102]"}
        HasDirectPerm(UnfoldingMask, this, key);
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_15: Ref, f_20: (Field A B) ::
          { newPMask[o_15, f_20] }
          Heap[null, tree#sm(this)][o_15, f_20] || Heap[null, heapseg#sm(Heap[this, child], null)][o_15, f_20] ==> newPMask[o_15, f_20]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := Heap[this, key];
}

// ==================================================
// Translation of function treeDegree
// ==================================================

// Uninterpreted function definitions
function  treeDegree(Heap: HeapType, this: Ref): int;
function  treeDegree'(Heap: HeapType, this: Ref): int;
axiom (forall Heap: HeapType, this: Ref ::
  { treeDegree(Heap, this) }
  treeDegree(Heap, this) == treeDegree'(Heap, this) && dummyFunction(treeDegree#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeDegree'(Heap, this) }
  dummyFunction(treeDegree#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeDegree(Heap, this) } { state(Heap, Mask), treeDegree#triggerStateless(this), tree#trigger(Heap, tree(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 9 ==> treeDegree(Heap, this) == Heap[this, degree]
);

// Framing axioms
function  treeDegree#frame(frame: FrameType, this: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeDegree'(Heap, this) }
  state(Heap, Mask) ==> treeDegree'(Heap, this) == treeDegree#frame(Heap[null, tree(this)], this)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeDegree'(Heap, this) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 9 || treeDegree#trigger(Heap[null, tree(this)], this)) ==> 0 <= treeDegree'(Heap, this)
);

// Trigger function (controlling recursive postconditions)
function  treeDegree#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeDegree#triggerStateless(this: Ref): int;

// Check contract well-formedness and postcondition
procedure treeDegree#definedness(this: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 9;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree(this):=Mask[null, tree(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in this.degree)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree(this));
      assume UnfoldingHeap[null, tree(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@38.1--43.2) [100103]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key:=UnfoldingMask[this, key] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree(this), UnfoldingHeap[null, tree(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@38.1--43.2) [100104]"}
        HasDirectPerm(UnfoldingMask, this, degree);
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_16: Ref, f_21: (Field A B) ::
          { newPMask[o_16, f_21] }
          Heap[null, tree#sm(this)][o_16, f_21] || Heap[null, heapseg#sm(Heap[this, child], null)][o_16, f_21] ==> newPMask[o_16, f_21]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := Heap[this, degree];
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of treeDegree might not hold. Assertion 0 <= result might not hold. (BinomialHeap.vpr@40.10--40.21) [100105]"}
      0 <= Result;
}

// ==================================================
// Translation of function treeSize
// ==================================================

// Uninterpreted function definitions
function  treeSize(Heap: HeapType, this: Ref): int;
function  treeSize'(Heap: HeapType, this: Ref): int;
axiom (forall Heap: HeapType, this: Ref ::
  { treeSize(Heap, this) }
  treeSize(Heap, this) == treeSize'(Heap, this) && dummyFunction(treeSize#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeSize'(Heap, this) }
  dummyFunction(treeSize#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeSize(Heap, this) } { state(Heap, Mask), treeSize#triggerStateless(this), tree#trigger(Heap, tree(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 0 ==> treeSize(Heap, this) == (if Heap[this, degree] == 0 then 1 else 1 + segSize'(Heap, Heap[this, child], null))
);

// Framing axioms
function  treeSize#frame(frame: FrameType, this: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeSize'(Heap, this) } { state(Heap, Mask), treeSize#triggerStateless(this), tree#trigger(Heap, tree(this)) }
  state(Heap, Mask) ==> treeSize'(Heap, this) == treeSize#frame(Heap[null, tree(this)], this)
);

// Trigger function (controlling recursive postconditions)
function  treeSize#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeSize#triggerStateless(this: Ref): int;

// Check contract well-formedness and postcondition
procedure treeSize#definedness(this: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 0;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree(this):=Mask[null, tree(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in (this.degree == 0 ? 1 : 1 + segSize(this.child, null)))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree(this));
      assume UnfoldingHeap[null, tree(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@45.1--49.2) [100106]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key:=UnfoldingMask[this, key] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree(this), UnfoldingHeap[null, tree(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@45.1--49.2) [100107]"}
        HasDirectPerm(UnfoldingMask, this, degree);
      if (UnfoldingHeap[this, degree] == 0) {
      } else {
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@45.1--49.2) [100108]"}
          HasDirectPerm(UnfoldingMask, this, child);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@48.52--48.77) [100109]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      }
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_52: Ref, f_55: (Field A B) ::
          { newPMask[o_52, f_55] }
          Heap[null, tree#sm(this)][o_52, f_55] || Heap[null, heapseg#sm(Heap[this, child], null)][o_52, f_55] ==> newPMask[o_52, f_55]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := (if Heap[this, degree] == 0 then 1 else 1 + segSize(Heap, Heap[this, child], null));
}

// ==================================================
// Translation of function treeParent
// ==================================================

// Uninterpreted function definitions
function  treeParent(Heap: HeapType, this: Ref): Ref;
function  treeParent'(Heap: HeapType, this: Ref): Ref;
axiom (forall Heap: HeapType, this: Ref ::
  { treeParent(Heap, this) }
  treeParent(Heap, this) == treeParent'(Heap, this) && dummyFunction(treeParent#triggerStateless(this))
);
axiom (forall Heap: HeapType, this: Ref ::
  { treeParent'(Heap, this) }
  dummyFunction(treeParent#triggerStateless(this))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeParent(Heap, this) } { state(Heap, Mask), treeParent#triggerStateless(this), tree#trigger(Heap, tree(this)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 6 ==> treeParent(Heap, this) == Heap[this, parent]
);

// Framing axioms
function  treeParent#frame(frame: FrameType, this: Ref): Ref;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref ::
  { state(Heap, Mask), treeParent'(Heap, this) }
  state(Heap, Mask) ==> treeParent'(Heap, this) == treeParent#frame(Heap[null, tree(this)], this)
);

// Trigger function (controlling recursive postconditions)
function  treeParent#trigger(frame: FrameType, this: Ref): bool;

// State-independent trigger function
function  treeParent#triggerStateless(this: Ref): Ref;

// Check contract well-formedness and postcondition
procedure treeParent#definedness(this: Ref) returns (Result: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume AssumeFunctionsAbove == 6;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, tree(this):=Mask[null, tree(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(tree(this), write) in this.parent)
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume tree#trigger(UnfoldingHeap, tree(this));
      assume UnfoldingHeap[null, tree(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, key]), CombineFrames(FrameFragment(UnfoldingHeap[this, degree]), CombineFrames(FrameFragment(UnfoldingHeap[this, child]), CombineFrames(FrameFragment(UnfoldingHeap[this, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[this, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[this, child] != null then EmptyFrame else EmptyFrame))))))));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@51.1--55.2) [100110]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, key:=UnfoldingMask[this, key] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, degree:=UnfoldingMask[this, degree] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, child:=UnfoldingMask[this, child] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      perm := FullPerm;
      assume this != null;
      UnfoldingMask := UnfoldingMask[this, parent:=UnfoldingMask[this, parent] + perm];
      assume state(UnfoldingHeap, UnfoldingMask);
      assume 0 <= UnfoldingHeap[this, degree];
      perm := FullPerm;
      UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, child], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(tree(this), UnfoldingHeap[null, tree(this)], heapseg(UnfoldingHeap[this, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, child], null)]);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume state(UnfoldingHeap, UnfoldingMask);
      assume UnfoldingHeap[this, degree] == segLength(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (0 < UnfoldingHeap[this, degree]) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segDegree(UnfoldingHeap, UnfoldingHeap[this, child], null, 0) == UnfoldingHeap[this, degree] - 1;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assume validChildren(UnfoldingHeap, UnfoldingHeap[this, child], null);
      if (UnfoldingHeap[this, child] != null) {
        assume state(UnfoldingHeap, UnfoldingMask);
        assume segParent(UnfoldingHeap, UnfoldingHeap[this, child], null) == this;
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.parent (BinomialHeap.vpr@51.1--55.2) [100111]"}
        HasDirectPerm(UnfoldingMask, this, parent);
      
      // -- Free assumptions (exp module)
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, key:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, degree:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, child:=true]];
        Heap := Heap[null, tree#sm(this):=Heap[null, tree#sm(this)][this, parent:=true]];
        havoc newPMask;
        assume (forall <A, B> o_53: Ref, f_56: (Field A B) ::
          { newPMask[o_53, f_56] }
          Heap[null, tree#sm(this)][o_53, f_56] || Heap[null, heapseg#sm(Heap[this, child], null)][o_53, f_56] ==> newPMask[o_53, f_56]
        );
        Heap := Heap[null, tree#sm(this):=newPMask];
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := Heap[this, parent];
}

// ==================================================
// Translation of function segLength
// ==================================================

// Uninterpreted function definitions
function  segLength(Heap: HeapType, this: Ref, last: Ref): int;
function  segLength'(Heap: HeapType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segLength(Heap, this, last) }
  segLength(Heap, this, last) == segLength'(Heap, this, last) && dummyFunction(segLength#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segLength'(Heap, this, last) }
  dummyFunction(segLength#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segLength(Heap, this, last) } { state(Heap, Mask), segLength#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 8 ==> segLength(Heap, this, last) == (if this == last then 0 else 1 + segLength'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  segLength#frame(frame: FrameType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segLength'(Heap, this, last) } { state(Heap, Mask), segLength#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segLength'(Heap, this, last) == segLength#frame(Heap[null, heapseg(this, last)], this, last)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segLength'(Heap, this, last) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 8 || segLength#trigger(Heap[null, heapseg(this, last)], this, last)) ==> 0 <= segLength'(Heap, this, last)
);

// Trigger function (controlling recursive postconditions)
function  segLength#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  segLength#triggerStateless(this: Ref, last: Ref): int;

// Check contract well-formedness and postcondition
procedure segLength#definedness(this: Ref, last: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 8;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (this == last ? 0 : 1 + (unfolding acc(heapseg(this, last), write) in segLength(this.sibling, last)))
      if (this == last) {
      } else {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@64.1--69.2) [100112]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree(this):=UnfoldingMask[null, tree(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree(this), UnfoldingHeap[null, tree(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@64.1--69.2) [100113]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@68.57--68.86) [100114]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        } else {
          // Enable postcondition for recursive call
          assume segLength#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_26: Ref, f_29: (Field A B) ::
              { newPMask[o_26, f_29] }
              Heap[null, heapseg#sm(this, last)][o_26, f_29] || Heap[null, tree#sm(this)][o_26, f_29] ==> newPMask[o_26, f_29]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o: Ref, f_85: (Field A B) ::
              { newPMask[o, f_85] }
              Heap[null, heapseg#sm(this, last)][o, f_85] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o, f_85] ==> newPMask[o, f_85]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_11: Ref, f_3: (Field A B) ::
              { newPMask[o_11, f_3] }
              Heap[null, heapseg#sm(this, last)][o_11, f_3] || Heap[null, tree#sm(this)][o_11, f_3] ==> newPMask[o_11, f_3]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_35: Ref, f_17: (Field A B) ::
              { newPMask[o_35, f_17] }
              Heap[null, heapseg#sm(this, last)][o_35, f_17] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_35, f_17] ==> newPMask[o_35, f_17]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := (if this == last then 0 else 1 + segLength(Heap, Heap[this, sibling], last));
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of segLength might not hold. Assertion 0 <= result might not hold. (BinomialHeap.vpr@66.10--66.21) [100115]"}
      0 <= Result;
}

// ==================================================
// Translation of function segSize
// ==================================================

// Uninterpreted function definitions
function  segSize(Heap: HeapType, this: Ref, last: Ref): int;
function  segSize'(Heap: HeapType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segSize(Heap, this, last) }
  segSize(Heap, this, last) == segSize'(Heap, this, last) && dummyFunction(segSize#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segSize'(Heap, this, last) }
  dummyFunction(segSize#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segSize(Heap, this, last) } { state(Heap, Mask), segSize#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 0 ==> segSize(Heap, this, last) == (if this == last then 0 else treeSize'(Heap, this) + segSize'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  segSize#frame(frame: FrameType, this: Ref, last: Ref): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segSize'(Heap, this, last) } { state(Heap, Mask), segSize#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segSize'(Heap, this, last) == segSize#frame(Heap[null, heapseg(this, last)], this, last)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segSize'(Heap, this, last) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 0 || segSize#trigger(Heap[null, heapseg(this, last)], this, last)) ==> this == last ==> segSize'(Heap, this, last) == 0
);

// Trigger function (controlling recursive postconditions)
function  segSize#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  segSize#triggerStateless(this: Ref, last: Ref): int;

// Check contract well-formedness and postcondition
procedure segSize#definedness(this: Ref, last: Ref) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 0;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (this == last ? 0 : (unfolding acc(heapseg(this, last), write) in treeSize(this) + segSize(this.sibling, last)))
      if (this == last) {
      } else {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@71.1--76.2) [100116]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree(this):=UnfoldingMask[null, tree(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree(this), UnfoldingHeap[null, tree(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@75.53--75.67) [100117]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@71.1--76.2) [100118]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@75.70--75.97) [100119]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        } else {
          // Enable postcondition for recursive call
          assume segSize#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_1: Ref, f_11: (Field A B) ::
              { newPMask[o_1, f_11] }
              Heap[null, heapseg#sm(this, last)][o_1, f_11] || Heap[null, tree#sm(this)][o_1, f_11] ==> newPMask[o_1, f_11]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_12: Ref, f_9: (Field A B) ::
              { newPMask[o_12, f_9] }
              Heap[null, heapseg#sm(this, last)][o_12, f_9] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_12, f_9] ==> newPMask[o_12, f_9]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := (if this == last then 0 else treeSize(Heap, this) + segSize(Heap, Heap[this, sibling], last));
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (this == last) {
      assert {:msg "  Postcondition of segSize might not hold. Assertion result == 0 might not hold. (BinomialHeap.vpr@73.10--73.38) [100120]"}
        Result == 0;
    }
}

// ==================================================
// Translation of function segDegree
// ==================================================

// Uninterpreted function definitions
function  segDegree(Heap: HeapType, this: Ref, last: Ref, index: int): int;
function  segDegree'(Heap: HeapType, this: Ref, last: Ref, index: int): int;
axiom (forall Heap: HeapType, this: Ref, last: Ref, index: int ::
  { segDegree(Heap, this, last, index) }
  segDegree(Heap, this, last, index) == segDegree'(Heap, this, last, index) && dummyFunction(segDegree#triggerStateless(this, last, index))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref, index: int ::
  { segDegree'(Heap, this, last, index) }
  dummyFunction(segDegree#triggerStateless(this, last, index))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref, index: int ::
  { state(Heap, Mask), segDegree(Heap, this, last, index) } { state(Heap, Mask), segDegree#triggerStateless(this, last, index), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 7 ==> 0 <= index && index < segLength(Heap, this, last) ==> segDegree(Heap, this, last, index) == (if index == 0 then treeDegree(Heap, this) else segDegree'(Heap, Heap[this, sibling], last, index - 1))
);

// Framing axioms
function  segDegree#frame(frame: FrameType, this: Ref, last: Ref, index: int): int;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref, index: int ::
  { state(Heap, Mask), segDegree'(Heap, this, last, index) } { state(Heap, Mask), segDegree#triggerStateless(this, last, index), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segDegree'(Heap, this, last, index) == segDegree#frame(Heap[null, heapseg(this, last)], this, last, index)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref, index: int ::
  { state(Heap, Mask), segDegree'(Heap, this, last, index) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 7 || segDegree#trigger(Heap[null, heapseg(this, last)], this, last, index)) ==> 0 <= index && index < segLength(Heap, this, last) ==> 0 <= segDegree'(Heap, this, last, index)
);

// Trigger function (controlling recursive postconditions)
function  segDegree#trigger(frame: FrameType, this: Ref, last: Ref, index: int): bool;

// State-independent trigger function
function  segDegree#triggerStateless(this: Ref, last: Ref, index: int): int;

// Check contract well-formedness and postcondition
procedure segDegree#definedness(this: Ref, last: Ref, index: int) returns (Result: int)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 7;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume 0 <= index;
    assume state(Heap, Mask);
    
    // -- Check definedness of index < segLength(this, last)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@80.33--80.54) [100121]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume index < segLength(Heap, this, last);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(heapseg(this, last), write) in (index == 0 ? treeDegree(this) : segDegree(this.sibling, last, index - 1)))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
      assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@78.1--85.2) [100122]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
      if (this != last) {
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, tree(this):=UnfoldingMask[null, tree(this)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree(this), UnfoldingHeap[null, tree(this)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        assume this != null;
        UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        if (UnfoldingHeap[this, sibling] != last) {
          assume state(UnfoldingHeap, UnfoldingMask);
          assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
        }
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      if (index == 0) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@84.16--84.32) [100123]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      } else {
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@78.1--85.2) [100124]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@84.34--84.74) [100125]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= index - 1 might not hold. (BinomialHeap.vpr@84.34--84.74) [100126]"}
            0 <= index - 1;
          assert {:msg "  Precondition of function segDegree might not hold. Assertion index - 1 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@84.34--84.74) [100127]"}
            index - 1 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        } else {
          // Enable postcondition for recursive call
          assume segDegree#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last, index - 1);
        }
      }
      
      // -- Free assumptions (exp module)
        if (this != last) {
          havoc newPMask;
          assume (forall <A, B> o_22: Ref, f_24: (Field A B) ::
            { newPMask[o_22, f_24] }
            Heap[null, heapseg#sm(this, last)][o_22, f_24] || Heap[null, tree#sm(this)][o_22, f_24] ==> newPMask[o_22, f_24]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_3: Ref, f_12: (Field A B) ::
            { newPMask[o_3, f_12] }
            Heap[null, heapseg#sm(this, last)][o_3, f_12] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_3, f_12] ==> newPMask[o_3, f_12]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
        }
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := (if index == 0 then treeDegree(Heap, this) else segDegree(Heap, Heap[this, sibling], last, index - 1));
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of segDegree might not hold. Assertion 0 <= result might not hold. (BinomialHeap.vpr@81.10--81.21) [100128]"}
      0 <= Result;
}

// ==================================================
// Translation of function segParent
// ==================================================

// Uninterpreted function definitions
function  segParent(Heap: HeapType, this: Ref, last: Ref): Ref;
function  segParent'(Heap: HeapType, this: Ref, last: Ref): Ref;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segParent(Heap, this, last) }
  segParent(Heap, this, last) == segParent'(Heap, this, last) && dummyFunction(segParent#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { segParent'(Heap, this, last) }
  dummyFunction(segParent#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segParent(Heap, this, last) } { state(Heap, Mask), segParent#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 4 ==> this != last ==> segParent(Heap, this, last) == treeParent(Heap, this)
);

// Framing axioms
function  segParent#frame(frame: FrameType, this: Ref, last: Ref): Ref;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), segParent'(Heap, this, last) } { state(Heap, Mask), segParent#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> segParent'(Heap, this, last) == segParent#frame(Heap[null, heapseg(this, last)], this, last)
);

// Trigger function (controlling recursive postconditions)
function  segParent#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  segParent#triggerStateless(this: Ref, last: Ref): Ref;

// Check contract well-formedness and postcondition
procedure segParent#definedness(this: Ref, last: Ref) returns (Result: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 4;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume this != last;
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (unfolding acc(heapseg(this, last), write) in treeParent(this))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
      assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@87.1--91.2) [100129]"}
        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
      if (this != last) {
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, tree(this):=UnfoldingMask[null, tree(this)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree(this), UnfoldingHeap[null, tree(this)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        assume this != null;
        UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        if (UnfoldingHeap[this, sibling] != last) {
          assume state(UnfoldingHeap, UnfoldingMask);
          assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
        }
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@90.35--90.51) [100130]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
        UnfoldingHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      
      // -- Free assumptions (exp module)
        if (this != last) {
          havoc newPMask;
          assume (forall <A, B> o_46: Ref, f_35: (Field A B) ::
            { newPMask[o_46, f_35] }
            Heap[null, heapseg#sm(this, last)][o_46, f_35] || Heap[null, tree#sm(this)][o_46, f_35] ==> newPMask[o_46, f_35]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_41: Ref, f_25: (Field A B) ::
            { newPMask[o_41, f_25] }
            Heap[null, heapseg#sm(this, last)][o_41, f_25] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_41, f_25] ==> newPMask[o_41, f_25]
          );
          Heap := Heap[null, heapseg#sm(this, last):=newPMask];
        }
        assume state(Heap, Mask);
  
  // -- Translate function body
    Result := treeParent(Heap, this);
}

// ==================================================
// Translation of function sorted
// ==================================================

// Uninterpreted function definitions
function  sorted(Heap: HeapType, this: Ref, last: Ref): bool;
function  sorted'(Heap: HeapType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { sorted(Heap, this, last) }
  sorted(Heap, this, last) == sorted'(Heap, this, last) && dummyFunction(sorted#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { sorted'(Heap, this, last) }
  dummyFunction(sorted#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), sorted(Heap, this, last) } { state(Heap, Mask), sorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 3 ==> sorted(Heap, this, last) == (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) < segDegree(Heap, Heap[this, sibling], last, 0) && sorted'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  sorted#frame(frame: FrameType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), sorted'(Heap, this, last) } { state(Heap, Mask), sorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> sorted'(Heap, this, last) == sorted#frame(Heap[null, heapseg(this, last)], this, last)
);

// Postcondition axioms
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), sorted'(Heap, this, last) }
  state(Heap, Mask) && (AssumeFunctionsAbove < 3 || sorted#trigger(Heap[null, heapseg(this, last)], this, last)) ==> sorted'(Heap, this, last) ==> presorted(Heap, this, last)
);

// Trigger function (controlling recursive postconditions)
function  sorted#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  sorted#triggerStateless(this: Ref, last: Ref): bool;

// Check contract well-formedness and postcondition
procedure sorted#definedness(this: Ref, last: Ref) returns (Result: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  var ExhaleWellDef1Heap: HeapType;
  var ExhaleWellDef1Mask: MaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 3;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of 1 < segLength(this, last) ==> (unfolding acc(heapseg(this, last), write) in treeDegree(this) < segDegree(this.sibling, last, 0) && sorted(this.sibling, last))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@97.6--97.27) [100131]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (1 < segLength(Heap, this, last)) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@93.1--98.2) [100132]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree(this):=UnfoldingMask[null, tree(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree(this), UnfoldingHeap[null, tree(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@97.65--97.81) [100133]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@93.1--98.2) [100134]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@97.84--97.116) [100135]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@97.84--97.116) [100136]"}
            0 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (treeDegree(UnfoldingHeap, this) < segDegree(UnfoldingHeap, UnfoldingHeap[this, sibling], last, 0)) {
          assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@93.1--98.2) [100137]"}
            HasDirectPerm(UnfoldingMask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := UnfoldingHeap;
            ExhaleWellDef0Mask := UnfoldingMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@97.120--97.146) [100138]"}
              NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
            UnfoldingHeap := ExhaleHeap;
            // Stop execution
            assume false;
          } else {
            // Enable postcondition for recursive call
            assume sorted#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
          }
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_34: Ref, f_44: (Field A B) ::
              { newPMask[o_34, f_44] }
              Heap[null, heapseg#sm(this, last)][o_34, f_44] || Heap[null, tree#sm(this)][o_34, f_44] ==> newPMask[o_34, f_44]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_55: Ref, f_36: (Field A B) ::
              { newPMask[o_55, f_36] }
              Heap[null, heapseg#sm(this, last)][o_55, f_36] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_55, f_36] ==> newPMask[o_55, f_36]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := 1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) < segDegree(Heap, Heap[this, sibling], last, 0) && sorted(Heap, Heap[this, sibling], last);
  
  // -- Exhaling postcondition (with checking)
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (Result) {
      
      // -- Check definedness of presorted(this, last)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef1Heap := ExhaleWellDef0Heap;
          ExhaleWellDef1Mask := ExhaleWellDef0Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@95.21--95.42) [100139]"}
            NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(this, last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
          ExhaleWellDef0Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assert {:msg "  Postcondition of sorted might not hold. Assertion presorted(this, last) might not hold. (BinomialHeap.vpr@95.10--95.42) [100140]"}
        presorted(Heap, this, last);
    }
}

// ==================================================
// Translation of function presorted
// ==================================================

// Uninterpreted function definitions
function  presorted(Heap: HeapType, this: Ref, last: Ref): bool;
function  presorted'(Heap: HeapType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { presorted(Heap, this, last) }
  presorted(Heap, this, last) == presorted'(Heap, this, last) && dummyFunction(presorted#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { presorted'(Heap, this, last) }
  dummyFunction(presorted#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), presorted(Heap, this, last) } { state(Heap, Mask), presorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 5 ==> presorted(Heap, this, last) == ((1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) <= segDegree(Heap, Heap[this, sibling], last, 0) && presorted'(Heap, Heap[this, sibling], last)) && (2 < segLength(Heap, this, last) && segDegree(Heap, this, last, 0) == segDegree(Heap, this, last, 1) ==> segDegree(Heap, this, last, 1) < segDegree(Heap, this, last, 2)))
);

// Framing axioms
function  presorted#frame(frame: FrameType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), presorted'(Heap, this, last) } { state(Heap, Mask), presorted#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> presorted'(Heap, this, last) == presorted#frame(Heap[null, heapseg(this, last)], this, last)
);

// Trigger function (controlling recursive postconditions)
function  presorted#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  presorted#triggerStateless(this: Ref, last: Ref): bool;

// Check contract well-formedness and postcondition
procedure presorted#definedness(this: Ref, last: Ref) returns (Result: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 5;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of (1 < segLength(this, last) ==> (unfolding acc(heapseg(this, last), write) in treeDegree(this) <= segDegree(this.sibling, last, 0) && presorted(this.sibling, last))) && (2 < segLength(this, last) && segDegree(this, last, 0) == segDegree(this, last, 1) ==> segDegree(this, last, 1) < segDegree(this, last, 2))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@103.7--103.28) [100141]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (1 < segLength(Heap, this, last)) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@100.1--105.2) [100142]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree(this):=UnfoldingMask[null, tree(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree(this), UnfoldingHeap[null, tree(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@103.66--103.82) [100143]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@100.1--105.2) [100144]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@103.86--103.118) [100145]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@103.86--103.118) [100146]"}
            0 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (treeDegree(UnfoldingHeap, this) <= segDegree(UnfoldingHeap, UnfoldingHeap[this, sibling], last, 0)) {
          assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@100.1--105.2) [100147]"}
            HasDirectPerm(UnfoldingMask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := UnfoldingHeap;
            ExhaleWellDef0Mask := UnfoldingMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@103.122--103.151) [100148]"}
              NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
            UnfoldingHeap := ExhaleHeap;
            // Stop execution
            assume false;
          } else {
            // Enable postcondition for recursive call
            assume presorted#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
          }
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_42: Ref, f_26: (Field A B) ::
              { newPMask[o_42, f_26] }
              Heap[null, heapseg#sm(this, last)][o_42, f_26] || Heap[null, tree#sm(this)][o_42, f_26] ==> newPMask[o_42, f_26]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_13: Ref, f_45: (Field A B) ::
              { newPMask[o_13, f_45] }
              Heap[null, heapseg#sm(this, last)][o_13, f_45] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_13, f_45] ==> newPMask[o_13, f_45]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
      if (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) <= segDegree(Heap, Heap[this, sibling], last, 0) && presorted(Heap, Heap[this, sibling], last)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.7--104.28) [100149]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (2 < segLength(Heap, this, last)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.32--104.56) [100150]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.32--104.56) [100151]"}
              0 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.60--104.84) [100152]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.60--104.84) [100153]"}
              1 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        }
        if (2 < segLength(Heap, this, last) && segDegree(Heap, this, last, 0) == segDegree(Heap, this, last, 1)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.89--104.113) [100154]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.89--104.113) [100155]"}
              1 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@104.116--104.140) [100156]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 2 < segLength(this, last) might not hold. (BinomialHeap.vpr@104.116--104.140) [100157]"}
              2 < segLength(Heap, this, last);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        }
      }
  
  // -- Translate function body
    Result := (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) <= segDegree(Heap, Heap[this, sibling], last, 0) && presorted(Heap, Heap[this, sibling], last)) && (2 < segLength(Heap, this, last) && segDegree(Heap, this, last, 0) == segDegree(Heap, this, last, 1) ==> segDegree(Heap, this, last, 1) < segDegree(Heap, this, last, 2));
}

// ==================================================
// Translation of function validChildren
// ==================================================

// Uninterpreted function definitions
function  validChildren(Heap: HeapType, this: Ref, last: Ref): bool;
function  validChildren'(Heap: HeapType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { validChildren(Heap, this, last) }
  validChildren(Heap, this, last) == validChildren'(Heap, this, last) && dummyFunction(validChildren#triggerStateless(this, last))
);
axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { validChildren'(Heap, this, last) }
  dummyFunction(validChildren#triggerStateless(this, last))
);

// Definitional axiom
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), validChildren(Heap, this, last) } { state(Heap, Mask), validChildren#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) && AssumeFunctionsAbove < 1 ==> validChildren(Heap, this, last) == (1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) == segDegree(Heap, Heap[this, sibling], last, 0) + 1 && validChildren'(Heap, Heap[this, sibling], last))
);

// Framing axioms
function  validChildren#frame(frame: FrameType, this: Ref, last: Ref): bool;
axiom (forall Heap: HeapType, Mask: MaskType, this: Ref, last: Ref ::
  { state(Heap, Mask), validChildren'(Heap, this, last) } { state(Heap, Mask), validChildren#triggerStateless(this, last), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)), heapseg#trigger(Heap, heapseg(this, last)) }
  state(Heap, Mask) ==> validChildren'(Heap, this, last) == validChildren#frame(Heap[null, heapseg(this, last)], this, last)
);

// Trigger function (controlling recursive postconditions)
function  validChildren#trigger(frame: FrameType, this: Ref, last: Ref): bool;

// State-independent trigger function
function  validChildren#triggerStateless(this: Ref, last: Ref): bool;

// Check contract well-formedness and postcondition
procedure validChildren#definedness(this: Ref, last: Ref) returns (Result: bool)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume !AssumePermUpperBound;
    assume Heap[this, $allocated];
    assume Heap[last, $allocated];
    assume AssumeFunctionsAbove == 1;
  
  // -- Inhaling precondition (with checking)
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, last):=Mask[null, heapseg(this, last)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Check definedness of function body
    
    // -- Check definedness of 1 < segLength(this, last) ==> (unfolding acc(heapseg(this, last), write) in treeDegree(this) == segDegree(this.sibling, last, 0) + 1 && validChildren(this.sibling, last))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@110.6--110.27) [100158]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, last)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (1 < segLength(Heap, this, last)) {
        UnfoldingHeap := Heap;
        UnfoldingMask := Mask;
        assume heapseg#trigger(UnfoldingHeap, heapseg(this, last));
        assume UnfoldingHeap[null, heapseg(this, last)] == FrameFragment((if this != last then CombineFrames(UnfoldingHeap[null, tree(this)], CombineFrames(FrameFragment(UnfoldingHeap[this, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], FrameFragment((if UnfoldingHeap[this, sibling] != last then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access heapseg(this, last) (BinomialHeap.vpr@107.1--111.2) [100159]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(this, last)];
        if (this != last) {
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, tree(this):=UnfoldingMask[null, tree(this)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], tree(this), UnfoldingHeap[null, tree(this)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          assume this != null;
          UnfoldingMask := UnfoldingMask[this, sibling:=UnfoldingMask[this, sibling] + perm];
          assume state(UnfoldingHeap, UnfoldingMask);
          perm := FullPerm;
          UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(this, last), UnfoldingHeap[null, heapseg(this, last)], heapseg(UnfoldingHeap[this, sibling], last), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)]);
          assume state(UnfoldingHeap, UnfoldingMask);
          if (UnfoldingHeap[this, sibling] != last) {
            assume state(UnfoldingHeap, UnfoldingMask);
            assume treeParent(UnfoldingHeap, this) == segParent(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          }
        }
        assume state(UnfoldingHeap, UnfoldingMask);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@110.65--110.81) [100160]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(this)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@107.1--111.2) [100161]"}
          HasDirectPerm(UnfoldingMask, this, sibling);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := UnfoldingHeap;
          ExhaleWellDef0Mask := UnfoldingMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@110.85--110.117) [100162]"}
            NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.sibling, last) might not hold. (BinomialHeap.vpr@110.85--110.117) [100163]"}
            0 < segLength(UnfoldingHeap, UnfoldingHeap[this, sibling], last);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
          UnfoldingHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (treeDegree(UnfoldingHeap, this) == segDegree(UnfoldingHeap, UnfoldingHeap[this, sibling], last, 0) + 1) {
          assert {:msg "  Function might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@107.1--111.2) [100164]"}
            HasDirectPerm(UnfoldingMask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := UnfoldingHeap;
            ExhaleWellDef0Mask := UnfoldingMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@110.125--110.158) [100165]"}
              NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, sibling], last)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
            UnfoldingHeap := ExhaleHeap;
            // Stop execution
            assume false;
          } else {
            // Enable postcondition for recursive call
            assume validChildren#trigger(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, sibling], last)], UnfoldingHeap[this, sibling], last);
          }
        }
        
        // -- Free assumptions (exp module)
          if (this != last) {
            havoc newPMask;
            assume (forall <A, B> o_43: Ref, f_13: (Field A B) ::
              { newPMask[o_43, f_13] }
              Heap[null, heapseg#sm(this, last)][o_43, f_13] || Heap[null, tree#sm(this)][o_43, f_13] ==> newPMask[o_43, f_13]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
            Heap := Heap[null, heapseg#sm(this, last):=Heap[null, heapseg#sm(this, last)][this, sibling:=true]];
            havoc newPMask;
            assume (forall <A, B> o_47: Ref, f_41: (Field A B) ::
              { newPMask[o_47, f_41] }
              Heap[null, heapseg#sm(this, last)][o_47, f_41] || Heap[null, heapseg#sm(Heap[this, sibling], last)][o_47, f_41] ==> newPMask[o_47, f_41]
            );
            Heap := Heap[null, heapseg#sm(this, last):=newPMask];
          }
          assume state(Heap, Mask);
      }
  
  // -- Translate function body
    Result := 1 < segLength(Heap, this, last) ==> treeDegree(Heap, this) == segDegree(Heap, Heap[this, sibling], last, 0) + 1 && validChildren(Heap, Heap[this, sibling], last);
}

// ==================================================
// Translation of predicate tree
// ==================================================

type PredicateType_tree;
function  tree(this: Ref): Field PredicateType_tree FrameType;
function  tree#sm(this: Ref): Field PredicateType_tree PMaskType;
axiom (forall this: Ref ::
  { PredicateMaskField(tree(this)) }
  PredicateMaskField(tree(this)) == tree#sm(this)
);
axiom (forall this: Ref ::
  { tree(this) }
  IsPredicateField(tree(this))
);
axiom (forall this: Ref ::
  { tree(this) }
  getPredWandId(tree(this)) == 0
);
function  tree#trigger<A>(Heap: HeapType, pred: (Field A FrameType)): bool;
function  tree#everUsed<A>(pred: (Field A FrameType)): bool;
axiom (forall this: Ref, this2: Ref ::
  { tree(this), tree(this2) }
  tree(this) == tree(this2) ==> this == this2
);
axiom (forall this: Ref, this2: Ref ::
  { tree#sm(this), tree#sm(this2) }
  tree#sm(this) == tree#sm(this2) ==> this == this2
);

axiom (forall Heap: HeapType, this: Ref ::
  { tree#trigger(Heap, tree(this)) }
  tree#everUsed(tree(this))
);

procedure tree#definedness(this: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  
  // -- Check definedness of predicate body of tree
    
    // -- Initializing the state
      Mask := ZeroMask;
      assume state(Heap, Mask);
      assume AssumeFunctionsAbove == -1;
      assume AssumePermUpperBound;
      assume Heap[this, $allocated];
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, key:=Mask[this, key] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, degree:=Mask[this, degree] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, child:=Mask[this, child] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, parent:=Mask[this, parent] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of 0 <= this.degree
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [100166]"}
        HasDirectPerm(Mask, this, degree);
    assume 0 <= Heap[this, degree];
    
    // -- Check definedness of acc(heapseg(this.child, null), write)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [100167]"}
        HasDirectPerm(Mask, this, child);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, child], null):=Mask[null, heapseg(Heap[this, child], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.degree == segLength(this.child, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [100168]"}
        HasDirectPerm(Mask, this, degree);
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [100169]"}
        HasDirectPerm(Mask, this, child);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@26.17--26.44) [100170]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume Heap[this, degree] == segLength(Heap, Heap[this, child], null);
    
    // -- Check definedness of 0 < this.degree
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [100171]"}
        HasDirectPerm(Mask, this, degree);
    if (0 < Heap[this, degree]) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segDegree(this.child, null, 0) == this.degree - 1
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [100172]"}
          HasDirectPerm(Mask, this, child);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@27.23--27.53) [100173]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this.child, null) might not hold. (BinomialHeap.vpr@27.23--27.53) [100174]"}
            0 < segLength(Heap, Heap[this, child], null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.degree (BinomialHeap.vpr@22.1--30.2) [100175]"}
          HasDirectPerm(Mask, this, degree);
      assume segDegree(Heap, Heap[this, child], null, 0) == Heap[this, degree] - 1;
    }
    assume state(Heap, Mask);
    
    // -- Check definedness of validChildren(this.child, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [100176]"}
        HasDirectPerm(Mask, this, child);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@28.2--28.33) [100177]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume validChildren(Heap, Heap[this, child], null);
    
    // -- Check definedness of this.child != null
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [100178]"}
        HasDirectPerm(Mask, this, child);
    if (Heap[this, child] != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.child, null) == this
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.child (BinomialHeap.vpr@22.1--30.2) [100179]"}
          HasDirectPerm(Mask, this, child);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.child, null) (BinomialHeap.vpr@29.26--29.53) [100180]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, child], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.child != null might not hold. (BinomialHeap.vpr@29.26--29.53) [100181]"}
            Heap[this, child] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, child], null) == this;
    }
    assume state(Heap, Mask);
}

// ==================================================
// Translation of predicate heapseg
// ==================================================

type PredicateType_heapseg;
function  heapseg(this: Ref, last: Ref): Field PredicateType_heapseg FrameType;
function  heapseg#sm(this: Ref, last: Ref): Field PredicateType_heapseg PMaskType;
axiom (forall this: Ref, last: Ref ::
  { PredicateMaskField(heapseg(this, last)) }
  PredicateMaskField(heapseg(this, last)) == heapseg#sm(this, last)
);
axiom (forall this: Ref, last: Ref ::
  { heapseg(this, last) }
  IsPredicateField(heapseg(this, last))
);
axiom (forall this: Ref, last: Ref ::
  { heapseg(this, last) }
  getPredWandId(heapseg(this, last)) == 1
);
function  heapseg#trigger<A>(Heap: HeapType, pred: (Field A FrameType)): bool;
function  heapseg#everUsed<A>(pred: (Field A FrameType)): bool;
axiom (forall this: Ref, last: Ref, this2: Ref, last2: Ref ::
  { heapseg(this, last), heapseg(this2, last2) }
  heapseg(this, last) == heapseg(this2, last2) ==> this == this2 && last == last2
);
axiom (forall this: Ref, last: Ref, this2: Ref, last2: Ref ::
  { heapseg#sm(this, last), heapseg#sm(this2, last2) }
  heapseg#sm(this, last) == heapseg#sm(this2, last2) ==> this == this2 && last == last2
);

axiom (forall Heap: HeapType, this: Ref, last: Ref ::
  { heapseg#trigger(Heap, heapseg(this, last)) }
  heapseg#everUsed(heapseg(this, last))
);

procedure heapseg#definedness(this: Ref, last: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  
  // -- Check definedness of predicate body of heapseg
    
    // -- Initializing the state
      Mask := ZeroMask;
      assume state(Heap, Mask);
      assume AssumeFunctionsAbove == -1;
      assume AssumePermUpperBound;
      assume Heap[this, $allocated];
      assume Heap[last, $allocated];
    if (this != last) {
      perm := FullPerm;
      Mask := Mask[null, tree(this):=Mask[null, tree(this)] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, sibling:=Mask[this, sibling] + perm];
      assume state(Heap, Mask);
      
      // -- Check definedness of acc(heapseg(this.sibling, last), write)
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@57.1--62.2) [100182]"}
          HasDirectPerm(Mask, this, sibling);
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, sibling], last):=Mask[null, heapseg(Heap[this, sibling], last)] + perm];
      assume state(Heap, Mask);
      
      // -- Check definedness of this.sibling != last
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@57.1--62.2) [100183]"}
          HasDirectPerm(Mask, this, sibling);
      if (Heap[this, sibling] != last) {
        assume state(Heap, Mask);
        
        // -- Check definedness of treeParent(this) == segParent(this.sibling, last)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@61.28--61.44) [100184]"}
              NoPerm < perm ==> NoPerm < Mask[null, tree(this)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@57.1--62.2) [100185]"}
            HasDirectPerm(Mask, this, sibling);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.sibling, last) (BinomialHeap.vpr@61.48--61.77) [100186]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, sibling], last)];
            assert {:msg "  Precondition of function segParent might not hold. Assertion this.sibling != last might not hold. (BinomialHeap.vpr@61.48--61.77) [100187]"}
              Heap[this, sibling] != last;
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume treeParent(Heap, this) == segParent(Heap, Heap[this, sibling], last);
      }
    }
    assume state(Heap, Mask);
}

// ==================================================
// Translation of predicate heap
// ==================================================

type PredicateType_heap;
function  heap_1(this: Ref): Field PredicateType_heap FrameType;
function  heap#sm(this: Ref): Field PredicateType_heap PMaskType;
axiom (forall this: Ref ::
  { PredicateMaskField(heap_1(this)) }
  PredicateMaskField(heap_1(this)) == heap#sm(this)
);
axiom (forall this: Ref ::
  { heap_1(this) }
  IsPredicateField(heap_1(this))
);
axiom (forall this: Ref ::
  { heap_1(this) }
  getPredWandId(heap_1(this)) == 2
);
function  heap#trigger<A>(Heap: HeapType, pred: (Field A FrameType)): bool;
function  heap#everUsed<A>(pred: (Field A FrameType)): bool;
axiom (forall this: Ref, this2: Ref ::
  { heap_1(this), heap_1(this2) }
  heap_1(this) == heap_1(this2) ==> this == this2
);
axiom (forall this: Ref, this2: Ref ::
  { heap#sm(this), heap#sm(this2) }
  heap#sm(this) == heap#sm(this2) ==> this == this2
);

axiom (forall Heap: HeapType, this: Ref ::
  { heap#trigger(Heap, heap_1(this)) }
  heap#everUsed(heap_1(this))
);

procedure heap#definedness(this: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  
  // -- Check definedness of predicate body of heap
    
    // -- Initializing the state
      Mask := ZeroMask;
      assume state(Heap, Mask);
      assume AssumeFunctionsAbove == -1;
      assume AssumePermUpperBound;
      assume Heap[this, $allocated];
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [100188]"}
        HasDirectPerm(Mask, this, Nodes);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [100189]"}
        HasDirectPerm(Mask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@239.31--239.55) [100190]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(Heap, Heap[this, Nodes], null);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [100191]"}
        HasDirectPerm(Mask, this, Nodes);
    if (Heap[this, Nodes] != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.Nodes, null) == null
        assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [100192]"}
          HasDirectPerm(Mask, this, Nodes);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@240.26--240.53) [100193]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@240.26--240.53) [100194]"}
            Heap[this, Nodes] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, Nodes], null) == null;
    }
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, size:=Mask[this, size] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.size == segSize(this.Nodes, null)
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.size (BinomialHeap.vpr@237.1--243.2) [100195]"}
        HasDirectPerm(Mask, this, size);
      assert {:msg "  Predicate might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@237.1--243.2) [100196]"}
        HasDirectPerm(Mask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@242.15--242.40) [100197]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume Heap[this, size] == segSize(Heap, Heap[this, Nodes], null);
    assume state(Heap, Mask);
}

// ==================================================
// Translation of method reverse2
// ==================================================

procedure reverse2(this: Ref, sibl: Ref) returns (res: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var newVersion: FrameType;
  var ss: Ref;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
    assume Heap[sibl, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of validChildren(this, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@114.34--114.59) [100198]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume validChildren(Heap, this, null);
    assume state(Heap, Mask);
    
    // -- Check definedness of 0 < segLength(this, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@114.67--114.88) [100199]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume 0 < segLength(Heap, this, null);
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(sibl, null):=Mask[null, heapseg(sibl, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(sibl, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@115.34--115.52) [100200]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(sibl, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(Heap, sibl, null);
    assume state(Heap, Mask);
    if (sibl != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segDegree(this, null, 0) < segDegree(sibl, null, 0)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@116.28--116.52) [100201]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(this, null) might not hold. (BinomialHeap.vpr@116.28--116.52) [100202]"}
            0 < segLength(Heap, this, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@116.55--116.79) [100203]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(sibl, null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(sibl, null) might not hold. (BinomialHeap.vpr@116.55--116.79) [100204]"}
            0 < segLength(Heap, sibl, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segDegree(Heap, this, null, 0) < segDegree(Heap, sibl, null, 0);
    }
    assume state(Heap, Mask);
    if (sibl != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this, null) == segParent(sibl, null)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@117.28--117.49) [100205]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(this, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this != null might not hold. (BinomialHeap.vpr@117.28--117.49) [100206]"}
            this != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@117.53--117.74) [100207]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(sibl, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion sibl != null might not hold. (BinomialHeap.vpr@117.53--117.74) [100208]"}
            sibl != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, this, null) == segParent(Heap, sibl, null);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    assume res != null;
    assume state(PostHeap, PostMask);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(res, null):=PostMask[null, heapseg(res, null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(res, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@120.10--120.27) [100209]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(PostHeap, res, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(res, null) == old(segSize(this, null)) + old(segSize(sibl, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@121.10--121.28) [100210]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@121.36--121.55) [100211]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(this, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(sibl, null) (BinomialHeap.vpr@121.63--121.82) [100212]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(sibl, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, res, null) == segSize(oldHeap, this, null) + segSize(oldHeap, sibl, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(res, null) == old(segParent(this, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@122.10--122.30) [100213]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@122.10--122.30) [100214]"}
          res != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@122.38--122.59) [100215]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(this, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this != null might not hold. (BinomialHeap.vpr@122.38--122.59) [100216]"}
          this != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, res, null) == segParent(oldHeap, this, null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Translating statement: unfold acc(heapseg(this, null), write) -- BinomialHeap.vpr@124.2--124.28
    assume heapseg#trigger(Heap, heapseg(this, null));
    assume Heap[null, heapseg(this, null)] == FrameFragment((if this != null then CombineFrames(Heap[null, tree(this)], CombineFrames(FrameFragment(Heap[this, sibling]), CombineFrames(Heap[null, heapseg(Heap[this, sibling], null)], FrameFragment((if Heap[this, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Unfolding heapseg(this, null) might fail. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@124.2--124.28) [100219]"}
        perm <= Mask[null, heapseg(this, null)];
    }
    Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] - perm];
    
    // -- Update version of predicate
      if (!HasDirectPerm(Mask, null, heapseg(this, null))) {
        havoc newVersion;
        Heap := Heap[null, heapseg(this, null):=newVersion];
      }
    if (this != null) {
      perm := FullPerm;
      Mask := Mask[null, tree(this):=Mask[null, tree(this)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], tree(this), Heap[null, tree(this)]);
      assume state(Heap, Mask);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, sibling:=Mask[this, sibling] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, sibling], null):=Mask[null, heapseg(Heap[this, sibling], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], heapseg(Heap[this, sibling], null), Heap[null, heapseg(Heap[this, sibling], null)]);
      assume state(Heap, Mask);
      if (Heap[this, sibling] != null) {
        assume state(Heap, Mask);
        assume treeParent(Heap, this) == segParent(Heap, Heap[this, sibling], null);
      }
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (this.sibling != null) -- BinomialHeap.vpr@125.2--136.3
    
    // -- Check definedness of this.sibling != null
      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@125.5--125.25) [100223]"}
        HasDirectPerm(Mask, this, sibling);
    if (Heap[this, sibling] != null) {
      
      // -- Assumptions about local variables
        assume Heap[ss, $allocated];
      
      // -- Translating statement: ss := this.sibling -- BinomialHeap.vpr@127.3--127.21
        
        // -- Check definedness of this.sibling
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@127.3--127.21) [100224]"}
            HasDirectPerm(Mask, this, sibling);
        ss := Heap[this, sibling];
        assume state(Heap, Mask);
      
      // -- Translating statement: this.sibling := sibl -- BinomialHeap.vpr@128.3--128.23
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@128.3--128.23) [100225]"}
          FullPerm == Mask[this, sibling];
        Heap := Heap[this, sibling:=sibl];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(this, null), write) -- BinomialHeap.vpr@129.3--129.27
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (this != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this, null) might fail. There might be insufficient permission to access tree(this) (BinomialHeap.vpr@129.3--129.27) [100228]"}
              perm <= Mask[null, tree(this)];
          }
          Mask := Mask[null, tree(this):=Mask[null, tree(this)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], tree(this), Heap[null, tree(this)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this, null) might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@129.3--129.27) [100230]"}
              perm <= Mask[this, sibling];
          }
          Mask := Mask[this, sibling:=Mask[this, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this, null) might fail. There might be insufficient permission to access heapseg(this.sibling, null) (BinomialHeap.vpr@129.3--129.27) [100232]"}
              perm <= Mask[null, heapseg(Heap[this, sibling], null)];
          }
          Mask := Mask[null, heapseg(Heap[this, sibling], null):=Mask[null, heapseg(Heap[this, sibling], null)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(this, null), Heap[null, heapseg(this, null)], heapseg(Heap[this, sibling], null), Heap[null, heapseg(Heap[this, sibling], null)]);
          if (Heap[this, sibling] != null) {
            assert {:msg "  Folding heapseg(this, null) might fail. Assertion treeParent(this) == segParent(this.sibling, null) might not hold. (BinomialHeap.vpr@129.3--129.27) [100233]"}
              treeParent(Heap, this) == segParent(Heap, Heap[this, sibling], null);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(this, null));
        assume Heap[null, heapseg(this, null)] == FrameFragment((if this != null then CombineFrames(Heap[null, tree(this)], CombineFrames(FrameFragment(Heap[this, sibling]), CombineFrames(Heap[null, heapseg(Heap[this, sibling], null)], FrameFragment((if Heap[this, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(this, null))) {
          Heap := Heap[null, heapseg#sm(this, null):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(this, null):=freshVersion];
        }
        if (this != null) {
          havoc newPMask;
          assume (forall <A, B> o_14: Ref, f_51: (Field A B) ::
            { newPMask[o_14, f_51] }
            Heap[null, heapseg#sm(this, null)][o_14, f_51] || Heap[null, tree#sm(this)][o_14, f_51] ==> newPMask[o_14, f_51]
          );
          Heap := Heap[null, heapseg#sm(this, null):=newPMask];
          Heap := Heap[null, heapseg#sm(this, null):=Heap[null, heapseg#sm(this, null)][this, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_44: Ref, f_14: (Field A B) ::
            { newPMask[o_44, f_14] }
            Heap[null, heapseg#sm(this, null)][o_44, f_14] || Heap[null, heapseg#sm(Heap[this, sibling], null)][o_44, f_14] ==> newPMask[o_44, f_14]
          );
          Heap := Heap[null, heapseg#sm(this, null):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: res := reverse2(ss, this) -- BinomialHeap.vpr@130.3--130.28
        PreCallHeap := Heap;
        PreCallMask := Mask;
        
        // -- Exhaling precondition
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(ss, null) (BinomialHeap.vpr@130.3--130.28) [100235]"}
              perm <= Mask[null, heapseg(ss, null)];
          }
          Mask := Mask[null, heapseg(ss, null):=Mask[null, heapseg(ss, null)] - perm];
          assert {:msg "  The precondition of method reverse2 might not hold. Assertion validChildren(ss, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [100236]"}
            validChildren(Heap, ss, null);
          assert {:msg "  The precondition of method reverse2 might not hold. Assertion 0 < segLength(ss, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [100237]"}
            0 < segLength(Heap, ss, null);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(this, null) (BinomialHeap.vpr@130.3--130.28) [100238]"}
              perm <= Mask[null, heapseg(this, null)];
          }
          Mask := Mask[null, heapseg(this, null):=Mask[null, heapseg(this, null)] - perm];
          assert {:msg "  The precondition of method reverse2 might not hold. Assertion sorted(this, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [100239]"}
            sorted(Heap, this, null);
          if (this != null) {
            assert {:msg "  The precondition of method reverse2 might not hold. Assertion segDegree(ss, null, 0) < segDegree(this, null, 0) might not hold. (BinomialHeap.vpr@130.3--130.28) [100240]"}
              segDegree(Heap, ss, null, 0) < segDegree(Heap, this, null, 0);
          }
          if (this != null) {
            assert {:msg "  The precondition of method reverse2 might not hold. Assertion segParent(ss, null) == segParent(this, null) might not hold. (BinomialHeap.vpr@130.3--130.28) [100241]"}
              segParent(Heap, ss, null) == segParent(Heap, this, null);
          }
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
        
        // -- Havocing target variables
          havoc res;
        
        // -- Inhaling postcondition
          assume res != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted(Heap, res, null);
          assume state(Heap, Mask);
          assume segSize(Heap, res, null) == segSize(PreCallHeap, ss, null) + segSize(PreCallHeap, this, null);
          assume state(Heap, Mask);
          assume segParent(Heap, res, null) == segParent(PreCallHeap, ss, null);
          assume state(Heap, Mask);
        assume Heap[res, $allocated];
        assume state(Heap, Mask);
    } else {
      
      // -- Translating statement: res := this -- BinomialHeap.vpr@133.3--133.14
        res := this;
        assume state(Heap, Mask);
      
      // -- Translating statement: this.sibling := sibl -- BinomialHeap.vpr@134.3--134.23
        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.sibling (BinomialHeap.vpr@134.3--134.23) [100242]"}
          FullPerm == Mask[this, sibling];
        Heap := Heap[this, sibling:=sibl];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(res, null), write) -- BinomialHeap.vpr@135.3--135.26
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (res != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(res, null) might fail. There might be insufficient permission to access tree(res) (BinomialHeap.vpr@135.3--135.26) [100245]"}
              perm <= Mask[null, tree(res)];
          }
          Mask := Mask[null, tree(res):=Mask[null, tree(res)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(res, null), Heap[null, heapseg(res, null)], tree(res), Heap[null, tree(res)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(res, null) might fail. There might be insufficient permission to access res.sibling (BinomialHeap.vpr@135.3--135.26) [100247]"}
              perm <= Mask[res, sibling];
          }
          Mask := Mask[res, sibling:=Mask[res, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(res, null) might fail. There might be insufficient permission to access heapseg(res.sibling, null) (BinomialHeap.vpr@135.3--135.26) [100249]"}
              perm <= Mask[null, heapseg(Heap[res, sibling], null)];
          }
          Mask := Mask[null, heapseg(Heap[res, sibling], null):=Mask[null, heapseg(Heap[res, sibling], null)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(res, null), Heap[null, heapseg(res, null)], heapseg(Heap[res, sibling], null), Heap[null, heapseg(Heap[res, sibling], null)]);
          if (Heap[res, sibling] != null) {
            assert {:msg "  Folding heapseg(res, null) might fail. Assertion treeParent(res) == segParent(res.sibling, null) might not hold. (BinomialHeap.vpr@135.3--135.26) [100250]"}
              treeParent(Heap, res) == segParent(Heap, Heap[res, sibling], null);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(res, null));
        assume Heap[null, heapseg(res, null)] == FrameFragment((if res != null then CombineFrames(Heap[null, tree(res)], CombineFrames(FrameFragment(Heap[res, sibling]), CombineFrames(Heap[null, heapseg(Heap[res, sibling], null)], FrameFragment((if Heap[res, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(res, null))) {
          Heap := Heap[null, heapseg#sm(res, null):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(res, null):=freshVersion];
        }
        if (res != null) {
          havoc newPMask;
          assume (forall <A, B> o_28: Ref, f_42: (Field A B) ::
            { newPMask[o_28, f_42] }
            Heap[null, heapseg#sm(res, null)][o_28, f_42] || Heap[null, tree#sm(res)][o_28, f_42] ==> newPMask[o_28, f_42]
          );
          Heap := Heap[null, heapseg#sm(res, null):=newPMask];
          Heap := Heap[null, heapseg#sm(res, null):=Heap[null, heapseg#sm(res, null)][res, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_76: Ref, f_34: (Field A B) ::
            { newPMask[o_76, f_34] }
            Heap[null, heapseg#sm(res, null)][o_76, f_34] || Heap[null, heapseg#sm(Heap[res, sibling], null)][o_76, f_34] ==> newPMask[o_76, f_34]
          );
          Heap := Heap[null, heapseg#sm(res, null):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@118.10--118.21) [100252]"}
      res != null;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of reverse2 might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@119.10--119.28) [100253]"}
        perm <= Mask[null, heapseg(res, null)];
    }
    Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] - perm];
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion sorted(res, null) might not hold. (BinomialHeap.vpr@120.10--120.27) [100254]"}
      sorted(Heap, res, null);
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion segSize(res, null) == old(segSize(this, null)) + old(segSize(sibl, null)) might not hold. (BinomialHeap.vpr@121.10--121.83) [100255]"}
      segSize(Heap, res, null) == segSize(oldHeap, this, null) + segSize(oldHeap, sibl, null);
    assert {:msg "  Postcondition of reverse2 might not hold. Assertion segParent(res, null) == old(segParent(this, null)) might not hold. (BinomialHeap.vpr@122.10--122.60) [100256]"}
      segParent(Heap, res, null) == segParent(oldHeap, this, null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method concat
// ==================================================

procedure vconcat(a_2: Ref, b_24: Ref, c: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var i_92: int;
  var i_93: int;
  var newVersion: FrameType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_a: Ref;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var ExhaleWellDef1Heap: HeapType;
  var ExhaleWellDef1Mask: MaskType;
  var Unfolding1Heap: HeapType;
  var Unfolding1Mask: MaskType;
  var newPMask: PMaskType;
  var freshVersion: FrameType;
  var i_4_1: int;
  var i_6_1: int;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[a_2, $allocated];
    assume Heap[b_24, $allocated];
    assume Heap[c, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    Mask := Mask[null, heapseg(a_2, b_24):=Mask[null, heapseg(a_2, b_24)] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(b_24, c):=Mask[null, heapseg(b_24, c)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    if (c != null) {
      perm := FullPerm;
      Mask := Mask[null, tree(c):=Mask[null, tree(c)] + perm];
      assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
    if (a_2 != b_24 && b_24 != c) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(a, b) == segParent(b, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@142.32--142.47) [100257]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(a_2, b_24)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != b might not hold. (BinomialHeap.vpr@142.32--142.47) [100258]"}
            a_2 != b_24;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@142.51--142.66) [100259]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(b_24, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion b != c might not hold. (BinomialHeap.vpr@142.51--142.66) [100260]"}
            b_24 != c;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, a_2, b_24) == segParent(Heap, b_24, c);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(a_2, c):=PostMask[null, heapseg(a_2, c)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segLength(a, c) == old(segLength(a, b)) + old(segLength(b, c))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@144.10--144.25) [100261]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@144.33--144.48) [100262]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@144.56--144.71) [100263]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segLength(PostHeap, a_2, c) == segLength(oldHeap, a_2, b_24) + segLength(oldHeap, b_24, c);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of (forall i: Int :: { segDegree(a, c, i) } { old(segDegree(a, b, i)) } 0 <= i && i < old(segLength(a, b)) ==> segDegree(a, c, i) == old(segDegree(a, b, i)))
      if (*) {
        if (0 <= i_92) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@145.44--145.59) [100264]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
        }
        if (0 <= i_92 && i_92 < segLength(oldHeap, a_2, b_24)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := PostHeap;
            ExhaleWellDef0Mask := PostMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@145.65--145.83) [100265]"}
              NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i might not hold. (BinomialHeap.vpr@145.65--145.83) [100266]"}
              0 <= i_92;
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i < segLength(a, c) might not hold. (BinomialHeap.vpr@145.65--145.83) [100267]"}
              i_92 < segLength(PostHeap, a_2, c);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
            PostHeap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@145.91--145.109) [100268]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i might not hold. (BinomialHeap.vpr@145.91--145.109) [100269]"}
              0 <= i_92;
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i < segLength(a, b) might not hold. (BinomialHeap.vpr@145.91--145.109) [100270]"}
              i_92 < segLength(oldHeap, a_2, b_24);
            // Finish exhale
            // Stop execution
            assume false;
          }
        }
        assume false;
      }
    assume (forall i_1: int ::
      { segDegree#frame(PostHeap[null, heapseg(a_2, c)], a_2, c, i_1) } { segDegree#frame(oldHeap[null, heapseg(a_2, b_24)], a_2, b_24, i_1) }
      0 <= i_1 && i_1 < segLength(oldHeap, a_2, b_24) ==> segDegree(PostHeap, a_2, c, i_1) == segDegree(oldHeap, a_2, b_24, i_1)
    );
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of (forall i: Int :: { segDegree(a, c, i) } old(segLength(a, b)) <= i && i < segLength(a, c) ==> segDegree(a, c, i) == old(segDegree(b, c, i - segLength(a, b))))
      if (*) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@146.30--146.45) [100271]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (segLength(oldHeap, a_2, b_24) <= i_93) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := PostHeap;
            ExhaleWellDef0Mask := PostMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@146.59--146.74) [100272]"}
              NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
            PostHeap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        }
        if (segLength(oldHeap, a_2, b_24) <= i_93 && i_93 < segLength(PostHeap, a_2, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := PostHeap;
            ExhaleWellDef0Mask := PostMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@146.79--146.97) [100273]"}
              NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i might not hold. (BinomialHeap.vpr@146.79--146.97) [100274]"}
              0 <= i_93;
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i < segLength(a, c) might not hold. (BinomialHeap.vpr@146.79--146.97) [100275]"}
              i_93 < segLength(PostHeap, a_2, c);
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
            PostHeap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@146.125--146.140) [100276]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@146.105--146.141) [100277]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
            assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= i - segLength(a, b) might not hold. (BinomialHeap.vpr@146.105--146.141) [100278]"}
              0 <= i_93 - segLength(oldHeap, a_2, b_24);
            assert {:msg "  Precondition of function segDegree might not hold. Assertion i - segLength(a, b) < segLength(b, c) might not hold. (BinomialHeap.vpr@146.105--146.141) [100279]"}
              i_93 - segLength(oldHeap, a_2, b_24) < segLength(oldHeap, b_24, c);
            // Finish exhale
            // Stop execution
            assume false;
          }
        }
        assume false;
      }
    assume (forall i_3: int ::
      { segDegree#frame(PostHeap[null, heapseg(a_2, c)], a_2, c, i_3) }
      segLength(oldHeap, a_2, b_24) <= i_3 && i_3 < segLength(PostHeap, a_2, c) ==> segDegree(PostHeap, a_2, c, i_3) == segDegree(oldHeap, b_24, c, i_3 - segLength(oldHeap, a_2, b_24))
    );
    assume state(PostHeap, PostMask);
    if (c != null) {
      perm := FullPerm;
      PostMask := PostMask[null, tree(c):=PostMask[null, tree(c)] + perm];
      assume state(PostHeap, PostMask);
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of treeDegree(c) == old(treeDegree(c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.35--147.48) [100280]"}
            NoPerm < perm ==> NoPerm < PostMask[null, tree(c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.56--147.69) [100281]"}
            NoPerm < perm ==> NoPerm < oldMask[null, tree(c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume treeDegree(PostHeap, c) == treeDegree(oldHeap, c);
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of treeSize(c) == old(treeSize(c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.74--147.85) [100282]"}
            NoPerm < perm ==> NoPerm < PostMask[null, tree(c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.93--147.104) [100283]"}
            NoPerm < perm ==> NoPerm < oldMask[null, tree(c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume treeSize(PostHeap, c) == treeSize(oldHeap, c);
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of treeParent(c) == old(treeParent(c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.109--147.122) [100284]"}
            NoPerm < perm ==> NoPerm < PostMask[null, tree(c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.130--147.143) [100285]"}
            NoPerm < perm ==> NoPerm < oldMask[null, tree(c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume treeParent(PostHeap, c) == treeParent(oldHeap, c);
    }
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of old(sorted(a, b)) && (old(sorted(b, c)) && old(0 < segLength(a, b) && 0 < segLength(b, c) ==> segDegree(a, b, segLength(a, b) - 1) < segDegree(b, c, 0)))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@149.14--149.26) [100286]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (sorted(oldHeap, a_2, b_24)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@149.35--149.47) [100287]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (sorted(oldHeap, b_24, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@150.9--150.24) [100288]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (0 < segLength(oldHeap, a_2, b_24)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@150.32--150.47) [100289]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
          if (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@150.68--150.83) [100290]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@150.52--150.88) [100291]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@150.52--150.88) [100292]"}
                0 <= segLength(oldHeap, a_2, b_24) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@150.52--150.88) [100293]"}
                segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@150.91--150.109) [100294]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@150.91--150.109) [100295]"}
                0 < segLength(oldHeap, b_24, c);
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
        }
      }
    if (sorted(oldHeap, a_2, b_24) && (sorted(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of sorted(a, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@150.115--150.127) [100296]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume sorted(PostHeap, a_2, c);
    }
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of old(presorted(a, b)) && (old(presorted(b, c)) && old(0 < segLength(a, b) && 0 < segLength(b, c) ==> segDegree(a, b, segLength(a, b) - 1) <= segDegree(b, c, 0) && ((2 <= segLength(a, b) && segDegree(a, b, segLength(a, b) - 1) == segDegree(a, b, segLength(a, b) - 2) ==> segDegree(a, b, segLength(a, b) - 1) < segDegree(b, c, 0)) && (2 <= segLength(b, c) && segDegree(b, c, 0) == segDegree(b, c, 1) ==> segDegree(a, b, segLength(a, b) - 1) < segDegree(b, c, 0)))))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@152.14--152.29) [100297]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (presorted(oldHeap, a_2, b_24)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@152.38--152.53) [100298]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (presorted(oldHeap, b_24, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@153.9--153.24) [100299]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (0 < segLength(oldHeap, a_2, b_24)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@153.32--153.47) [100300]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
          if (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@153.68--153.83) [100301]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@153.52--153.88) [100302]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@153.52--153.88) [100303]"}
                0 <= segLength(oldHeap, a_2, b_24) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@153.52--153.88) [100304]"}
                segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@153.92--153.110) [100305]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@153.92--153.110) [100306]"}
                0 < segLength(oldHeap, b_24, c);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) <= segDegree(oldHeap, b_24, c, 0)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.7--154.22) [100307]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                // Finish exhale
                // Stop execution
                assume false;
              }
              if (2 <= segLength(oldHeap, a_2, b_24)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.42--154.57) [100308]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.26--154.62) [100309]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@154.26--154.62) [100310]"}
                    0 <= segLength(oldHeap, a_2, b_24) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@154.26--154.62) [100311]"}
                    segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.82--154.97) [100312]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.66--154.102) [100313]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 2 might not hold. (BinomialHeap.vpr@154.66--154.102) [100314]"}
                    0 <= segLength(oldHeap, a_2, b_24) - 2;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 2 < segLength(a, b) might not hold. (BinomialHeap.vpr@154.66--154.102) [100315]"}
                    segLength(oldHeap, a_2, b_24) - 2 < segLength(oldHeap, a_2, b_24);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
              }
              if (2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.123--154.138) [100316]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@154.107--154.143) [100317]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@154.107--154.143) [100318]"}
                    0 <= segLength(oldHeap, a_2, b_24) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@154.107--154.143) [100319]"}
                    segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@154.146--154.164) [100320]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@154.146--154.164) [100321]"}
                    0 < segLength(oldHeap, b_24, c);
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
              }
              if (2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.7--155.22) [100322]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(oldHeap, b_24, c)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.26--155.44) [100323]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@155.26--155.44) [100324]"}
                      0 < segLength(oldHeap, b_24, c);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.48--155.66) [100325]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(b, c) might not hold. (BinomialHeap.vpr@155.48--155.66) [100326]"}
                      1 < segLength(oldHeap, b_24, c);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                }
                if (2 <= segLength(oldHeap, b_24, c) && segDegree(oldHeap, b_24, c, 0) == segDegree(oldHeap, b_24, c, 1)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@155.87--155.102) [100327]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@155.71--155.107) [100328]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@155.71--155.107) [100329]"}
                      0 <= segLength(oldHeap, a_2, b_24) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@155.71--155.107) [100330]"}
                      segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := oldHeap;
                    ExhaleWellDef0Mask := oldMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@155.110--155.128) [100331]"}
                      NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@155.110--155.128) [100332]"}
                      0 < segLength(oldHeap, b_24, c);
                    // Finish exhale
                    // Stop execution
                    assume false;
                  }
                }
              }
            }
          }
        }
      }
    if (presorted(oldHeap, a_2, b_24) && (presorted(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) <= segDegree(oldHeap, b_24, c, 0) && ((2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)) && (2 <= segLength(oldHeap, b_24, c) && segDegree(oldHeap, b_24, c, 0) == segDegree(oldHeap, b_24, c, 1) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))))) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of presorted(a, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@156.5--156.20) [100333]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume presorted(PostHeap, a_2, c);
    }
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of old(validChildren(a, b)) && (old(validChildren(b, c)) && old(0 < segLength(a, b) && 0 < segLength(b, c) ==> segDegree(a, b, segLength(a, b) - 1) == segDegree(b, c, 0) + 1))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@157.14--157.33) [100334]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (validChildren(oldHeap, a_2, b_24)) {
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@157.42--157.61) [100335]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          // Finish exhale
          // Stop execution
          assume false;
        }
        if (validChildren(oldHeap, b_24, c)) {
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@158.9--158.24) [100336]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (0 < segLength(oldHeap, a_2, b_24)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@158.32--158.47) [100337]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
          if (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@158.68--158.83) [100338]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@158.52--158.88) [100339]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(a, b) - 1 might not hold. (BinomialHeap.vpr@158.52--158.88) [100340]"}
                0 <= segLength(oldHeap, a_2, b_24) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(a, b) - 1 < segLength(a, b) might not hold. (BinomialHeap.vpr@158.52--158.88) [100341]"}
                segLength(oldHeap, a_2, b_24) - 1 < segLength(oldHeap, a_2, b_24);
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@158.92--158.110) [100342]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(b, c) might not hold. (BinomialHeap.vpr@158.92--158.110) [100343]"}
                0 < segLength(oldHeap, b_24, c);
              // Finish exhale
              // Stop execution
              assume false;
            }
          }
        }
      }
    if (validChildren(oldHeap, a_2, b_24) && (validChildren(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, b_24, c, 0) + 1))) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of validChildren(a, c)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@160.1--160.20) [100344]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume validChildren(PostHeap, a_2, c);
    }
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(a, c) == old(segSize(a, b)) + old(segSize(b, c))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@161.10--161.23) [100345]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@161.31--161.44) [100346]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@161.52--161.65) [100347]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, a_2, c) == segSize(oldHeap, a_2, b_24) + segSize(oldHeap, b_24, c);
    assume state(PostHeap, PostMask);
    if (a_2 != b_24) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segParent(a, c) == old(segParent(a, b))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@162.21--162.36) [100348]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != c might not hold. (BinomialHeap.vpr@162.21--162.36) [100349]"}
            a_2 != c;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@162.44--162.59) [100350]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(a_2, b_24)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != b might not hold. (BinomialHeap.vpr@162.44--162.59) [100351]"}
            a_2 != b_24;
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume segParent(PostHeap, a_2, c) == segParent(oldHeap, a_2, b_24);
    }
    assume state(PostHeap, PostMask);
    if (b_24 != c) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segParent(a, c) == old(segParent(b, c))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@163.21--163.36) [100352]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(a_2, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion a != c might not hold. (BinomialHeap.vpr@163.21--163.36) [100353]"}
            a_2 != c;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@163.44--163.59) [100354]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(b_24, c)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion b != c might not hold. (BinomialHeap.vpr@163.44--163.59) [100355]"}
            b_24 != c;
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume segParent(PostHeap, a_2, c) == segParent(oldHeap, b_24, c);
    }
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Translating statement: if (a != b) -- BinomialHeap.vpr@165.2--170.3
    if (a_2 != b_24) {
      
      // -- Translating statement: unfold acc(heapseg(a, b), write) -- BinomialHeap.vpr@166.3--166.23
        assume heapseg#trigger(Heap, heapseg(a_2, b_24));
        assume Heap[null, heapseg(a_2, b_24)] == FrameFragment((if a_2 != b_24 then CombineFrames(Heap[null, tree(a_2)], CombineFrames(FrameFragment(Heap[a_2, sibling]), CombineFrames(Heap[null, heapseg(Heap[a_2, sibling], b_24)], FrameFragment((if Heap[a_2, sibling] != b_24 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Unfolding heapseg(a, b) might fail. There might be insufficient permission to access heapseg(a, b) (BinomialHeap.vpr@166.3--166.23) [100358]"}
            perm <= Mask[null, heapseg(a_2, b_24)];
        }
        Mask := Mask[null, heapseg(a_2, b_24):=Mask[null, heapseg(a_2, b_24)] - perm];
        
        // -- Update version of predicate
          if (!HasDirectPerm(Mask, null, heapseg(a_2, b_24))) {
            havoc newVersion;
            Heap := Heap[null, heapseg(a_2, b_24):=newVersion];
          }
        if (a_2 != b_24) {
          perm := FullPerm;
          Mask := Mask[null, tree(a_2):=Mask[null, tree(a_2)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(a_2, b_24), Heap[null, heapseg(a_2, b_24)], tree(a_2), Heap[null, tree(a_2)]);
          assume state(Heap, Mask);
          perm := FullPerm;
          assume a_2 != null;
          Mask := Mask[a_2, sibling:=Mask[a_2, sibling] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[a_2, sibling], b_24):=Mask[null, heapseg(Heap[a_2, sibling], b_24)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(a_2, b_24), Heap[null, heapseg(a_2, b_24)], heapseg(Heap[a_2, sibling], b_24), Heap[null, heapseg(Heap[a_2, sibling], b_24)]);
          assume state(Heap, Mask);
          if (Heap[a_2, sibling] != b_24) {
            assume state(Heap, Mask);
            assume treeParent(Heap, a_2) == segParent(Heap, Heap[a_2, sibling], b_24);
          }
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: concat(a.sibling, b, c) -- BinomialHeap.vpr@167.3--167.26
        PreCallHeap := Heap;
        PreCallMask := Mask;
        
        // -- Check definedness of a.sibling
          assert {:msg "  Method call might fail. There might be insufficient permission to access a.sibling (BinomialHeap.vpr@167.3--167.26) [100362]"}
            HasDirectPerm(Mask, a_2, sibling);
        arg_a := Heap[a_2, sibling];
        
        // -- Exhaling precondition
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(a.sibling, b) (BinomialHeap.vpr@167.3--167.26) [100363]"}
              perm <= Mask[null, heapseg(arg_a, b_24)];
          }
          Mask := Mask[null, heapseg(arg_a, b_24):=Mask[null, heapseg(arg_a, b_24)] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(b, c) (BinomialHeap.vpr@167.3--167.26) [100364]"}
              perm <= Mask[null, heapseg(b_24, c)];
          }
          Mask := Mask[null, heapseg(b_24, c):=Mask[null, heapseg(b_24, c)] - perm];
          if (c != null) {
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@167.3--167.26) [100365]"}
                perm <= Mask[null, tree(c)];
            }
            Mask := Mask[null, tree(c):=Mask[null, tree(c)] - perm];
          }
          if (arg_a != b_24 && b_24 != c) {
            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(a.sibling, b) == segParent(b, c) might not hold. (BinomialHeap.vpr@167.3--167.26) [100366]"}
              segParent(Heap, arg_a, b_24) == segParent(Heap, b_24, c);
          }
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
        
        // -- Inhaling postcondition
          perm := FullPerm;
          Mask := Mask[null, heapseg(arg_a, c):=Mask[null, heapseg(arg_a, c)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume segLength(Heap, arg_a, c) == segLength(PreCallHeap, arg_a, b_24) + segLength(PreCallHeap, b_24, c);
          assume state(Heap, Mask);
          assume (forall i_8_2: int ::
            { segDegree#frame(Heap[null, heapseg(arg_a, c)], arg_a, c, i_8_2) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a, b_24)], arg_a, b_24, i_8_2) }
            0 <= i_8_2 && i_8_2 < segLength(PreCallHeap, arg_a, b_24) ==> segDegree(Heap, arg_a, c, i_8_2) == segDegree(PreCallHeap, arg_a, b_24, i_8_2)
          );
          assume state(Heap, Mask);
          assume (forall i_9_1: int ::
            { segDegree#frame(Heap[null, heapseg(arg_a, c)], arg_a, c, i_9_1) }
            segLength(PreCallHeap, arg_a, b_24) <= i_9_1 && i_9_1 < segLength(Heap, arg_a, c) ==> segDegree(Heap, arg_a, c, i_9_1) == segDegree(PreCallHeap, b_24, c, i_9_1 - segLength(PreCallHeap, arg_a, b_24))
          );
          if (c != null) {
            perm := FullPerm;
            Mask := Mask[null, tree(c):=Mask[null, tree(c)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume treeDegree(Heap, c) == treeDegree(PreCallHeap, c);
            assume state(Heap, Mask);
            assume treeSize(Heap, c) == treeSize(PreCallHeap, c);
            assume state(Heap, Mask);
            assume treeParent(Heap, c) == treeParent(PreCallHeap, c);
          }
          if (sorted(PreCallHeap, arg_a, b_24) && (sorted(PreCallHeap, b_24, c) && (0 < segLength(PreCallHeap, arg_a, b_24) && 0 < segLength(PreCallHeap, b_24, c) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) < segDegree(PreCallHeap, b_24, c, 0)))) {
            assume state(Heap, Mask);
            assume sorted(Heap, arg_a, c);
          }
          if (presorted(PreCallHeap, arg_a, b_24) && (presorted(PreCallHeap, b_24, c) && (0 < segLength(PreCallHeap, arg_a, b_24) && 0 < segLength(PreCallHeap, b_24, c) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) <= segDegree(PreCallHeap, b_24, c, 0) && ((2 <= segLength(PreCallHeap, arg_a, b_24) && segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) == segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 2) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) < segDegree(PreCallHeap, b_24, c, 0)) && (2 <= segLength(PreCallHeap, b_24, c) && segDegree(PreCallHeap, b_24, c, 0) == segDegree(PreCallHeap, b_24, c, 1) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) < segDegree(PreCallHeap, b_24, c, 0)))))) {
            assume state(Heap, Mask);
            assume presorted(Heap, arg_a, c);
          }
          if (validChildren(PreCallHeap, arg_a, b_24) && (validChildren(PreCallHeap, b_24, c) && (0 < segLength(PreCallHeap, arg_a, b_24) && 0 < segLength(PreCallHeap, b_24, c) ==> segDegree(PreCallHeap, arg_a, b_24, segLength(PreCallHeap, arg_a, b_24) - 1) == segDegree(PreCallHeap, b_24, c, 0) + 1))) {
            assume state(Heap, Mask);
            assume validChildren(Heap, arg_a, c);
          }
          assume state(Heap, Mask);
          assume segSize(Heap, arg_a, c) == segSize(PreCallHeap, arg_a, b_24) + segSize(PreCallHeap, b_24, c);
          if (arg_a != b_24) {
            assume state(Heap, Mask);
            assume segParent(Heap, arg_a, c) == segParent(PreCallHeap, arg_a, b_24);
          }
          if (b_24 != c) {
            assume state(Heap, Mask);
            assume segParent(Heap, arg_a, c) == segParent(PreCallHeap, b_24, c);
          }
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: assert c != null ==>
  //   (unfolding acc(tree(a), write) in
  //     (unfolding acc(tree(c), 1 / 2) in a != c)) -- BinomialHeap.vpr@168.3--168.82
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (c != null) {
          
          // -- Check definedness of (unfolding acc(tree(a), write) in (unfolding acc(tree(c), 1 / 2) in a != c))
            UnfoldingHeap := ExhaleWellDef0Heap;
            UnfoldingMask := ExhaleWellDef0Mask;
            assume tree#trigger(UnfoldingHeap, tree(a_2));
            assume UnfoldingHeap[null, tree(a_2)] == CombineFrames(FrameFragment(UnfoldingHeap[a_2, key]), CombineFrames(FrameFragment(UnfoldingHeap[a_2, degree]), CombineFrames(FrameFragment(UnfoldingHeap[a_2, child]), CombineFrames(FrameFragment(UnfoldingHeap[a_2, parent]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[a_2, child], null)], CombineFrames(FrameFragment((if 0 < UnfoldingHeap[a_2, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if UnfoldingHeap[a_2, child] != null then EmptyFrame else EmptyFrame))))))));
            ExhaleWellDef1Heap := UnfoldingHeap;
            ExhaleWellDef1Mask := UnfoldingMask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Assert might fail. There might be insufficient permission to access tree(a) (BinomialHeap.vpr@168.10--168.82) [100367]"}
                perm <= UnfoldingMask[null, tree(a_2)];
            }
            UnfoldingMask := UnfoldingMask[null, tree(a_2):=UnfoldingMask[null, tree(a_2)] - perm];
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, key:=UnfoldingMask[a_2, key] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, degree:=UnfoldingMask[a_2, degree] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, child:=UnfoldingMask[a_2, child] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            perm := FullPerm;
            assume a_2 != null;
            UnfoldingMask := UnfoldingMask[a_2, parent:=UnfoldingMask[a_2, parent] + perm];
            assume state(UnfoldingHeap, UnfoldingMask);
            assume 0 <= UnfoldingHeap[a_2, degree];
            perm := FullPerm;
            UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[a_2, child], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[a_2, child], null)] + perm];
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(tree(a_2), UnfoldingHeap[null, tree(a_2)], heapseg(UnfoldingHeap[a_2, child], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[a_2, child], null)]);
            assume state(UnfoldingHeap, UnfoldingMask);
            assume state(UnfoldingHeap, UnfoldingMask);
            assume UnfoldingHeap[a_2, degree] == segLength(UnfoldingHeap, UnfoldingHeap[a_2, child], null);
            if (0 < UnfoldingHeap[a_2, degree]) {
              assume state(UnfoldingHeap, UnfoldingMask);
              assume segDegree(UnfoldingHeap, UnfoldingHeap[a_2, child], null, 0) == UnfoldingHeap[a_2, degree] - 1;
            }
            assume state(UnfoldingHeap, UnfoldingMask);
            assume validChildren(UnfoldingHeap, UnfoldingHeap[a_2, child], null);
            if (UnfoldingHeap[a_2, child] != null) {
              assume state(UnfoldingHeap, UnfoldingMask);
              assume segParent(UnfoldingHeap, UnfoldingHeap[a_2, child], null) == a_2;
            }
            assume state(UnfoldingHeap, UnfoldingMask);
            Unfolding1Heap := UnfoldingHeap;
            Unfolding1Mask := UnfoldingMask;
            assume tree#trigger(Unfolding1Heap, tree(c));
            assume Unfolding1Heap[null, tree(c)] == CombineFrames(FrameFragment(Unfolding1Heap[c, key]), CombineFrames(FrameFragment(Unfolding1Heap[c, degree]), CombineFrames(FrameFragment(Unfolding1Heap[c, child]), CombineFrames(FrameFragment(Unfolding1Heap[c, parent]), CombineFrames(Unfolding1Heap[null, heapseg(Unfolding1Heap[c, child], null)], CombineFrames(FrameFragment((if 0 < Unfolding1Heap[c, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Unfolding1Heap[c, child] != null then EmptyFrame else EmptyFrame))))))));
            ExhaleWellDef1Heap := Unfolding1Heap;
            ExhaleWellDef1Mask := Unfolding1Mask;
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [100368]"}
              perm >= NoPerm;
            if (perm != NoPerm) {
              assert {:msg "  Assert might fail. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@168.10--168.82) [100369]"}
                perm <= Unfolding1Mask[null, tree(c)];
            }
            Unfolding1Mask := Unfolding1Mask[null, tree(c):=Unfolding1Mask[null, tree(c)] - perm];
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [100370]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, key:=Unfolding1Mask[c, key] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [100371]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, degree:=Unfolding1Mask[c, degree] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [100372]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, child:=Unfolding1Mask[c, child] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [100373]"}
              perm >= NoPerm;
            assume perm > NoPerm ==> c != null;
            Unfolding1Mask := Unfolding1Mask[c, parent:=Unfolding1Mask[c, parent] + perm];
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume 0 <= Unfolding1Heap[c, degree];
            perm := 1 / 2;
            assert {:msg "  Assert might fail. Fraction 1 / 2 might be negative. (BinomialHeap.vpr@168.10--168.82) [100374]"}
              perm >= NoPerm;
            Unfolding1Mask := Unfolding1Mask[null, heapseg(Unfolding1Heap[c, child], null):=Unfolding1Mask[null, heapseg(Unfolding1Heap[c, child], null)] + perm];
            
            // -- Extra unfolding of predicate
              assume InsidePredicate(tree(c), Unfolding1Heap[null, tree(c)], heapseg(Unfolding1Heap[c, child], null), Unfolding1Heap[null, heapseg(Unfolding1Heap[c, child], null)]);
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume Unfolding1Heap[c, degree] == segLength(Unfolding1Heap, Unfolding1Heap[c, child], null);
            if (0 < Unfolding1Heap[c, degree]) {
              assume state(Unfolding1Heap, Unfolding1Mask);
              assume segDegree(Unfolding1Heap, Unfolding1Heap[c, child], null, 0) == Unfolding1Heap[c, degree] - 1;
            }
            assume state(Unfolding1Heap, Unfolding1Mask);
            assume validChildren(Unfolding1Heap, Unfolding1Heap[c, child], null);
            if (Unfolding1Heap[c, child] != null) {
              assume state(Unfolding1Heap, Unfolding1Mask);
              assume segParent(Unfolding1Heap, Unfolding1Heap[c, child], null) == c;
            }
            assume state(Unfolding1Heap, Unfolding1Mask);
            
            // -- Free assumptions (exp module)
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, key:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, degree:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, child:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, parent:=true]];
              havoc newPMask;
              assume (forall <A, B> o_29: Ref, f_81: (Field A B) ::
                { newPMask[o_29, f_81] }
                Heap[null, tree#sm(c)][o_29, f_81] || Heap[null, heapseg#sm(Heap[c, child], null)][o_29, f_81] ==> newPMask[o_29, f_81]
              );
              Heap := Heap[null, tree#sm(c):=newPMask];
              assume state(Heap, Mask);
            
            // -- Free assumptions (exp module)
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, key:=true]];
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, degree:=true]];
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, child:=true]];
              Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, parent:=true]];
              havoc newPMask;
              assume (forall <A, B> o_77: Ref, f_52: (Field A B) ::
                { newPMask[o_77, f_52] }
                Heap[null, tree#sm(a_2)][o_77, f_52] || Heap[null, heapseg#sm(Heap[a_2, child], null)][o_77, f_52] ==> newPMask[o_77, f_52]
              );
              Heap := Heap[null, tree#sm(a_2):=newPMask];
              assume state(Heap, Mask);
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, key:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, degree:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, child:=true]];
              Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, parent:=true]];
              havoc newPMask;
              assume (forall <A, B> o_78: Ref, f_49: (Field A B) ::
                { newPMask[o_78, f_49] }
                Heap[null, tree#sm(c)][o_78, f_49] || Heap[null, heapseg#sm(Heap[c, child], null)][o_78, f_49] ==> newPMask[o_78, f_49]
              );
              Heap := Heap[null, tree#sm(c):=newPMask];
              assume state(Heap, Mask);
          assert {:msg "  Assert might fail. Assertion a != c might not hold. (BinomialHeap.vpr@168.10--168.82) [100375]"}
            a_2 != c;
        }
        
        // -- Free assumptions (exhale module)
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, key:=true]];
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, degree:=true]];
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, child:=true]];
          Heap := Heap[null, tree#sm(a_2):=Heap[null, tree#sm(a_2)][a_2, parent:=true]];
          havoc newPMask;
          assume (forall <A, B> o_63: Ref, f_86: (Field A B) ::
            { newPMask[o_63, f_86] }
            Heap[null, tree#sm(a_2)][o_63, f_86] || Heap[null, heapseg#sm(Heap[a_2, child], null)][o_63, f_86] ==> newPMask[o_63, f_86]
          );
          Heap := Heap[null, tree#sm(a_2):=newPMask];
          assume state(Heap, Mask);
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, key:=true]];
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, degree:=true]];
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, child:=true]];
          Heap := Heap[null, tree#sm(c):=Heap[null, tree#sm(c)][c, parent:=true]];
          havoc newPMask;
          assume (forall <A, B> o_79: Ref, f_87: (Field A B) ::
            { newPMask[o_79, f_87] }
            Heap[null, tree#sm(c)][o_79, f_87] || Heap[null, heapseg#sm(Heap[c, child], null)][o_79, f_87] ==> newPMask[o_79, f_87]
          );
          Heap := Heap[null, tree#sm(c):=newPMask];
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(a, c), write) -- BinomialHeap.vpr@169.3--169.21
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (a_2 != c) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(a, c) might fail. There might be insufficient permission to access tree(a) (BinomialHeap.vpr@169.3--169.21) [100378]"}
              perm <= Mask[null, tree(a_2)];
          }
          Mask := Mask[null, tree(a_2):=Mask[null, tree(a_2)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(a_2, c), Heap[null, heapseg(a_2, c)], tree(a_2), Heap[null, tree(a_2)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(a, c) might fail. There might be insufficient permission to access a.sibling (BinomialHeap.vpr@169.3--169.21) [100380]"}
              perm <= Mask[a_2, sibling];
          }
          Mask := Mask[a_2, sibling:=Mask[a_2, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(a, c) might fail. There might be insufficient permission to access heapseg(a.sibling, c) (BinomialHeap.vpr@169.3--169.21) [100382]"}
              perm <= Mask[null, heapseg(Heap[a_2, sibling], c)];
          }
          Mask := Mask[null, heapseg(Heap[a_2, sibling], c):=Mask[null, heapseg(Heap[a_2, sibling], c)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(a_2, c), Heap[null, heapseg(a_2, c)], heapseg(Heap[a_2, sibling], c), Heap[null, heapseg(Heap[a_2, sibling], c)]);
          if (Heap[a_2, sibling] != c) {
            assert {:msg "  Folding heapseg(a, c) might fail. Assertion treeParent(a) == segParent(a.sibling, c) might not hold. (BinomialHeap.vpr@169.3--169.21) [100383]"}
              treeParent(Heap, a_2) == segParent(Heap, Heap[a_2, sibling], c);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(a_2, c):=Mask[null, heapseg(a_2, c)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(a_2, c));
        assume Heap[null, heapseg(a_2, c)] == FrameFragment((if a_2 != c then CombineFrames(Heap[null, tree(a_2)], CombineFrames(FrameFragment(Heap[a_2, sibling]), CombineFrames(Heap[null, heapseg(Heap[a_2, sibling], c)], FrameFragment((if Heap[a_2, sibling] != c then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(a_2, c))) {
          Heap := Heap[null, heapseg#sm(a_2, c):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(a_2, c):=freshVersion];
        }
        if (a_2 != c) {
          havoc newPMask;
          assume (forall <A, B> o_80: Ref, f_88: (Field A B) ::
            { newPMask[o_80, f_88] }
            Heap[null, heapseg#sm(a_2, c)][o_80, f_88] || Heap[null, tree#sm(a_2)][o_80, f_88] ==> newPMask[o_80, f_88]
          );
          Heap := Heap[null, heapseg#sm(a_2, c):=newPMask];
          Heap := Heap[null, heapseg#sm(a_2, c):=Heap[null, heapseg#sm(a_2, c)][a_2, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_81: Ref, f_57: (Field A B) ::
            { newPMask[o_81, f_57] }
            Heap[null, heapseg#sm(a_2, c)][o_81, f_57] || Heap[null, heapseg#sm(Heap[a_2, sibling], c)][o_81, f_57] ==> newPMask[o_81, f_57]
          );
          Heap := Heap[null, heapseg#sm(a_2, c):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of concat might not hold. There might be insufficient permission to access heapseg(a, c) (BinomialHeap.vpr@143.10--143.23) [100385]"}
        perm <= Mask[null, heapseg(a_2, c)];
    }
    Mask := Mask[null, heapseg(a_2, c):=Mask[null, heapseg(a_2, c)] - perm];
    assert {:msg "  Postcondition of concat might not hold. Assertion segLength(a, c) == old(segLength(a, b)) + old(segLength(b, c)) might not hold. (BinomialHeap.vpr@144.10--144.72) [100386]"}
      segLength(Heap, a_2, c) == segLength(oldHeap, a_2, b_24) + segLength(oldHeap, b_24, c);
    if (*) {
      if (0 <= i_4_1 && i_4_1 < segLength(oldHeap, a_2, b_24)) {
        assert {:msg "  Postcondition of concat might not hold. Assertion segDegree(a, c, i) == old(segDegree(a, b, i)) might not hold. (BinomialHeap.vpr@145.10--145.110) [100387]"}
          segDegree(Heap, a_2, c, i_4_1) == segDegree(oldHeap, a_2, b_24, i_4_1);
      }
      assume false;
    }
    assume (forall i_5_1_1: int ::
      { segDegree#frame(Heap[null, heapseg(a_2, c)], a_2, c, i_5_1_1) } { segDegree#frame(oldHeap[null, heapseg(a_2, b_24)], a_2, b_24, i_5_1_1) }
      0 <= i_5_1_1 && i_5_1_1 < segLength(oldHeap, a_2, b_24) ==> segDegree(Heap, a_2, c, i_5_1_1) == segDegree(oldHeap, a_2, b_24, i_5_1_1)
    );
    if (*) {
      if (segLength(oldHeap, a_2, b_24) <= i_6_1 && i_6_1 < segLength(Heap, a_2, c)) {
        assert {:msg "  Postcondition of concat might not hold. Assertion segDegree(a, c, i) == old(segDegree(b, c, i - segLength(a, b))) might not hold. (BinomialHeap.vpr@146.10--146.142) [100388]"}
          segDegree(Heap, a_2, c, i_6_1) == segDegree(oldHeap, b_24, c, i_6_1 - segLength(oldHeap, a_2, b_24));
      }
      assume false;
    }
    assume (forall i_7_1_1: int ::
      { segDegree#frame(Heap[null, heapseg(a_2, c)], a_2, c, i_7_1_1) }
      segLength(oldHeap, a_2, b_24) <= i_7_1_1 && i_7_1_1 < segLength(Heap, a_2, c) ==> segDegree(Heap, a_2, c, i_7_1_1) == segDegree(oldHeap, b_24, c, i_7_1_1 - segLength(oldHeap, a_2, b_24))
    );
    if (c != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Postcondition of concat might not hold. There might be insufficient permission to access tree(c) (BinomialHeap.vpr@147.10--147.144) [100389]"}
          perm <= Mask[null, tree(c)];
      }
      Mask := Mask[null, tree(c):=Mask[null, tree(c)] - perm];
      assert {:msg "  Postcondition of concat might not hold. Assertion treeDegree(c) == old(treeDegree(c)) might not hold. (BinomialHeap.vpr@147.10--147.144) [100390]"}
        treeDegree(Heap, c) == treeDegree(oldHeap, c);
      assert {:msg "  Postcondition of concat might not hold. Assertion treeSize(c) == old(treeSize(c)) might not hold. (BinomialHeap.vpr@147.10--147.144) [100391]"}
        treeSize(Heap, c) == treeSize(oldHeap, c);
      assert {:msg "  Postcondition of concat might not hold. Assertion treeParent(c) == old(treeParent(c)) might not hold. (BinomialHeap.vpr@147.10--147.144) [100392]"}
        treeParent(Heap, c) == treeParent(oldHeap, c);
    }
    if (sorted(oldHeap, a_2, b_24) && (sorted(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))) {
      assert {:msg "  Postcondition of concat might not hold. Assertion sorted(a, c) might not hold. (BinomialHeap.vpr@149.10--150.127) [100393]"}
        sorted(Heap, a_2, c);
    }
    if (presorted(oldHeap, a_2, b_24) && (presorted(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) <= segDegree(oldHeap, b_24, c, 0) && ((2 <= segLength(oldHeap, a_2, b_24) && segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 2) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)) && (2 <= segLength(oldHeap, b_24, c) && segDegree(oldHeap, b_24, c, 0) == segDegree(oldHeap, b_24, c, 1) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) < segDegree(oldHeap, b_24, c, 0)))))) {
      assert {:msg "  Postcondition of concat might not hold. Assertion presorted(a, c) might not hold. (BinomialHeap.vpr@152.10--156.20) [100394]"}
        presorted(Heap, a_2, c);
    }
    if (validChildren(oldHeap, a_2, b_24) && (validChildren(oldHeap, b_24, c) && (0 < segLength(oldHeap, a_2, b_24) && 0 < segLength(oldHeap, b_24, c) ==> segDegree(oldHeap, a_2, b_24, segLength(oldHeap, a_2, b_24) - 1) == segDegree(oldHeap, b_24, c, 0) + 1))) {
      assert {:msg "  Postcondition of concat might not hold. Assertion validChildren(a, c) might not hold. (BinomialHeap.vpr@157.10--160.20) [100395]"}
        validChildren(Heap, a_2, c);
    }
    assert {:msg "  Postcondition of concat might not hold. Assertion segSize(a, c) == old(segSize(a, b)) + old(segSize(b, c)) might not hold. (BinomialHeap.vpr@161.10--161.66) [100396]"}
      segSize(Heap, a_2, c) == segSize(oldHeap, a_2, b_24) + segSize(oldHeap, b_24, c);
    if (a_2 != b_24) {
      assert {:msg "  Postcondition of concat might not hold. Assertion segParent(a, c) == old(segParent(a, b)) might not hold. (BinomialHeap.vpr@162.10--162.60) [100397]"}
        segParent(Heap, a_2, c) == segParent(oldHeap, a_2, b_24);
    }
    if (b_24 != c) {
      assert {:msg "  Postcondition of concat might not hold. Assertion segParent(a, c) == old(segParent(b, c)) might not hold. (BinomialHeap.vpr@163.10--163.60) [100398]"}
        segParent(Heap, a_2, c) == segParent(oldHeap, b_24, c);
    }
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method findMinNode
// ==================================================

procedure findMinNode(arg: Ref) returns (res: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var x: Ref;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var newPMask: PMaskType;
  var vmin: int;
  var freshVersion: FrameType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var tmp: Ref;
  var newVersion: FrameType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[arg, $allocated];
  
  // -- Checked inhaling of precondition
    assume arg != null;
    perm := FullPerm;
    Mask := Mask[null, heapseg(arg, null):=Mask[null, heapseg(arg, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(arg, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@177.48--177.65) [100399]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(Heap, arg, null);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    assume res != null;
    assume state(PostHeap, PostMask);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(arg, res):=PostMask[null, heapseg(arg, res)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(arg, res)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@179.31--179.47) [100400]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg, res)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(PostHeap, arg, res);
    assume state(PostHeap, PostMask);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(res, null):=PostMask[null, heapseg(res, null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(res, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@180.32--180.49) [100401]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(PostHeap, res, null);
    assume state(PostHeap, PostMask);
    if (arg != res) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, null, 0)
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@181.45--181.64) [100402]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg, res)];
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@181.25--181.69) [100403]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg, res)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(arg, res) - 1 might not hold. (BinomialHeap.vpr@181.25--181.69) [100404]"}
            0 <= segLength(PostHeap, arg, res) - 1;
          assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(arg, res) - 1 < segLength(arg, res) might not hold. (BinomialHeap.vpr@181.25--181.69) [100405]"}
            segLength(PostHeap, arg, res) - 1 < segLength(PostHeap, arg, res);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@181.72--181.95) [100406]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(res, null) might not hold. (BinomialHeap.vpr@181.72--181.95) [100407]"}
            0 < segLength(PostHeap, res, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segDegree(PostHeap, arg, res, segLength(PostHeap, arg, res) - 1) < segDegree(PostHeap, res, null, 0);
    }
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(arg, res) + segSize(res, null) == old(segSize(arg, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@182.10--182.27) [100408]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg, res)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@182.30--182.48) [100409]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@182.56--182.74) [100410]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, arg, res) + segSize(PostHeap, res, null) == segSize(oldHeap, arg, null);
    assume state(PostHeap, PostMask);
    if (arg != res) {
      assume state(PostHeap, PostMask);
      
      // -- Check definedness of segParent(arg, res) == old(segParent(arg, null))
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := PostHeap;
          ExhaleWellDef0Mask := PostMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@183.25--183.44) [100411]"}
            NoPerm < perm ==> NoPerm < PostMask[null, heapseg(arg, res)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@183.25--183.44) [100412]"}
            arg != res;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
          PostHeap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := oldHeap;
          ExhaleWellDef0Mask := oldMask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@183.52--183.72) [100413]"}
            NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@183.52--183.72) [100414]"}
            arg != null;
          // Finish exhale
          // Stop execution
          assume false;
        }
      assume segParent(PostHeap, arg, res) == segParent(oldHeap, arg, null);
    }
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(res, null) == old(segParent(arg, null))
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@184.10--184.30) [100415]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(res, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@184.10--184.30) [100416]"}
          res != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@184.38--184.58) [100417]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg, null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@184.38--184.58) [100418]"}
          arg != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, res, null) == segParent(oldHeap, arg, null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[x, $allocated];
  
  // -- Translating statement: x := arg -- BinomialHeap.vpr@186.2--186.19
    x := arg;
    assume state(Heap, Mask);
  
  // -- Translating statement: res := arg -- BinomialHeap.vpr@187.2--187.12
    res := arg;
    assume state(Heap, Mask);
  
  // -- Translating statement: min := (unfolding acc(heapseg(x, null), write) in treeKey(x)) -- BinomialHeap.vpr@190.2--190.49
    
    // -- Check definedness of (unfolding acc(heapseg(x, null), write) in treeKey(x))
      UnfoldingHeap := Heap;
      UnfoldingMask := Mask;
      assume heapseg#trigger(UnfoldingHeap, heapseg(x, null));
      assume UnfoldingHeap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(UnfoldingHeap[null, tree(x)], CombineFrames(FrameFragment(UnfoldingHeap[x, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[x, sibling], null)], FrameFragment((if UnfoldingHeap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
      ExhaleWellDef0Heap := UnfoldingHeap;
      ExhaleWellDef0Mask := UnfoldingMask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Assignment might fail. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@190.2--190.49) [100419]"}
          perm <= UnfoldingMask[null, heapseg(x, null)];
      }
      UnfoldingMask := UnfoldingMask[null, heapseg(x, null):=UnfoldingMask[null, heapseg(x, null)] - perm];
      if (x != null) {
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, tree(x):=UnfoldingMask[null, tree(x)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(x, null), UnfoldingHeap[null, heapseg(x, null)], tree(x), UnfoldingHeap[null, tree(x)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        assume x != null;
        UnfoldingMask := UnfoldingMask[x, sibling:=UnfoldingMask[x, sibling] + perm];
        assume state(UnfoldingHeap, UnfoldingMask);
        perm := FullPerm;
        UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[x, sibling], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[x, sibling], null)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(heapseg(x, null), UnfoldingHeap[null, heapseg(x, null)], heapseg(UnfoldingHeap[x, sibling], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[x, sibling], null)]);
        assume state(UnfoldingHeap, UnfoldingMask);
        if (UnfoldingHeap[x, sibling] != null) {
          assume state(UnfoldingHeap, UnfoldingMask);
          assume treeParent(UnfoldingHeap, x) == segParent(UnfoldingHeap, UnfoldingHeap[x, sibling], null);
        }
      }
      assume state(UnfoldingHeap, UnfoldingMask);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := UnfoldingHeap;
        ExhaleWellDef0Mask := UnfoldingMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@190.39--190.49) [100420]"}
          NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(x)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
        UnfoldingHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      
      // -- Free assumptions (exp module)
        if (x != null) {
          havoc newPMask;
          assume (forall <A, B> o_82: Ref, f_70: (Field A B) ::
            { newPMask[o_82, f_70] }
            Heap[null, heapseg#sm(x, null)][o_82, f_70] || Heap[null, tree#sm(x)][o_82, f_70] ==> newPMask[o_82, f_70]
          );
          Heap := Heap[null, heapseg#sm(x, null):=newPMask];
          Heap := Heap[null, heapseg#sm(x, null):=Heap[null, heapseg#sm(x, null)][x, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_83: Ref, f_89: (Field A B) ::
            { newPMask[o_83, f_89] }
            Heap[null, heapseg#sm(x, null)][o_83, f_89] || Heap[null, heapseg#sm(Heap[x, sibling], null)][o_83, f_89] ==> newPMask[o_83, f_89]
          );
          Heap := Heap[null, heapseg#sm(x, null):=newPMask];
        }
        assume state(Heap, Mask);
    vmin := treeKey(Heap, x);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(arg, res), write) -- BinomialHeap.vpr@191.2--191.24
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (arg != res) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(arg, res) might fail. There might be insufficient permission to access tree(arg) (BinomialHeap.vpr@191.2--191.24) [100423]"}
          perm <= Mask[null, tree(arg)];
      }
      Mask := Mask[null, tree(arg):=Mask[null, tree(arg)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(arg, res), Heap[null, heapseg(arg, res)], tree(arg), Heap[null, tree(arg)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(arg, res) might fail. There might be insufficient permission to access arg.sibling (BinomialHeap.vpr@191.2--191.24) [100425]"}
          perm <= Mask[arg, sibling];
      }
      Mask := Mask[arg, sibling:=Mask[arg, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(arg, res) might fail. There might be insufficient permission to access heapseg(arg.sibling, res) (BinomialHeap.vpr@191.2--191.24) [100427]"}
          perm <= Mask[null, heapseg(Heap[arg, sibling], res)];
      }
      Mask := Mask[null, heapseg(Heap[arg, sibling], res):=Mask[null, heapseg(Heap[arg, sibling], res)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(arg, res), Heap[null, heapseg(arg, res)], heapseg(Heap[arg, sibling], res), Heap[null, heapseg(Heap[arg, sibling], res)]);
      if (Heap[arg, sibling] != res) {
        assert {:msg "  Folding heapseg(arg, res) might fail. Assertion treeParent(arg) == segParent(arg.sibling, res) might not hold. (BinomialHeap.vpr@191.2--191.24) [100428]"}
          treeParent(Heap, arg) == segParent(Heap, Heap[arg, sibling], res);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(arg, res));
    assume Heap[null, heapseg(arg, res)] == FrameFragment((if arg != res then CombineFrames(Heap[null, tree(arg)], CombineFrames(FrameFragment(Heap[arg, sibling]), CombineFrames(Heap[null, heapseg(Heap[arg, sibling], res)], FrameFragment((if Heap[arg, sibling] != res then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(arg, res))) {
      Heap := Heap[null, heapseg#sm(arg, res):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(arg, res):=freshVersion];
    }
    if (arg != res) {
      havoc newPMask;
      assume (forall <A, B> o_68: Ref, f_58: (Field A B) ::
        { newPMask[o_68, f_58] }
        Heap[null, heapseg#sm(arg, res)][o_68, f_58] || Heap[null, tree#sm(arg)][o_68, f_58] ==> newPMask[o_68, f_58]
      );
      Heap := Heap[null, heapseg#sm(arg, res):=newPMask];
      Heap := Heap[null, heapseg#sm(arg, res):=Heap[null, heapseg#sm(arg, res)][arg, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_84: Ref, f_71: (Field A B) ::
        { newPMask[o_84, f_71] }
        Heap[null, heapseg#sm(arg, res)][o_84, f_71] || Heap[null, heapseg#sm(Heap[arg, sibling], res)][o_84, f_71] ==> newPMask[o_84, f_71]
      );
      Heap := Heap[null, heapseg#sm(arg, res):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(res, x), write) -- BinomialHeap.vpr@192.2--192.22
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (res != x) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(res, x) might fail. There might be insufficient permission to access tree(res) (BinomialHeap.vpr@192.2--192.22) [100432]"}
          perm <= Mask[null, tree(res)];
      }
      Mask := Mask[null, tree(res):=Mask[null, tree(res)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(res, x), Heap[null, heapseg(res, x)], tree(res), Heap[null, tree(res)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(res, x) might fail. There might be insufficient permission to access res.sibling (BinomialHeap.vpr@192.2--192.22) [100434]"}
          perm <= Mask[res, sibling];
      }
      Mask := Mask[res, sibling:=Mask[res, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(res, x) might fail. There might be insufficient permission to access heapseg(res.sibling, x) (BinomialHeap.vpr@192.2--192.22) [100436]"}
          perm <= Mask[null, heapseg(Heap[res, sibling], x)];
      }
      Mask := Mask[null, heapseg(Heap[res, sibling], x):=Mask[null, heapseg(Heap[res, sibling], x)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(res, x), Heap[null, heapseg(res, x)], heapseg(Heap[res, sibling], x), Heap[null, heapseg(Heap[res, sibling], x)]);
      if (Heap[res, sibling] != x) {
        assert {:msg "  Folding heapseg(res, x) might fail. Assertion treeParent(res) == segParent(res.sibling, x) might not hold. (BinomialHeap.vpr@192.2--192.22) [100437]"}
          treeParent(Heap, res) == segParent(Heap, Heap[res, sibling], x);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(res, x));
    assume Heap[null, heapseg(res, x)] == FrameFragment((if res != x then CombineFrames(Heap[null, tree(res)], CombineFrames(FrameFragment(Heap[res, sibling]), CombineFrames(Heap[null, heapseg(Heap[res, sibling], x)], FrameFragment((if Heap[res, sibling] != x then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(res, x))) {
      Heap := Heap[null, heapseg#sm(res, x):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(res, x):=freshVersion];
    }
    if (res != x) {
      havoc newPMask;
      assume (forall <A, B> o_85: Ref, f_60: (Field A B) ::
        { newPMask[o_85, f_60] }
        Heap[null, heapseg#sm(res, x)][o_85, f_60] || Heap[null, tree#sm(res)][o_85, f_60] ==> newPMask[o_85, f_60]
      );
      Heap := Heap[null, heapseg#sm(res, x):=newPMask];
      Heap := Heap[null, heapseg#sm(res, x):=Heap[null, heapseg#sm(res, x)][res, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_69: Ref, f_90: (Field A B) ::
        { newPMask[o_69, f_90] }
        Heap[null, heapseg#sm(res, x)][o_69, f_90] || Heap[null, heapseg#sm(Heap[res, sibling], x)][o_69, f_90] ==> newPMask[o_69, f_90]
      );
      Heap := Heap[null, heapseg#sm(res, x):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: while (x != null) -- BinomialHeap.vpr@194.2--226.3
    
    // -- Before loop head
      
      // -- Exhale loop invariant before loop
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not hold on entry. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@195.13--195.50) [100439]"}
            perm <= Mask[null, heapseg(arg, res)];
        }
        Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not hold on entry. Assertion sorted(arg, res) might not hold. (BinomialHeap.vpr@195.13--195.50) [100440]"}
          sorted(Heap, arg, res);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not hold on entry. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@196.13--196.46) [100441]"}
            perm <= Mask[null, heapseg(res, x)];
        }
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not hold on entry. Assertion sorted(res, x) might not hold. (BinomialHeap.vpr@196.13--196.46) [100442]"}
          sorted(Heap, res, x);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not hold on entry. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@197.13--197.48) [100443]"}
            perm <= Mask[null, heapseg(x, null)];
        }
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not hold on entry. Assertion sorted(x, null) might not hold. (BinomialHeap.vpr@197.13--197.48) [100444]"}
          sorted(Heap, x, null);
        if (arg != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not hold on entry. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not hold. (BinomialHeap.vpr@198.13--198.107) [100445]"}
            segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, res, x, 0);
        }
        if (x != null && res != x) {
          assert {:msg "  Loop invariant x != null && res != x ==> segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not hold on entry. Assertion segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@199.13--199.103) [100446]"}
            segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        if (arg != res && (res == x && x != null)) {
          assert {:msg "  Loop invariant arg != res && (res == x && x != null) ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not hold on entry. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@200.13--200.121) [100447]"}
            segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assert {:msg "  Loop invariant res != null might not hold on entry. Assertion res != null might not hold. (BinomialHeap.vpr@201.13--201.24) [100448]"}
          res != null;
        assert {:msg "  Loop invariant segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not hold on entry. Assertion segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not hold. (BinomialHeap.vpr@202.13--202.94) [100449]"}
          segSize(Heap, arg, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg, null);
        if (arg != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segParent(arg, res) == segParent(res, x) might not hold on entry. Assertion segParent(arg, res) == segParent(res, x) might not hold. (BinomialHeap.vpr@203.13--203.80) [100450]"}
            segParent(Heap, arg, res) == segParent(Heap, res, x);
        }
        if (res != x && x != null) {
          assert {:msg "  Loop invariant res != x && x != null ==> segParent(res, x) == segParent(x, null) might not hold on entry. Assertion segParent(res, x) == segParent(x, null) might not hold. (BinomialHeap.vpr@204.13--204.78) [100451]"}
            segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        if (arg != res && x != null) {
          assert {:msg "  Loop invariant arg != res && x != null ==> segParent(arg, res) == segParent(x, null) might not hold on entry. Assertion segParent(arg, res) == segParent(x, null) might not hold. (BinomialHeap.vpr@205.13--205.82) [100452]"}
            segParent(Heap, arg, res) == segParent(Heap, x, null);
        }
        if (arg != res) {
          assert {:msg "  Loop invariant arg != res ==> segParent(arg, res) == old(segParent(arg, null)) might not hold on entry. Assertion segParent(arg, res) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@206.13--206.76) [100453]"}
            segParent(Heap, arg, res) == segParent(oldHeap, arg, null);
        }
        if (res != x) {
          assert {:msg "  Loop invariant res != x ==> segParent(res, x) == old(segParent(arg, null)) might not hold on entry. Assertion segParent(res, x) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@207.13--207.72) [100454]"}
            segParent(Heap, res, x) == segParent(oldHeap, arg, null);
        }
        if (x != null) {
          assert {:msg "  Loop invariant x != null ==> segParent(x, null) == old(segParent(arg, null)) might not hold on entry. Assertion segParent(x, null) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@208.13--208.74) [100455]"}
            segParent(Heap, x, null) == segParent(oldHeap, arg, null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
    
    // -- Havoc loop written variables (except locals)
      havoc x, vmin, res;
      assume Heap[x, $allocated];
      assume Heap[res, $allocated];
    
    // -- Check definedness of invariant
      if (*) {
        perm := FullPerm;
        Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(arg, res)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@195.34--195.50) [100456]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted(Heap, arg, res);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(res, x)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@196.32--196.46) [100457]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted(Heap, res, x);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(x, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@197.33--197.48) [100458]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted(Heap, x, null);
        assume state(Heap, Mask);
        if (arg != res && res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@198.60--198.79) [100459]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@198.40--198.84) [100460]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(arg, res) - 1 might not hold. (BinomialHeap.vpr@198.40--198.84) [100461]"}
                0 <= segLength(Heap, arg, res) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(arg, res) - 1 < segLength(arg, res) might not hold. (BinomialHeap.vpr@198.40--198.84) [100462]"}
                segLength(Heap, arg, res) - 1 < segLength(Heap, arg, res);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@198.87--198.107) [100463]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(res, x) might not hold. (BinomialHeap.vpr@198.87--198.107) [100464]"}
                0 < segLength(Heap, res, x);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, res, x, 0);
        }
        assume state(Heap, Mask);
        if (x != null && res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@199.57--199.74) [100465]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@199.39--199.79) [100466]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(res, x) - 1 might not hold. (BinomialHeap.vpr@199.39--199.79) [100467]"}
                0 <= segLength(Heap, res, x) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(res, x) - 1 < segLength(res, x) might not hold. (BinomialHeap.vpr@199.39--199.79) [100468]"}
                segLength(Heap, res, x) - 1 < segLength(Heap, res, x);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@199.82--199.103) [100469]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(x, null) might not hold. (BinomialHeap.vpr@199.82--199.103) [100470]"}
                0 < segLength(Heap, x, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        assume state(Heap, Mask);
        if (arg != res && (res == x && x != null)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@200.73--200.92) [100471]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@200.53--200.97) [100472]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(arg, res) - 1 might not hold. (BinomialHeap.vpr@200.53--200.97) [100473]"}
                0 <= segLength(Heap, arg, res) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(arg, res) - 1 < segLength(arg, res) might not hold. (BinomialHeap.vpr@200.53--200.97) [100474]"}
                segLength(Heap, arg, res) - 1 < segLength(Heap, arg, res);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@200.100--200.121) [100475]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(x, null) might not hold. (BinomialHeap.vpr@200.100--200.121) [100476]"}
                0 < segLength(Heap, x, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assume state(Heap, Mask);
        assume res != null;
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null))
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@202.13--202.30) [100477]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@202.33--202.48) [100478]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@202.51--202.67) [100479]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@202.75--202.93) [100480]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg, null)];
            // Finish exhale
            // Stop execution
            assume false;
          }
        assume segSize(Heap, arg, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg, null);
        assume state(Heap, Mask);
        if (arg != res && res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(arg, res) == segParent(res, x)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@203.40--203.59) [100481]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@203.40--203.59) [100482]"}
                arg != res;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@203.63--203.80) [100483]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion res != x might not hold. (BinomialHeap.vpr@203.63--203.80) [100484]"}
                res != x;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, arg, res) == segParent(Heap, res, x);
        }
        assume state(Heap, Mask);
        if (res != x && x != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(res, x) == segParent(x, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@204.39--204.56) [100485]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion res != x might not hold. (BinomialHeap.vpr@204.39--204.56) [100486]"}
                res != x;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@204.60--204.78) [100487]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion x != null might not hold. (BinomialHeap.vpr@204.60--204.78) [100488]"}
                x != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        assume state(Heap, Mask);
        if (arg != res && x != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(arg, res) == segParent(x, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@205.41--205.60) [100489]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@205.41--205.60) [100490]"}
                arg != res;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@205.64--205.82) [100491]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion x != null might not hold. (BinomialHeap.vpr@205.64--205.82) [100492]"}
                x != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, arg, res) == segParent(Heap, x, null);
        }
        assume state(Heap, Mask);
        if (arg != res) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(arg, res) == old(segParent(arg, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@206.28--206.47) [100493]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(arg, res)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != res might not hold. (BinomialHeap.vpr@206.28--206.47) [100494]"}
                arg != res;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@206.55--206.75) [100495]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@206.55--206.75) [100496]"}
                arg != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, arg, res) == segParent(oldHeap, arg, null);
        }
        assume state(Heap, Mask);
        if (res != x) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(res, x) == old(segParent(arg, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@207.26--207.43) [100497]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(res, x)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion res != x might not hold. (BinomialHeap.vpr@207.26--207.43) [100498]"}
                res != x;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@207.51--207.71) [100499]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@207.51--207.71) [100500]"}
                arg != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, res, x) == segParent(oldHeap, arg, null);
        }
        assume state(Heap, Mask);
        if (x != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(x, null) == old(segParent(arg, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@208.27--208.45) [100501]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(x, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion x != null might not hold. (BinomialHeap.vpr@208.27--208.45) [100502]"}
                x != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(arg, null) (BinomialHeap.vpr@208.53--208.73) [100503]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(arg, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion arg != null might not hold. (BinomialHeap.vpr@208.53--208.73) [100504]"}
                arg != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, x, null) == segParent(oldHeap, arg, null);
        }
        assume state(Heap, Mask);
        assume false;
      }
    
    // -- Check the loop body
      if (*) {
        // Reset state
        loopHeap := Heap;
        loopMask := Mask;
        Mask := ZeroMask;
        assume state(Heap, Mask);
        // Inhale invariant
        perm := FullPerm;
        Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted(Heap, arg, res);
        perm := FullPerm;
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted(Heap, res, x);
        perm := FullPerm;
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted(Heap, x, null);
        if (arg != res && res != x) {
          assume state(Heap, Mask);
          assume segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, res, x, 0);
        }
        if (x != null && res != x) {
          assume state(Heap, Mask);
          assume segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        if (arg != res && (res == x && x != null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assume res != null;
        assume state(Heap, Mask);
        assume segSize(Heap, arg, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg, null);
        if (arg != res && res != x) {
          assume state(Heap, Mask);
          assume segParent(Heap, arg, res) == segParent(Heap, res, x);
        }
        if (res != x && x != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        if (arg != res && x != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, arg, res) == segParent(Heap, x, null);
        }
        if (arg != res) {
          assume state(Heap, Mask);
          assume segParent(Heap, arg, res) == segParent(oldHeap, arg, null);
        }
        if (res != x) {
          assume state(Heap, Mask);
          assume segParent(Heap, res, x) == segParent(oldHeap, arg, null);
        }
        if (x != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, x, null) == segParent(oldHeap, arg, null);
        }
        assume state(Heap, Mask);
        // Check and assume guard
        assume x != null;
        assume state(Heap, Mask);
        
        // -- Translate loop body
          
          // -- Assumptions about local variables
            assume Heap[tmp, $allocated];
          
          // -- Translating statement: unfold acc(heapseg(x, null), write) -- BinomialHeap.vpr@210.3--210.26
            assume heapseg#trigger(Heap, heapseg(x, null));
            assume Heap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(Heap[null, tree(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], null)], FrameFragment((if Heap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(x, null) might fail. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@210.3--210.26) [100505]"}
                perm <= Mask[null, heapseg(x, null)];
            }
            Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(x, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(x, null):=newVersion];
              }
            if (x != null) {
              perm := FullPerm;
              Mask := Mask[null, tree(x):=Mask[null, tree(x)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], tree(x), Heap[null, tree(x)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume x != null;
              Mask := Mask[x, sibling:=Mask[x, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[x, sibling], null):=Mask[null, heapseg(Heap[x, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], heapseg(Heap[x, sibling], null), Heap[null, heapseg(Heap[x, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[x, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (treeKey(x) < min) -- BinomialHeap.vpr@211.3--216.4
            
            // -- Check definedness of treeKey(x) < min
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@211.6--211.16) [100506]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree(x)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (treeKey(Heap, x) < vmin) {
              
              // -- Translating statement: concat(arg, res, x) -- BinomialHeap.vpr@212.4--212.23
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@212.4--212.23) [100507]"}
                      perm <= Mask[null, heapseg(arg, res)];
                  }
                  Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@212.4--212.23) [100508]"}
                      perm <= Mask[null, heapseg(res, x)];
                  }
                  Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] - perm];
                  if (x != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@212.4--212.23) [100509]"}
                        perm <= Mask[null, tree(x)];
                    }
                    Mask := Mask[null, tree(x):=Mask[null, tree(x)] - perm];
                  }
                  if (arg != res && res != x) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(arg, res) == segParent(res, x) might not hold. (BinomialHeap.vpr@212.4--212.23) [100510]"}
                      segParent(Heap, arg, res) == segParent(Heap, res, x);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(arg, x):=Mask[null, heapseg(arg, x)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, arg, x) == segLength(PreCallHeap, arg, res) + segLength(PreCallHeap, res, x);
                  assume state(Heap, Mask);
                  assume (forall i: int ::
                    { segDegree#frame(Heap[null, heapseg(arg, x)], arg, x, i) } { segDegree#frame(PreCallHeap[null, heapseg(arg, res)], arg, res, i) }
                    0 <= i && i < segLength(PreCallHeap, arg, res) ==> segDegree(Heap, arg, x, i) == segDegree(PreCallHeap, arg, res, i)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_1: int ::
                    { segDegree#frame(Heap[null, heapseg(arg, x)], arg, x, i_1) }
                    segLength(PreCallHeap, arg, res) <= i_1 && i_1 < segLength(Heap, arg, x) ==> segDegree(Heap, arg, x, i_1) == segDegree(PreCallHeap, res, x, i_1 - segLength(PreCallHeap, arg, res))
                  );
                  if (x != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree(x):=Mask[null, tree(x)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, x) == treeDegree(PreCallHeap, x);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, x) == treeSize(PreCallHeap, x);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, x) == treeParent(PreCallHeap, x);
                  }
                  if (sorted(PreCallHeap, arg, res) && (sorted(PreCallHeap, res, x) && (0 < segLength(PreCallHeap, arg, res) && 0 < segLength(PreCallHeap, res, x) ==> segDegree(PreCallHeap, arg, res, segLength(PreCallHeap, arg, res) - 1) < segDegree(PreCallHeap, res, x, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted(Heap, arg, x);
                  }
                  if (presorted(PreCallHeap, arg, res) && (presorted(PreCallHeap, res, x) && (0 < segLength(PreCallHeap, arg, res) && 0 < segLength(PreCallHeap, res, x) ==> segDegree(PreCallHeap, arg, res, segLength(PreCallHeap, arg, res) - 1) <= segDegree(PreCallHeap, res, x, 0) && ((2 <= segLength(PreCallHeap, arg, res) && segDegree(PreCallHeap, arg, res, segLength(PreCallHeap, arg, res) - 1) == segDegree(PreCallHeap, arg, res, segLength(PreCallHeap, arg, res) - 2) ==> segDegree(PreCallHeap, arg, res, segLength(PreCallHeap, arg, res) - 1) < segDegree(PreCallHeap, res, x, 0)) && (2 <= segLength(PreCallHeap, res, x) && segDegree(PreCallHeap, res, x, 0) == segDegree(PreCallHeap, res, x, 1) ==> segDegree(PreCallHeap, arg, res, segLength(PreCallHeap, arg, res) - 1) < segDegree(PreCallHeap, res, x, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, arg, x);
                  }
                  if (validChildren(PreCallHeap, arg, res) && (validChildren(PreCallHeap, res, x) && (0 < segLength(PreCallHeap, arg, res) && 0 < segLength(PreCallHeap, res, x) ==> segDegree(PreCallHeap, arg, res, segLength(PreCallHeap, arg, res) - 1) == segDegree(PreCallHeap, res, x, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, arg, x);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, arg, x) == segSize(PreCallHeap, arg, res) + segSize(PreCallHeap, res, x);
                  if (arg != res) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg, x) == segParent(PreCallHeap, arg, res);
                  }
                  if (res != x) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg, x) == segParent(PreCallHeap, res, x);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: res := x -- BinomialHeap.vpr@213.4--213.12
                res := x;
                assume state(Heap, Mask);
              
              // -- Translating statement: min := treeKey(x) -- BinomialHeap.vpr@214.4--214.21
                
                // -- Check definedness of treeKey(x)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@214.11--214.21) [100511]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree(x)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                vmin := treeKey(Heap, x);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(res, res), write) -- BinomialHeap.vpr@215.4--215.26
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (res != res) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(res, res) might fail. There might be insufficient permission to access tree(res) (BinomialHeap.vpr@215.4--215.26) [100512]"}
                      perm <= Mask[null, tree(res)];
                  }
                  Mask := Mask[null, tree(res):=Mask[null, tree(res)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(res, res), Heap[null, heapseg(res, res)], tree(res), Heap[null, tree(res)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(res, res) might fail. There might be insufficient permission to access res.sibling (BinomialHeap.vpr@215.4--215.26) [100513]"}
                      perm <= Mask[res, sibling];
                  }
                  Mask := Mask[res, sibling:=Mask[res, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(res, res) might fail. There might be insufficient permission to access heapseg(res.sibling, res) (BinomialHeap.vpr@215.4--215.26) [100514]"}
                      perm <= Mask[null, heapseg(Heap[res, sibling], res)];
                  }
                  Mask := Mask[null, heapseg(Heap[res, sibling], res):=Mask[null, heapseg(Heap[res, sibling], res)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(res, res), Heap[null, heapseg(res, res)], heapseg(Heap[res, sibling], res), Heap[null, heapseg(Heap[res, sibling], res)]);
                  if (Heap[res, sibling] != res) {
                    assert {:msg "  Folding heapseg(res, res) might fail. Assertion treeParent(res) == segParent(res.sibling, res) might not hold. (BinomialHeap.vpr@215.4--215.26) [100515]"}
                      treeParent(Heap, res) == segParent(Heap, Heap[res, sibling], res);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(res, res):=Mask[null, heapseg(res, res)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(res, res));
                assume Heap[null, heapseg(res, res)] == FrameFragment((if res != res then CombineFrames(Heap[null, tree(res)], CombineFrames(FrameFragment(Heap[res, sibling]), CombineFrames(Heap[null, heapseg(Heap[res, sibling], res)], FrameFragment((if Heap[res, sibling] != res then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(res, res))) {
                  Heap := Heap[null, heapseg#sm(res, res):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(res, res):=freshVersion];
                }
                if (res != res) {
                  havoc newPMask;
                  assume (forall <A, B> o_86: Ref, f_91: (Field A B) ::
                    { newPMask[o_86, f_91] }
                    Heap[null, heapseg#sm(res, res)][o_86, f_91] || Heap[null, tree#sm(res)][o_86, f_91] ==> newPMask[o_86, f_91]
                  );
                  Heap := Heap[null, heapseg#sm(res, res):=newPMask];
                  Heap := Heap[null, heapseg#sm(res, res):=Heap[null, heapseg#sm(res, res)][res, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_87: Ref, f_61: (Field A B) ::
                    { newPMask[o_87, f_61] }
                    Heap[null, heapseg#sm(res, res)][o_87, f_61] || Heap[null, heapseg#sm(Heap[res, sibling], res)][o_87, f_61] ==> newPMask[o_87, f_61]
                  );
                  Heap := Heap[null, heapseg#sm(res, res):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
          
          // -- Translating statement: tmp := x -- BinomialHeap.vpr@217.3--217.20
            tmp := x;
            assume state(Heap, Mask);
          
          // -- Translating statement: x := x.sibling -- BinomialHeap.vpr@218.3--218.17
            
            // -- Check definedness of x.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access x.sibling (BinomialHeap.vpr@218.3--218.17) [100516]"}
                HasDirectPerm(Mask, x, sibling);
            x := Heap[x, sibling];
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(x, x), write) -- BinomialHeap.vpr@220.3--220.21
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (x != x) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, x) might fail. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@220.3--220.21) [100517]"}
                  perm <= Mask[null, tree(x)];
              }
              Mask := Mask[null, tree(x):=Mask[null, tree(x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, x), Heap[null, heapseg(x, x)], tree(x), Heap[null, tree(x)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, x) might fail. There might be insufficient permission to access x.sibling (BinomialHeap.vpr@220.3--220.21) [100518]"}
                  perm <= Mask[x, sibling];
              }
              Mask := Mask[x, sibling:=Mask[x, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, x) might fail. There might be insufficient permission to access heapseg(x.sibling, x) (BinomialHeap.vpr@220.3--220.21) [100519]"}
                  perm <= Mask[null, heapseg(Heap[x, sibling], x)];
              }
              Mask := Mask[null, heapseg(Heap[x, sibling], x):=Mask[null, heapseg(Heap[x, sibling], x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, x), Heap[null, heapseg(x, x)], heapseg(Heap[x, sibling], x), Heap[null, heapseg(Heap[x, sibling], x)]);
              if (Heap[x, sibling] != x) {
                assert {:msg "  Folding heapseg(x, x) might fail. Assertion treeParent(x) == segParent(x.sibling, x) might not hold. (BinomialHeap.vpr@220.3--220.21) [100520]"}
                  treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], x);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(x, x):=Mask[null, heapseg(x, x)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(x, x));
            assume Heap[null, heapseg(x, x)] == FrameFragment((if x != x then CombineFrames(Heap[null, tree(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], x)], FrameFragment((if Heap[x, sibling] != x then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(x, x))) {
              Heap := Heap[null, heapseg#sm(x, x):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(x, x):=freshVersion];
            }
            if (x != x) {
              havoc newPMask;
              assume (forall <A, B> o_88: Ref, f_78: (Field A B) ::
                { newPMask[o_88, f_78] }
                Heap[null, heapseg#sm(x, x)][o_88, f_78] || Heap[null, tree#sm(x)][o_88, f_78] ==> newPMask[o_88, f_78]
              );
              Heap := Heap[null, heapseg#sm(x, x):=newPMask];
              Heap := Heap[null, heapseg#sm(x, x):=Heap[null, heapseg#sm(x, x)][x, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_89: Ref, f_92: (Field A B) ::
                { newPMask[o_89, f_92] }
                Heap[null, heapseg#sm(x, x)][o_89, f_92] || Heap[null, heapseg#sm(Heap[x, sibling], x)][o_89, f_92] ==> newPMask[o_89, f_92]
              );
              Heap := Heap[null, heapseg#sm(x, x):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(tmp, x), write) -- BinomialHeap.vpr@221.3--221.23
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (tmp != x) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@221.3--221.23) [100521]"}
                  perm <= Mask[null, tree(tmp)];
              }
              Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(tmp, x), Heap[null, heapseg(tmp, x)], tree(tmp), Heap[null, tree(tmp)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@221.3--221.23) [100522]"}
                  perm <= Mask[tmp, sibling];
              }
              Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. There might be insufficient permission to access heapseg(tmp.sibling, x) (BinomialHeap.vpr@221.3--221.23) [100523]"}
                  perm <= Mask[null, heapseg(Heap[tmp, sibling], x)];
              }
              Mask := Mask[null, heapseg(Heap[tmp, sibling], x):=Mask[null, heapseg(Heap[tmp, sibling], x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(tmp, x), Heap[null, heapseg(tmp, x)], heapseg(Heap[tmp, sibling], x), Heap[null, heapseg(Heap[tmp, sibling], x)]);
              if (Heap[tmp, sibling] != x) {
                assert {:msg "  Folding heapseg(tmp, x) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, x) might not hold. (BinomialHeap.vpr@221.3--221.23) [100524]"}
                  treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], x);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(tmp, x):=Mask[null, heapseg(tmp, x)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(tmp, x));
            assume Heap[null, heapseg(tmp, x)] == FrameFragment((if tmp != x then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], x)], FrameFragment((if Heap[tmp, sibling] != x then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(tmp, x))) {
              Heap := Heap[null, heapseg#sm(tmp, x):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(tmp, x):=freshVersion];
            }
            if (tmp != x) {
              havoc newPMask;
              assume (forall <A, B> o_90: Ref, f_93: (Field A B) ::
                { newPMask[o_90, f_93] }
                Heap[null, heapseg#sm(tmp, x)][o_90, f_93] || Heap[null, tree#sm(tmp)][o_90, f_93] ==> newPMask[o_90, f_93]
              );
              Heap := Heap[null, heapseg#sm(tmp, x):=newPMask];
              Heap := Heap[null, heapseg#sm(tmp, x):=Heap[null, heapseg#sm(tmp, x)][tmp, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_91: Ref, f_79: (Field A B) ::
                { newPMask[o_91, f_79] }
                Heap[null, heapseg#sm(tmp, x)][o_91, f_79] || Heap[null, heapseg#sm(Heap[tmp, sibling], x)][o_91, f_79] ==> newPMask[o_91, f_79]
              );
              Heap := Heap[null, heapseg#sm(tmp, x):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: unfold acc(heapseg(x, null), write) -- BinomialHeap.vpr@222.3--222.26
            assume heapseg#trigger(Heap, heapseg(x, null));
            assume Heap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(Heap[null, tree(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], null)], FrameFragment((if Heap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(x, null) might fail. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@222.3--222.26) [100525]"}
                perm <= Mask[null, heapseg(x, null)];
            }
            Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(x, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(x, null):=newVersion];
              }
            if (x != null) {
              perm := FullPerm;
              Mask := Mask[null, tree(x):=Mask[null, tree(x)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], tree(x), Heap[null, tree(x)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume x != null;
              Mask := Mask[x, sibling:=Mask[x, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[x, sibling], null):=Mask[null, heapseg(Heap[x, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], heapseg(Heap[x, sibling], null), Heap[null, heapseg(Heap[x, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[x, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: concat(res, tmp, x) -- BinomialHeap.vpr@224.3--224.22
            PreCallHeap := Heap;
            PreCallMask := Mask;
            
            // -- Exhaling precondition
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(res, tmp) (BinomialHeap.vpr@224.3--224.22) [100526]"}
                  perm <= Mask[null, heapseg(res, tmp)];
              }
              Mask := Mask[null, heapseg(res, tmp):=Mask[null, heapseg(res, tmp)] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(tmp, x) (BinomialHeap.vpr@224.3--224.22) [100527]"}
                  perm <= Mask[null, heapseg(tmp, x)];
              }
              Mask := Mask[null, heapseg(tmp, x):=Mask[null, heapseg(tmp, x)] - perm];
              if (x != null) {
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@224.3--224.22) [100528]"}
                    perm <= Mask[null, tree(x)];
                }
                Mask := Mask[null, tree(x):=Mask[null, tree(x)] - perm];
              }
              if (res != tmp && tmp != x) {
                assert {:msg "  The precondition of method concat might not hold. Assertion segParent(res, tmp) == segParent(tmp, x) might not hold. (BinomialHeap.vpr@224.3--224.22) [100529]"}
                  segParent(Heap, res, tmp) == segParent(Heap, tmp, x);
              }
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
            
            // -- Inhaling postcondition
              perm := FullPerm;
              Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume segLength(Heap, res, x) == segLength(PreCallHeap, res, tmp) + segLength(PreCallHeap, tmp, x);
              assume state(Heap, Mask);
              assume (forall i_2_1: int ::
                { segDegree#frame(Heap[null, heapseg(res, x)], res, x, i_2_1) } { segDegree#frame(PreCallHeap[null, heapseg(res, tmp)], res, tmp, i_2_1) }
                0 <= i_2_1 && i_2_1 < segLength(PreCallHeap, res, tmp) ==> segDegree(Heap, res, x, i_2_1) == segDegree(PreCallHeap, res, tmp, i_2_1)
              );
              assume state(Heap, Mask);
              assume (forall i_3: int ::
                { segDegree#frame(Heap[null, heapseg(res, x)], res, x, i_3) }
                segLength(PreCallHeap, res, tmp) <= i_3 && i_3 < segLength(Heap, res, x) ==> segDegree(Heap, res, x, i_3) == segDegree(PreCallHeap, tmp, x, i_3 - segLength(PreCallHeap, res, tmp))
              );
              if (x != null) {
                perm := FullPerm;
                Mask := Mask[null, tree(x):=Mask[null, tree(x)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume treeDegree(Heap, x) == treeDegree(PreCallHeap, x);
                assume state(Heap, Mask);
                assume treeSize(Heap, x) == treeSize(PreCallHeap, x);
                assume state(Heap, Mask);
                assume treeParent(Heap, x) == treeParent(PreCallHeap, x);
              }
              if (sorted(PreCallHeap, res, tmp) && (sorted(PreCallHeap, tmp, x) && (0 < segLength(PreCallHeap, res, tmp) && 0 < segLength(PreCallHeap, tmp, x) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) < segDegree(PreCallHeap, tmp, x, 0)))) {
                assume state(Heap, Mask);
                assume sorted(Heap, res, x);
              }
              if (presorted(PreCallHeap, res, tmp) && (presorted(PreCallHeap, tmp, x) && (0 < segLength(PreCallHeap, res, tmp) && 0 < segLength(PreCallHeap, tmp, x) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) <= segDegree(PreCallHeap, tmp, x, 0) && ((2 <= segLength(PreCallHeap, res, tmp) && segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) == segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 2) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) < segDegree(PreCallHeap, tmp, x, 0)) && (2 <= segLength(PreCallHeap, tmp, x) && segDegree(PreCallHeap, tmp, x, 0) == segDegree(PreCallHeap, tmp, x, 1) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) < segDegree(PreCallHeap, tmp, x, 0)))))) {
                assume state(Heap, Mask);
                assume presorted(Heap, res, x);
              }
              if (validChildren(PreCallHeap, res, tmp) && (validChildren(PreCallHeap, tmp, x) && (0 < segLength(PreCallHeap, res, tmp) && 0 < segLength(PreCallHeap, tmp, x) ==> segDegree(PreCallHeap, res, tmp, segLength(PreCallHeap, res, tmp) - 1) == segDegree(PreCallHeap, tmp, x, 0) + 1))) {
                assume state(Heap, Mask);
                assume validChildren(Heap, res, x);
              }
              assume state(Heap, Mask);
              assume segSize(Heap, res, x) == segSize(PreCallHeap, res, tmp) + segSize(PreCallHeap, tmp, x);
              if (res != tmp) {
                assume state(Heap, Mask);
                assume segParent(Heap, res, x) == segParent(PreCallHeap, res, tmp);
              }
              if (tmp != x) {
                assume state(Heap, Mask);
                assume segParent(Heap, res, x) == segParent(PreCallHeap, tmp, x);
              }
              assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(x, null), write) -- BinomialHeap.vpr@225.3--225.24
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (x != null) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, null) might fail. There might be insufficient permission to access tree(x) (BinomialHeap.vpr@225.3--225.24) [100530]"}
                  perm <= Mask[null, tree(x)];
              }
              Mask := Mask[null, tree(x):=Mask[null, tree(x)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], tree(x), Heap[null, tree(x)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, null) might fail. There might be insufficient permission to access x.sibling (BinomialHeap.vpr@225.3--225.24) [100531]"}
                  perm <= Mask[x, sibling];
              }
              Mask := Mask[x, sibling:=Mask[x, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(x, null) might fail. There might be insufficient permission to access heapseg(x.sibling, null) (BinomialHeap.vpr@225.3--225.24) [100532]"}
                  perm <= Mask[null, heapseg(Heap[x, sibling], null)];
              }
              Mask := Mask[null, heapseg(Heap[x, sibling], null):=Mask[null, heapseg(Heap[x, sibling], null)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(x, null), Heap[null, heapseg(x, null)], heapseg(Heap[x, sibling], null), Heap[null, heapseg(Heap[x, sibling], null)]);
              if (Heap[x, sibling] != null) {
                assert {:msg "  Folding heapseg(x, null) might fail. Assertion treeParent(x) == segParent(x.sibling, null) might not hold. (BinomialHeap.vpr@225.3--225.24) [100533]"}
                  treeParent(Heap, x) == segParent(Heap, Heap[x, sibling], null);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(x, null));
            assume Heap[null, heapseg(x, null)] == FrameFragment((if x != null then CombineFrames(Heap[null, tree(x)], CombineFrames(FrameFragment(Heap[x, sibling]), CombineFrames(Heap[null, heapseg(Heap[x, sibling], null)], FrameFragment((if Heap[x, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(x, null))) {
              Heap := Heap[null, heapseg#sm(x, null):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(x, null):=freshVersion];
            }
            if (x != null) {
              havoc newPMask;
              assume (forall <A, B> o_64: Ref, f_94: (Field A B) ::
                { newPMask[o_64, f_94] }
                Heap[null, heapseg#sm(x, null)][o_64, f_94] || Heap[null, tree#sm(x)][o_64, f_94] ==> newPMask[o_64, f_94]
              );
              Heap := Heap[null, heapseg#sm(x, null):=newPMask];
              Heap := Heap[null, heapseg#sm(x, null):=Heap[null, heapseg#sm(x, null)][x, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_92: Ref, f_68: (Field A B) ::
                { newPMask[o_92, f_68] }
                Heap[null, heapseg#sm(x, null)][o_92, f_68] || Heap[null, heapseg#sm(Heap[x, sibling], null)][o_92, f_68] ==> newPMask[o_92, f_68]
              );
              Heap := Heap[null, heapseg#sm(x, null):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
        // Exhale invariant
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not be preserved. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@195.13--195.50) [100534]"}
            perm <= Mask[null, heapseg(arg, res)];
        }
        Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(arg, res), write) && sorted(arg, res) might not be preserved. Assertion sorted(arg, res) might not hold. (BinomialHeap.vpr@195.13--195.50) [100535]"}
          sorted(Heap, arg, res);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not be preserved. There might be insufficient permission to access heapseg(res, x) (BinomialHeap.vpr@196.13--196.46) [100536]"}
            perm <= Mask[null, heapseg(res, x)];
        }
        Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(res, x), write) && sorted(res, x) might not be preserved. Assertion sorted(res, x) might not hold. (BinomialHeap.vpr@196.13--196.46) [100537]"}
          sorted(Heap, res, x);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not be preserved. There might be insufficient permission to access heapseg(x, null) (BinomialHeap.vpr@197.13--197.48) [100538]"}
            perm <= Mask[null, heapseg(x, null)];
        }
        Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(x, null), write) && sorted(x, null) might not be preserved. Assertion sorted(x, null) might not hold. (BinomialHeap.vpr@197.13--197.48) [100539]"}
          sorted(Heap, x, null);
        if (arg != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not be preserved. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, x, 0) might not hold. (BinomialHeap.vpr@198.13--198.107) [100540]"}
            segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, res, x, 0);
        }
        if (x != null && res != x) {
          assert {:msg "  Loop invariant x != null && res != x ==> segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not be preserved. Assertion segDegree(res, x, segLength(res, x) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@199.13--199.103) [100541]"}
            segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
        }
        if (arg != res && (res == x && x != null)) {
          assert {:msg "  Loop invariant arg != res && (res == x && x != null) ==> segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not be preserved. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(x, null, 0) might not hold. (BinomialHeap.vpr@200.13--200.121) [100542]"}
            segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, x, null, 0);
        }
        assert {:msg "  Loop invariant res != null might not be preserved. Assertion res != null might not hold. (BinomialHeap.vpr@201.13--201.24) [100543]"}
          res != null;
        assert {:msg "  Loop invariant segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not be preserved. Assertion segSize(arg, res) + segSize(res, x) + segSize(x, null) == old(segSize(arg, null)) might not hold. (BinomialHeap.vpr@202.13--202.94) [100544]"}
          segSize(Heap, arg, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg, null);
        if (arg != res && res != x) {
          assert {:msg "  Loop invariant arg != res && res != x ==> segParent(arg, res) == segParent(res, x) might not be preserved. Assertion segParent(arg, res) == segParent(res, x) might not hold. (BinomialHeap.vpr@203.13--203.80) [100545]"}
            segParent(Heap, arg, res) == segParent(Heap, res, x);
        }
        if (res != x && x != null) {
          assert {:msg "  Loop invariant res != x && x != null ==> segParent(res, x) == segParent(x, null) might not be preserved. Assertion segParent(res, x) == segParent(x, null) might not hold. (BinomialHeap.vpr@204.13--204.78) [100546]"}
            segParent(Heap, res, x) == segParent(Heap, x, null);
        }
        if (arg != res && x != null) {
          assert {:msg "  Loop invariant arg != res && x != null ==> segParent(arg, res) == segParent(x, null) might not be preserved. Assertion segParent(arg, res) == segParent(x, null) might not hold. (BinomialHeap.vpr@205.13--205.82) [100547]"}
            segParent(Heap, arg, res) == segParent(Heap, x, null);
        }
        if (arg != res) {
          assert {:msg "  Loop invariant arg != res ==> segParent(arg, res) == old(segParent(arg, null)) might not be preserved. Assertion segParent(arg, res) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@206.13--206.76) [100548]"}
            segParent(Heap, arg, res) == segParent(oldHeap, arg, null);
        }
        if (res != x) {
          assert {:msg "  Loop invariant res != x ==> segParent(res, x) == old(segParent(arg, null)) might not be preserved. Assertion segParent(res, x) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@207.13--207.72) [100549]"}
            segParent(Heap, res, x) == segParent(oldHeap, arg, null);
        }
        if (x != null) {
          assert {:msg "  Loop invariant x != null ==> segParent(x, null) == old(segParent(arg, null)) might not be preserved. Assertion segParent(x, null) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@208.13--208.74) [100550]"}
            segParent(Heap, x, null) == segParent(oldHeap, arg, null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Terminate execution
        assume false;
      }
    
    // -- Inhale loop invariant after loop, and assume guard
      assume !(x != null);
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted(Heap, arg, res);
      perm := FullPerm;
      Mask := Mask[null, heapseg(res, x):=Mask[null, heapseg(res, x)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted(Heap, res, x);
      perm := FullPerm;
      Mask := Mask[null, heapseg(x, null):=Mask[null, heapseg(x, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted(Heap, x, null);
      if (arg != res && res != x) {
        assume state(Heap, Mask);
        assume segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, res, x, 0);
      }
      if (x != null && res != x) {
        assume state(Heap, Mask);
        assume segDegree(Heap, res, x, segLength(Heap, res, x) - 1) < segDegree(Heap, x, null, 0);
      }
      if (arg != res && (res == x && x != null)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, x, null, 0);
      }
      assume res != null;
      assume state(Heap, Mask);
      assume segSize(Heap, arg, res) + segSize(Heap, res, x) + segSize(Heap, x, null) == segSize(oldHeap, arg, null);
      if (arg != res && res != x) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg, res) == segParent(Heap, res, x);
      }
      if (res != x && x != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, res, x) == segParent(Heap, x, null);
      }
      if (arg != res && x != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg, res) == segParent(Heap, x, null);
      }
      if (arg != res) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg, res) == segParent(oldHeap, arg, null);
      }
      if (res != x) {
        assume state(Heap, Mask);
        assume segParent(Heap, res, x) == segParent(oldHeap, arg, null);
      }
      if (x != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, x, null) == segParent(oldHeap, arg, null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion res != null might not hold. (BinomialHeap.vpr@178.10--178.21) [100551]"}
      res != null;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of findMinNode might not hold. There might be insufficient permission to access heapseg(arg, res) (BinomialHeap.vpr@179.10--179.47) [100552]"}
        perm <= Mask[null, heapseg(arg, res)];
    }
    Mask := Mask[null, heapseg(arg, res):=Mask[null, heapseg(arg, res)] - perm];
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion sorted(arg, res) might not hold. (BinomialHeap.vpr@179.10--179.47) [100553]"}
      sorted(Heap, arg, res);
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of findMinNode might not hold. There might be insufficient permission to access heapseg(res, null) (BinomialHeap.vpr@180.10--180.49) [100554]"}
        perm <= Mask[null, heapseg(res, null)];
    }
    Mask := Mask[null, heapseg(res, null):=Mask[null, heapseg(res, null)] - perm];
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion sorted(res, null) might not hold. (BinomialHeap.vpr@180.10--180.49) [100555]"}
      sorted(Heap, res, null);
    if (arg != res) {
      assert {:msg "  Postcondition of findMinNode might not hold. Assertion segDegree(arg, res, segLength(arg, res) - 1) < segDegree(res, null, 0) might not hold. (BinomialHeap.vpr@181.10--181.95) [100556]"}
        segDegree(Heap, arg, res, segLength(Heap, arg, res) - 1) < segDegree(Heap, res, null, 0);
    }
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion segSize(arg, res) + segSize(res, null) == old(segSize(arg, null)) might not hold. (BinomialHeap.vpr@182.10--182.75) [100557]"}
      segSize(Heap, arg, res) + segSize(Heap, res, null) == segSize(oldHeap, arg, null);
    if (arg != res) {
      assert {:msg "  Postcondition of findMinNode might not hold. Assertion segParent(arg, res) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@183.10--183.73) [100558]"}
        segParent(Heap, arg, res) == segParent(oldHeap, arg, null);
    }
    assert {:msg "  Postcondition of findMinNode might not hold. Assertion segParent(res, null) == old(segParent(arg, null)) might not hold. (BinomialHeap.vpr@184.10--184.59) [100559]"}
      segParent(Heap, res, null) == segParent(oldHeap, arg, null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method merge
// ==================================================

procedure merge(this: Ref, binHeap: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var temp1: Ref;
  var temp2: Ref;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var tmp: Ref;
  var newVersion: FrameType;
  var ExhaleWellDef1Heap: HeapType;
  var ExhaleWellDef1Mask: MaskType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var arg_a: Ref;
  var arg_a_1: Ref;
  var arg_a_2: Ref;
  var t_2: Ref;
  var Unfolding1Heap: HeapType;
  var Unfolding1Mask: MaskType;
  var Unfolding2Heap: HeapType;
  var Unfolding2Mask: MaskType;
  var arg_a_3: Ref;
  var arg_a_4: Ref;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
    assume Heap[binHeap, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@247.11--248.54) [100560]"}
        HasDirectPerm(Mask, this, Nodes);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@247.11--248.54) [100561]"}
        HasDirectPerm(Mask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@248.30--248.54) [100562]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(Heap, Heap[this, Nodes], null);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@249.11--249.29) [100563]"}
        HasDirectPerm(Mask, this, Nodes);
    assume Heap[this, Nodes] != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(binHeap, null):=Mask[null, heapseg(binHeap, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(binHeap, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@250.37--250.58) [100564]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(Heap, binHeap, null);
    assume state(Heap, Mask);
    if (binHeap != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.Nodes, null) == segParent(binHeap, null)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@251.11--251.86) [100565]"}
          HasDirectPerm(Mask, this, Nodes);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@251.31--251.58) [100566]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@251.31--251.58) [100567]"}
            Heap[this, Nodes] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@251.62--251.86) [100568]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion binHeap != null might not hold. (BinomialHeap.vpr@251.62--251.86) [100569]"}
            binHeap != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, Nodes], null) == segParent(Heap, binHeap, null);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    assume this != null;
    PostMask := PostMask[this, Nodes:=PostMask[this, Nodes] + perm];
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [100570]"}
        HasDirectPerm(PostMask, this, Nodes);
    assume PostHeap[this, Nodes] != null;
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [100571]"}
        HasDirectPerm(PostMask, this, Nodes);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(PostHeap[this, Nodes], null):=PostMask[null, heapseg(PostHeap[this, Nodes], null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of presorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [100572]"}
        HasDirectPerm(PostMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@252.80--252.107) [100573]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume presorted(PostHeap, PostHeap[this, Nodes], null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@253.10--253.99) [100574]"}
        HasDirectPerm(PostMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@253.10--253.35) [100575]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@253.10--253.99) [100576]"}
        HasDirectPerm(oldMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@253.43--253.68) [100577]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@253.76--253.98) [100578]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, PostHeap[this, Nodes], null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(this.Nodes, null) == old(segParent(this.Nodes, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@254.10--254.73) [100579]"}
        HasDirectPerm(PostMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@254.10--254.37) [100580]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@254.10--254.37) [100581]"}
          PostHeap[this, Nodes] != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@254.10--254.73) [100582]"}
        HasDirectPerm(oldMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@254.45--254.72) [100583]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@254.45--254.72) [100584]"}
          oldHeap[this, Nodes] != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, PostHeap[this, Nodes], null) == segParent(oldHeap, oldHeap[this, Nodes], null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[temp1, $allocated];
    assume Heap[temp2, $allocated];
  
  // -- Translating statement: temp1 := this.Nodes -- BinomialHeap.vpr@258.2--258.21
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@258.2--258.21) [100585]"}
        HasDirectPerm(Mask, this, Nodes);
    temp1 := Heap[this, Nodes];
    assume state(Heap, Mask);
  
  // -- Translating statement: temp2 := binHeap -- BinomialHeap.vpr@259.2--259.18
    temp2 := binHeap;
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(this.Nodes, temp1), write) -- BinomialHeap.vpr@261.2--261.33
    
    // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
      assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@261.2--261.33) [100586]"}
        HasDirectPerm(Mask, this, Nodes);
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (Heap[this, Nodes] != temp1) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@261.2--261.33) [100589]"}
          perm <= Mask[null, tree(Heap[this, Nodes])];
      }
      Mask := Mask[null, tree(Heap[this, Nodes]):=Mask[null, tree(Heap[this, Nodes])] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(Heap[this, Nodes], temp1), Heap[null, heapseg(Heap[this, Nodes], temp1)], tree(Heap[this, Nodes]), Heap[null, tree(Heap[this, Nodes])]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@261.2--261.33) [100591]"}
          perm <= Mask[Heap[this, Nodes], sibling];
      }
      Mask := Mask[Heap[this, Nodes], sibling:=Mask[Heap[this, Nodes], sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp1) (BinomialHeap.vpr@261.2--261.33) [100593]"}
          perm <= Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)];
      }
      Mask := Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1):=Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(Heap[this, Nodes], temp1), Heap[null, heapseg(Heap[this, Nodes], temp1)], heapseg(Heap[Heap[this, Nodes], sibling], temp1), Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)]);
      if (Heap[Heap[this, Nodes], sibling] != temp1) {
        assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp1) might not hold. (BinomialHeap.vpr@261.2--261.33) [100594]"}
          treeParent(Heap, Heap[this, Nodes]) == segParent(Heap, Heap[Heap[this, Nodes], sibling], temp1);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes], temp1));
    assume Heap[null, heapseg(Heap[this, Nodes], temp1)] == FrameFragment((if Heap[this, Nodes] != temp1 then CombineFrames(Heap[null, tree(Heap[this, Nodes])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)], FrameFragment((if Heap[Heap[this, Nodes], sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes], temp1))) {
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(Heap[this, Nodes], temp1):=freshVersion];
    }
    if (Heap[this, Nodes] != temp1) {
      havoc newPMask;
      assume (forall <A, B> o_93: Ref, f_95: (Field A B) ::
        { newPMask[o_93, f_95] }
        Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][o_93, f_95] || Heap[null, tree#sm(Heap[this, Nodes])][o_93, f_95] ==> newPMask[o_93, f_95]
      );
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=newPMask];
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][Heap[this, Nodes], sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_65: Ref, f_96: (Field A B) ::
        { newPMask[o_65, f_96] }
        Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][o_65, f_96] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes], sibling], temp1)][o_65, f_96] ==> newPMask[o_65, f_96]
      );
      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: while (temp1 != null && temp2 != null) -- BinomialHeap.vpr@262.2--352.3
    
    // -- Before loop head
      
      // -- Exhale loop invariant before loop
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not hold on entry. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@263.13--263.56) [100596]"}
            perm <= Mask[null, heapseg(temp1, null)];
        }
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not hold on entry. Assertion sorted(temp1, null) might not hold. (BinomialHeap.vpr@263.13--263.56) [100597]"}
          sorted(Heap, temp1, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@264.13--264.56) [100598]"}
            perm <= Mask[null, heapseg(temp2, null)];
        }
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@264.13--264.56) [100599]"}
          sorted(Heap, temp2, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@265.13--265.50) [100600]"}
            perm <= Mask[this, Nodes];
        }
        Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
        assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@265.13--265.50) [100601]"}
          Heap[this, Nodes] != null;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@266.13--266.71) [100602]"}
            perm <= Mask[null, heapseg(Heap[this, Nodes], temp1)];
        }
        Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@266.13--266.71) [100603]"}
          presorted(Heap, Heap[this, Nodes], temp1);
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp1, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [100604]"}
            segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [100605]"}
              segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp2, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [100606]"}
            segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [100607]"}
              segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@277.13--279.93) [100608]"}
            segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        if (temp1 != Heap[this, Nodes] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant temp1 != this.Nodes && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not hold on entry. Assertion segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@280.13--281.56) [100609]"}
            segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@282.13--282.149) [100610]"}
          segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        if (temp1 != null && temp2 != null) {
          assert {:msg "  Loop invariant temp1 != null && temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not hold on entry. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@283.13--283.96) [100611]"}
            segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes] != temp1 && temp1 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp1 != null ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@284.13--284.108) [100612]"}
            segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
        }
        if (Heap[this, Nodes] != temp1 && temp2 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@285.13--285.108) [100613]"}
            segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes] != temp1) {
          assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@286.13--286.101) [100614]"}
            segParent(Heap, Heap[this, Nodes], temp1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        if (temp1 != null) {
          assert {:msg "  Loop invariant temp1 != null ==> segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@287.13--287.89) [100615]"}
            segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        if (temp2 != null) {
          assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@288.13--288.89) [100616]"}
            segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
    
    // -- Havoc loop written variables (except locals)
      havoc temp2, temp1;
      assume Heap[temp2, $allocated];
      assume Heap[temp1, $allocated];
    
    // -- Check definedness of invariant
      if (*) {
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(temp1, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@263.37--263.56) [100617]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted(Heap, temp1, null);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of sorted(temp2, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@264.37--264.56) [100618]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume sorted(Heap, temp2, null);
        assume state(Heap, Mask);
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != null
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@265.13--265.50) [100619]"}
            HasDirectPerm(Mask, this, Nodes);
        assume Heap[this, Nodes] != null;
        assume state(Heap, Mask);
        
        // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@266.13--266.71) [100620]"}
            HasDirectPerm(Mask, this, Nodes);
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of presorted(this.Nodes, temp1)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@266.13--266.71) [100621]"}
            HasDirectPerm(Mask, this, Nodes);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@266.43--266.71) [100622]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume presorted(Heap, Heap[this, Nodes], temp1);
        assume state(Heap, Mask);
        
        // -- Check definedness of 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100623]"}
            HasDirectPerm(Mask, this, Nodes);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@267.17--267.45) [100624]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@267.53--267.75) [100625]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp1, null)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100626]"}
              HasDirectPerm(Mask, this, Nodes);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100627]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@268.31--268.59) [100628]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@268.2--268.64) [100629]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@268.2--268.64) [100630]"}
                0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@268.2--268.64) [100631]"}
                segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@268.68--268.93) [100632]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@268.68--268.93) [100633]"}
                0 < segLength(Heap, temp1, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          
          // -- Check definedness of 2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100634]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@269.8--269.36) [100635]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (2 <= segLength(Heap, Heap[this, Nodes], temp1)) {
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100636]"}
                HasDirectPerm(Mask, this, Nodes);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100637]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.31--270.59) [100638]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.2--270.64) [100639]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@270.2--270.64) [100640]"}
                  0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@270.2--270.64) [100641]"}
                  segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100642]"}
                HasDirectPerm(Mask, this, Nodes);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100643]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.97--270.125) [100644]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@270.68--270.130) [100645]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 2 might not hold. (BinomialHeap.vpr@270.68--270.130) [100646]"}
                  0 <= segLength(Heap, Heap[this, Nodes], temp1) - 2;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 2 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@270.68--270.130) [100647]"}
                  segLength(Heap, Heap[this, Nodes], temp1) - 2 < segLength(Heap, Heap[this, Nodes], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assume state(Heap, Mask);
            
            // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100648]"}
                HasDirectPerm(Mask, this, Nodes);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@267.13--271.93) [100649]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@271.31--271.59) [100650]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@271.2--271.64) [100651]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@271.2--271.64) [100652]"}
                  0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@271.2--271.64) [100653]"}
                  segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@271.67--271.92) [100654]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@271.67--271.92) [100655]"}
                  0 < segLength(Heap, temp1, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null)
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100656]"}
            HasDirectPerm(Mask, this, Nodes);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@272.17--272.45) [100657]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@272.53--272.75) [100658]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp2, null)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100659]"}
              HasDirectPerm(Mask, this, Nodes);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100660]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@273.31--273.59) [100661]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@273.2--273.64) [100662]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@273.2--273.64) [100663]"}
                0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@273.2--273.64) [100664]"}
                segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@273.68--273.93) [100665]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@273.68--273.93) [100666]"}
                0 < segLength(Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          
          // -- Check definedness of 2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100667]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@274.8--274.36) [100668]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (2 <= segLength(Heap, Heap[this, Nodes], temp1)) {
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100669]"}
                HasDirectPerm(Mask, this, Nodes);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100670]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.31--275.59) [100671]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.2--275.64) [100672]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@275.2--275.64) [100673]"}
                  0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@275.2--275.64) [100674]"}
                  segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100675]"}
                HasDirectPerm(Mask, this, Nodes);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100676]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.97--275.125) [100677]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@275.68--275.130) [100678]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 2 might not hold. (BinomialHeap.vpr@275.68--275.130) [100679]"}
                  0 <= segLength(Heap, Heap[this, Nodes], temp1) - 2;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 2 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@275.68--275.130) [100680]"}
                  segLength(Heap, Heap[this, Nodes], temp1) - 2 < segLength(Heap, Heap[this, Nodes], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assume state(Heap, Mask);
            
            // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100681]"}
                HasDirectPerm(Mask, this, Nodes);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@272.13--276.93) [100682]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@276.31--276.59) [100683]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@276.2--276.64) [100684]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@276.2--276.64) [100685]"}
                  0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@276.2--276.64) [100686]"}
                  segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@276.67--276.92) [100687]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@276.67--276.92) [100688]"}
                  0 < segLength(Heap, temp2, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of 0 < segLength(this.Nodes, temp1) && (0 < segLength(temp1, null) && 0 < segLength(temp2, null))
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [100689]"}
            HasDirectPerm(Mask, this, Nodes);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@277.17--277.45) [100690]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@277.53--277.75) [100691]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (0 < segLength(Heap, temp1, null)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@277.83--277.105) [100692]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [100693]"}
              HasDirectPerm(Mask, this, Nodes);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [100694]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@278.32--278.60) [100695]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@278.3--278.65) [100696]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@278.3--278.65) [100697]"}
                0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@278.3--278.65) [100698]"}
                segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@278.68--278.93) [100699]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@278.68--278.93) [100700]"}
                0 < segLength(Heap, temp1, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (!(segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0))) {
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [100701]"}
                HasDirectPerm(Mask, this, Nodes);
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@277.13--279.93) [100702]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@279.31--279.59) [100703]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@279.2--279.64) [100704]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@279.2--279.64) [100705]"}
                  0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@279.2--279.64) [100706]"}
                  segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@279.67--279.92) [100707]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@279.67--279.92) [100708]"}
                  0 < segLength(Heap, temp2, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of temp1 != this.Nodes && (0 < segLength(temp1, null) && 0 < segLength(temp2, null))
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@280.13--281.56) [100709]"}
            HasDirectPerm(Mask, this, Nodes);
          if (temp1 != Heap[this, Nodes]) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@280.40--280.62) [100710]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (0 < segLength(Heap, temp1, null)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@280.70--280.92) [100711]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            }
          }
        if (temp1 != Heap[this, Nodes] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(temp1, null, 0) <= segDegree(temp2, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@281.2--281.27) [100712]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@281.2--281.27) [100713]"}
                0 < segLength(Heap, temp1, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@281.31--281.56) [100714]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@281.31--281.56) [100715]"}
                0 < segLength(Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@282.13--282.149) [100716]"}
            HasDirectPerm(Mask, this, Nodes);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@282.13--282.39) [100717]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@282.42--282.62) [100718]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@282.65--282.85) [100719]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@282.13--282.149) [100720]"}
            HasDirectPerm(oldMask, this, Nodes);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@282.93--282.118) [100721]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
            // Finish exhale
            // Stop execution
            assume false;
          }
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@282.126--282.148) [100722]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
            // Finish exhale
            // Stop execution
            assume false;
          }
        assume segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        assume state(Heap, Mask);
        if (temp1 != null && temp2 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(temp1, null) == segParent(temp2, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@283.48--283.70) [100723]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@283.48--283.70) [100724]"}
                temp1 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@283.74--283.96) [100725]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@283.74--283.96) [100726]"}
                temp2 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != temp1 && temp1 != null
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@284.13--284.108) [100727]"}
            HasDirectPerm(Mask, this, Nodes);
        if (Heap[this, Nodes] != temp1 && temp1 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp1, null)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@284.13--284.108) [100728]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@284.54--284.82) [100729]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@284.54--284.82) [100730]"}
                Heap[this, Nodes] != temp1;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@284.86--284.108) [100731]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@284.86--284.108) [100732]"}
                temp1 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != temp1 && temp2 != null
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@285.13--285.108) [100733]"}
            HasDirectPerm(Mask, this, Nodes);
        if (Heap[this, Nodes] != temp1 && temp2 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp2, null)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@285.13--285.108) [100734]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@285.54--285.82) [100735]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@285.54--285.82) [100736]"}
                Heap[this, Nodes] != temp1;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@285.86--285.108) [100737]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@285.86--285.108) [100738]"}
                temp2 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of this.Nodes != temp1
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@286.13--286.101) [100739]"}
            HasDirectPerm(Mask, this, Nodes);
        if (Heap[this, Nodes] != temp1) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null))
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@286.13--286.101) [100740]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@286.37--286.65) [100741]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@286.37--286.65) [100742]"}
                Heap[this, Nodes] != temp1;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@286.13--286.101) [100743]"}
              HasDirectPerm(oldMask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@286.73--286.100) [100744]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@286.73--286.100) [100745]"}
                oldHeap[this, Nodes] != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        assume state(Heap, Mask);
        if (temp1 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(temp1, null) == old(segParent(this.Nodes, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@287.31--287.53) [100746]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@287.31--287.53) [100747]"}
                temp1 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@287.13--287.89) [100748]"}
              HasDirectPerm(oldMask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@287.61--287.88) [100749]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@287.61--287.88) [100750]"}
                oldHeap[this, Nodes] != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        assume state(Heap, Mask);
        if (temp2 != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(temp2, null) == old(segParent(this.Nodes, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@288.31--288.53) [100751]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@288.31--288.53) [100752]"}
                temp2 != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@288.13--288.89) [100753]"}
              HasDirectPerm(oldMask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@288.61--288.88) [100754]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@288.61--288.88) [100755]"}
                oldHeap[this, Nodes] != null;
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        assume state(Heap, Mask);
        assume false;
      }
    
    // -- Check the loop body
      if (*) {
        // Reset state
        loopHeap := Heap;
        loopMask := Mask;
        Mask := ZeroMask;
        assume state(Heap, Mask);
        // Inhale invariant
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted(Heap, temp1, null);
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted(Heap, temp2, null);
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
        assume state(Heap, Mask);
        assume Heap[this, Nodes] != null;
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume presorted(Heap, Heap[this, Nodes], temp1);
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp1, null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp2, null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        if (temp1 != Heap[this, Nodes] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assume state(Heap, Mask);
          assume segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assume state(Heap, Mask);
        assume segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        if (temp1 != null && temp2 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes] != temp1 && temp1 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
        }
        if (Heap[this, Nodes] != temp1 && temp2 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes] != temp1) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        if (temp1 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        if (temp2 != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        assume state(Heap, Mask);
        // Check and assume guard
        assume temp1 != null && temp2 != null;
        assume state(Heap, Mask);
        
        // -- Translate loop body
          
          // -- Assumptions about local variables
            assume Heap[tmp, $allocated];
          
          // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@291.3--291.30
            assume heapseg#trigger(Heap, heapseg(temp1, null));
            assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@291.3--291.30) [100756]"}
                perm <= Mask[null, heapseg(temp1, null)];
            }
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(temp1, null):=newVersion];
              }
            if (temp1 != null) {
              perm := FullPerm;
              Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree(temp1), Heap[null, tree(temp1)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume temp1 != null;
              Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[temp1, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: unfold acc(heapseg(temp2, null), write) -- BinomialHeap.vpr@292.3--292.30
            assume heapseg#trigger(Heap, heapseg(temp2, null));
            assume Heap[null, heapseg(temp2, null)] == FrameFragment((if temp2 != null then CombineFrames(Heap[null, tree(temp2)], CombineFrames(FrameFragment(Heap[temp2, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp2, sibling], null)], FrameFragment((if Heap[temp2, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(temp2, null) might fail. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@292.3--292.30) [100757]"}
                perm <= Mask[null, heapseg(temp2, null)];
            }
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(temp2, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(temp2, null):=newVersion];
              }
            if (temp2 != null) {
              perm := FullPerm;
              Mask := Mask[null, tree(temp2):=Mask[null, tree(temp2)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], tree(temp2), Heap[null, tree(temp2)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume temp2 != null;
              Mask := Mask[temp2, sibling:=Mask[temp2, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[temp2, sibling], null):=Mask[null, heapseg(Heap[temp2, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], heapseg(Heap[temp2, sibling], null), Heap[null, heapseg(Heap[temp2, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[temp2, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, temp2) == segParent(Heap, Heap[temp2, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (treeDegree(temp1) == treeDegree(temp2)) -- BinomialHeap.vpr@294.3--351.4
            
            // -- Check definedness of treeDegree(temp1) == treeDegree(temp2)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@294.6--294.23) [100758]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree(temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@294.27--294.44) [100759]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree(temp2)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (treeDegree(Heap, temp1) == treeDegree(Heap, temp2)) {
              
              // -- Translating statement: tmp := temp2 -- BinomialHeap.vpr@295.4--295.16
                tmp := temp2;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp2 := temp2.sibling -- BinomialHeap.vpr@296.4--296.26
                
                // -- Check definedness of temp2.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@296.4--296.26) [100760]"}
                    HasDirectPerm(Mask, temp2, sibling);
                temp2 := Heap[temp2, sibling];
                assume state(Heap, Mask);
              
              // -- Translating statement: tmp.sibling := temp1.sibling -- BinomialHeap.vpr@297.4--297.32
                
                // -- Check definedness of temp1.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@297.4--297.32) [100761]"}
                    HasDirectPerm(Mask, temp1, sibling);
                assert {:msg "  Assignment might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@297.4--297.32) [100762]"}
                  FullPerm == Mask[tmp, sibling];
                Heap := Heap[tmp, sibling:=Heap[temp1, sibling]];
                assume state(Heap, Mask);
              
              // -- Translating statement: temp1.sibling := tmp -- BinomialHeap.vpr@298.4--298.24
                assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@298.4--298.24) [100763]"}
                  FullPerm == Mask[temp1, sibling];
                Heap := Heap[temp1, sibling:=tmp];
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(tmp, tmp), write) -- BinomialHeap.vpr@300.4--300.26
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (tmp != tmp) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@300.4--300.26) [100764]"}
                      perm <= Mask[null, tree(tmp)];
                  }
                  Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], tree(tmp), Heap[null, tree(tmp)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@300.4--300.26) [100765]"}
                      perm <= Mask[tmp, sibling];
                  }
                  Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access heapseg(tmp.sibling, tmp) (BinomialHeap.vpr@300.4--300.26) [100766]"}
                      perm <= Mask[null, heapseg(Heap[tmp, sibling], tmp)];
                  }
                  Mask := Mask[null, heapseg(Heap[tmp, sibling], tmp):=Mask[null, heapseg(Heap[tmp, sibling], tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], heapseg(Heap[tmp, sibling], tmp), Heap[null, heapseg(Heap[tmp, sibling], tmp)]);
                  if (Heap[tmp, sibling] != tmp) {
                    assert {:msg "  Folding heapseg(tmp, tmp) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, tmp) might not hold. (BinomialHeap.vpr@300.4--300.26) [100767]"}
                      treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], tmp);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(tmp, tmp):=Mask[null, heapseg(tmp, tmp)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(tmp, tmp));
                assume Heap[null, heapseg(tmp, tmp)] == FrameFragment((if tmp != tmp then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], tmp)], FrameFragment((if Heap[tmp, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(tmp, tmp))) {
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(tmp, tmp):=freshVersion];
                }
                if (tmp != tmp) {
                  havoc newPMask;
                  assume (forall <A, B> o_94: Ref, f_97: (Field A B) ::
                    { newPMask[o_94, f_97] }
                    Heap[null, heapseg#sm(tmp, tmp)][o_94, f_97] || Heap[null, tree#sm(tmp)][o_94, f_97] ==> newPMask[o_94, f_97]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=Heap[null, heapseg#sm(tmp, tmp)][tmp, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_95: Ref, f_98: (Field A B) ::
                    { newPMask[o_95, f_98] }
                    Heap[null, heapseg#sm(tmp, tmp)][o_95, f_98] || Heap[null, heapseg#sm(Heap[tmp, sibling], tmp)][o_95, f_98] ==> newPMask[o_95, f_98]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp1, tmp), write) -- BinomialHeap.vpr@301.4--301.28
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp1 != tmp) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@301.4--301.28) [100768]"}
                      perm <= Mask[null, tree(temp1)];
                  }
                  Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], tree(temp1), Heap[null, tree(temp1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@301.4--301.28) [100769]"}
                      perm <= Mask[temp1, sibling];
                  }
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access heapseg(temp1.sibling, tmp) (BinomialHeap.vpr@301.4--301.28) [100770]"}
                      perm <= Mask[null, heapseg(Heap[temp1, sibling], tmp)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], tmp):=Mask[null, heapseg(Heap[temp1, sibling], tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], heapseg(Heap[temp1, sibling], tmp), Heap[null, heapseg(Heap[temp1, sibling], tmp)]);
                  if (Heap[temp1, sibling] != tmp) {
                    assert {:msg "  Folding heapseg(temp1, tmp) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, tmp) might not hold. (BinomialHeap.vpr@301.4--301.28) [100771]"}
                      treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], tmp);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp1, tmp));
                assume Heap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], tmp)], FrameFragment((if Heap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp1, tmp))) {
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp1, tmp):=freshVersion];
                }
                if (temp1 != tmp) {
                  havoc newPMask;
                  assume (forall <A, B> o_96: Ref, f_99: (Field A B) ::
                    { newPMask[o_96, f_99] }
                    Heap[null, heapseg#sm(temp1, tmp)][o_96, f_99] || Heap[null, tree#sm(temp1)][o_96, f_99] ==> newPMask[o_96, f_99]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_97: Ref, f_100: (Field A B) ::
                    { newPMask[o_97, f_100] }
                    Heap[null, heapseg#sm(temp1, tmp)][o_97, f_100] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_97, f_100] ==> newPMask[o_97, f_100]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: assert segSize(temp1, tmp) ==
  //   (unfolding acc(heapseg(temp1, tmp), write) in treeSize(temp1)) -- BinomialHeap.vpr@302.4--302.82
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                
                // -- Check definedness of segSize(temp1, tmp) == (unfolding acc(heapseg(temp1, tmp), write) in treeSize(temp1))
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef1Heap := ExhaleWellDef0Heap;
                    ExhaleWellDef1Mask := ExhaleWellDef0Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@302.11--302.30) [100772]"}
                      NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp1, tmp)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
                    ExhaleWellDef0Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  UnfoldingHeap := ExhaleWellDef0Heap;
                  UnfoldingMask := ExhaleWellDef0Mask;
                  assume heapseg#trigger(UnfoldingHeap, heapseg(temp1, tmp));
                  assume UnfoldingHeap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(UnfoldingHeap[null, tree(temp1)], CombineFrames(FrameFragment(UnfoldingHeap[temp1, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], tmp)], FrameFragment((if UnfoldingHeap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                  ExhaleWellDef1Heap := UnfoldingHeap;
                  ExhaleWellDef1Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@302.11--302.82) [100773]"}
                      perm <= UnfoldingMask[null, heapseg(temp1, tmp)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heapseg(temp1, tmp):=UnfoldingMask[null, heapseg(temp1, tmp)] - perm];
                  if (temp1 != tmp) {
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, tree(temp1):=UnfoldingMask[null, tree(temp1)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, tmp), UnfoldingHeap[null, heapseg(temp1, tmp)], tree(temp1), UnfoldingHeap[null, tree(temp1)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    assume temp1 != null;
                    UnfoldingMask := UnfoldingMask[temp1, sibling:=UnfoldingMask[temp1, sibling] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], tmp):=UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], tmp)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, tmp), UnfoldingHeap[null, heapseg(temp1, tmp)], heapseg(UnfoldingHeap[temp1, sibling], tmp), UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], tmp)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    if (UnfoldingHeap[temp1, sibling] != tmp) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume treeParent(UnfoldingHeap, temp1) == segParent(UnfoldingHeap, UnfoldingHeap[temp1, sibling], tmp);
                    }
                  }
                  assume state(UnfoldingHeap, UnfoldingMask);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef1Heap := UnfoldingHeap;
                    ExhaleWellDef1Mask := UnfoldingMask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@302.67--302.82) [100774]"}
                      NoPerm < perm ==> NoPerm < UnfoldingMask[null, tree(temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
                    UnfoldingHeap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  
                  // -- Free assumptions (exp module)
                    if (temp1 != tmp) {
                      havoc newPMask;
                      assume (forall <A, B> o_98: Ref, f_101: (Field A B) ::
                        { newPMask[o_98, f_101] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_98, f_101] || Heap[null, tree#sm(temp1)][o_98, f_101] ==> newPMask[o_98, f_101]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_99: Ref, f_75: (Field A B) ::
                        { newPMask[o_99, f_75] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_99, f_75] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_99, f_75] ==> newPMask[o_99, f_75]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                    }
                    assume state(Heap, Mask);
                  
                  // -- Free assumptions (exp module)
                    if (temp1 != tmp) {
                      havoc newPMask;
                      assume (forall <A, B> o_100: Ref, f_102: (Field A B) ::
                        { newPMask[o_100, f_102] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_100, f_102] || Heap[null, tree#sm(temp1)][o_100, f_102] ==> newPMask[o_100, f_102]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_101: Ref, f_103: (Field A B) ::
                        { newPMask[o_101, f_103] }
                        Heap[null, heapseg#sm(temp1, tmp)][o_101, f_103] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_101, f_103] ==> newPMask[o_101, f_103]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                    }
                    assume state(Heap, Mask);
                assert {:msg "  Assert might fail. Assertion segSize(temp1, tmp) == (unfolding acc(heapseg(temp1, tmp), write) in treeSize(temp1)) might not hold. (BinomialHeap.vpr@302.11--302.82) [100775]"}
                  segSize(Heap, temp1, tmp) == treeSize(Heap, temp1);
                
                // -- Free assumptions (exhale module)
                  if (temp1 != tmp) {
                    havoc newPMask;
                    assume (forall <A, B> o_102: Ref, f_76: (Field A B) ::
                      { newPMask[o_102, f_76] }
                      Heap[null, heapseg#sm(temp1, tmp)][o_102, f_76] || Heap[null, tree#sm(temp1)][o_102, f_76] ==> newPMask[o_102, f_76]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                    Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_103: Ref, f_104: (Field A B) ::
                      { newPMask[o_103, f_104] }
                      Heap[null, heapseg#sm(temp1, tmp)][o_103, f_104] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_103, f_104] ==> newPMask[o_103, f_104]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: concat(this.Nodes, temp1, tmp) -- BinomialHeap.vpr@303.4--303.34
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Check definedness of this.Nodes
                  assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@303.4--303.34) [100776]"}
                    HasDirectPerm(Mask, this, Nodes);
                arg_a := Heap[this, Nodes];
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@303.4--303.34) [100777]"}
                      perm <= Mask[null, heapseg(arg_a, temp1)];
                  }
                  Mask := Mask[null, heapseg(arg_a, temp1):=Mask[null, heapseg(arg_a, temp1)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@303.4--303.34) [100778]"}
                      perm <= Mask[null, heapseg(temp1, tmp)];
                  }
                  Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] - perm];
                  if (tmp != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@303.4--303.34) [100779]"}
                        perm <= Mask[null, tree(tmp)];
                    }
                    Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                  }
                  if (arg_a != temp1 && temp1 != tmp) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, tmp) might not hold. (BinomialHeap.vpr@303.4--303.34) [100780]"}
                      segParent(Heap, arg_a, temp1) == segParent(Heap, temp1, tmp);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(arg_a, tmp):=Mask[null, heapseg(arg_a, tmp)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, arg_a, tmp) == segLength(PreCallHeap, arg_a, temp1) + segLength(PreCallHeap, temp1, tmp);
                  assume state(Heap, Mask);
                  assume (forall i: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a, tmp)], arg_a, tmp, i) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a, temp1)], arg_a, temp1, i) }
                    0 <= i && i < segLength(PreCallHeap, arg_a, temp1) ==> segDegree(Heap, arg_a, tmp, i) == segDegree(PreCallHeap, arg_a, temp1, i)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_1: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a, tmp)], arg_a, tmp, i_1) }
                    segLength(PreCallHeap, arg_a, temp1) <= i_1 && i_1 < segLength(Heap, arg_a, tmp) ==> segDegree(Heap, arg_a, tmp, i_1) == segDegree(PreCallHeap, temp1, tmp, i_1 - segLength(PreCallHeap, arg_a, temp1))
                  );
                  if (tmp != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, tmp) == treeDegree(PreCallHeap, tmp);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, tmp) == treeSize(PreCallHeap, tmp);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, tmp) == treeParent(PreCallHeap, tmp);
                  }
                  if (sorted(PreCallHeap, arg_a, temp1) && (sorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted(Heap, arg_a, tmp);
                  }
                  if (presorted(PreCallHeap, arg_a, temp1) && (presorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) <= segDegree(PreCallHeap, temp1, tmp, 0) && ((2 <= segLength(PreCallHeap, arg_a, temp1) && segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) == segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 2) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)) && (2 <= segLength(PreCallHeap, temp1, tmp) && segDegree(PreCallHeap, temp1, tmp, 0) == segDegree(PreCallHeap, temp1, tmp, 1) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, arg_a, tmp);
                  }
                  if (validChildren(PreCallHeap, arg_a, temp1) && (validChildren(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a, temp1, segLength(PreCallHeap, arg_a, temp1) - 1) == segDegree(PreCallHeap, temp1, tmp, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, arg_a, tmp);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, arg_a, tmp) == segSize(PreCallHeap, arg_a, temp1) + segSize(PreCallHeap, temp1, tmp);
                  if (arg_a != temp1) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a, tmp) == segParent(PreCallHeap, arg_a, temp1);
                  }
                  if (temp1 != tmp) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a, tmp) == segParent(PreCallHeap, temp1, tmp);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: temp1 := tmp -- BinomialHeap.vpr@305.4--305.16
                temp1 := tmp;
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@309.4--309.27
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (tmp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@309.4--309.27) [100781]"}
                      perm <= Mask[null, tree(tmp)];
                  }
                  Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree(tmp), Heap[null, tree(tmp)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@309.4--309.27) [100782]"}
                      perm <= Mask[tmp, sibling];
                  }
                  Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@309.4--309.27) [100783]"}
                      perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                  }
                  Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                  if (Heap[tmp, sibling] != null) {
                    assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@309.4--309.27) [100784]"}
                      treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(tmp, null));
                assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                  Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                }
                if (tmp != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_104: Ref, f_105: (Field A B) ::
                    { newPMask[o_104, f_105] }
                    Heap[null, heapseg#sm(tmp, null)][o_104, f_105] || Heap[null, tree#sm(tmp)][o_104, f_105] ==> newPMask[o_104, f_105]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_105: Ref, f_106: (Field A B) ::
                    { newPMask[o_105, f_106] }
                    Heap[null, heapseg#sm(tmp, null)][o_105, f_106] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_105, f_106] ==> newPMask[o_105, f_106]
                  );
                  Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: if (treeDegree(temp1) < treeDegree(temp2)) -- BinomialHeap.vpr@311.4--350.5
                
                // -- Check definedness of treeDegree(temp1) < treeDegree(temp2)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@311.7--311.24) [100785]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree(temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@311.27--311.44) [100786]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree(temp2)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                if (treeDegree(Heap, temp1) < treeDegree(Heap, temp2)) {
                  
                  // -- Translating statement: if (temp1.sibling == null || segDegree(temp1.sibling, null, 0) > treeDegree(temp2)) -- BinomialHeap.vpr@312.5--336.6
                    
                    // -- Check definedness of temp1.sibling == null || segDegree(temp1.sibling, null, 0) > treeDegree(temp2)
                      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@312.8--313.58) [100787]"}
                        HasDirectPerm(Mask, temp1, sibling);
                      if (!(Heap[temp1, sibling] == null)) {
                        assert {:msg "  Conditional statement might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@312.8--313.58) [100788]"}
                          HasDirectPerm(Mask, temp1, sibling);
                        if (*) {
                          // Exhale precondition of function application
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@313.5--313.38) [100789]"}
                            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[temp1, sibling], null)];
                          assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1.sibling, null) might not hold. (BinomialHeap.vpr@313.5--313.38) [100790]"}
                            0 < segLength(Heap, Heap[temp1, sibling], null);
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                          // Stop execution
                          assume false;
                        }
                        if (*) {
                          // Exhale precondition of function application
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@313.41--313.58) [100791]"}
                            NoPerm < perm ==> NoPerm < Mask[null, tree(temp2)];
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                          // Stop execution
                          assume false;
                        }
                      }
                    if (Heap[temp1, sibling] == null || segDegree(Heap, Heap[temp1, sibling], null, 0) > treeDegree(Heap, temp2)) {
                      
                      // -- Translating statement: tmp := temp2 -- BinomialHeap.vpr@314.6--314.18
                        tmp := temp2;
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp2 := temp2.sibling -- BinomialHeap.vpr@315.6--315.28
                        
                        // -- Check definedness of temp2.sibling
                          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@315.6--315.28) [100792]"}
                            HasDirectPerm(Mask, temp2, sibling);
                        temp2 := Heap[temp2, sibling];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: tmp.sibling := temp1.sibling -- BinomialHeap.vpr@316.6--316.34
                        
                        // -- Check definedness of temp1.sibling
                          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@316.6--316.34) [100793]"}
                            HasDirectPerm(Mask, temp1, sibling);
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@316.6--316.34) [100794]"}
                          FullPerm == Mask[tmp, sibling];
                        Heap := Heap[tmp, sibling:=Heap[temp1, sibling]];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp1.sibling := tmp -- BinomialHeap.vpr@317.6--317.26
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@317.6--317.26) [100795]"}
                          FullPerm == Mask[temp1, sibling];
                        Heap := Heap[temp1, sibling:=tmp];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, tmp), write) -- BinomialHeap.vpr@318.6--318.28
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@318.6--318.28) [100796]"}
                              perm <= Mask[null, tree(tmp)];
                          }
                          Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], tree(tmp), Heap[null, tree(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@318.6--318.28) [100797]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access heapseg(tmp.sibling, tmp) (BinomialHeap.vpr@318.6--318.28) [100798]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], tmp):=Mask[null, heapseg(Heap[tmp, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], heapseg(Heap[tmp, sibling], tmp), Heap[null, heapseg(Heap[tmp, sibling], tmp)]);
                          if (Heap[tmp, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, tmp) might not hold. (BinomialHeap.vpr@318.6--318.28) [100799]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, tmp):=Mask[null, heapseg(tmp, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, tmp));
                        assume Heap[null, heapseg(tmp, tmp)] == FrameFragment((if tmp != tmp then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], tmp)], FrameFragment((if Heap[tmp, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, tmp))) {
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, tmp):=freshVersion];
                        }
                        if (tmp != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_106: Ref, f_107: (Field A B) ::
                            { newPMask[o_106, f_107] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_106, f_107] || Heap[null, tree#sm(tmp)][o_106, f_107] ==> newPMask[o_106, f_107]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=Heap[null, heapseg#sm(tmp, tmp)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_107: Ref, f_108: (Field A B) ::
                            { newPMask[o_107, f_108] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_107, f_108] || Heap[null, heapseg#sm(Heap[tmp, sibling], tmp)][o_107, f_108] ==> newPMask[o_107, f_108]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(temp1, tmp), write) -- BinomialHeap.vpr@319.6--319.30
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp1 != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@319.6--319.30) [100800]"}
                              perm <= Mask[null, tree(temp1)];
                          }
                          Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], tree(temp1), Heap[null, tree(temp1)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@319.6--319.30) [100801]"}
                              perm <= Mask[temp1, sibling];
                          }
                          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access heapseg(temp1.sibling, tmp) (BinomialHeap.vpr@319.6--319.30) [100802]"}
                              perm <= Mask[null, heapseg(Heap[temp1, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp1, sibling], tmp):=Mask[null, heapseg(Heap[temp1, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], heapseg(Heap[temp1, sibling], tmp), Heap[null, heapseg(Heap[temp1, sibling], tmp)]);
                          if (Heap[temp1, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, tmp) might not hold. (BinomialHeap.vpr@319.6--319.30) [100803]"}
                              treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp1, tmp));
                        assume Heap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], tmp)], FrameFragment((if Heap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp1, tmp))) {
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp1, tmp):=freshVersion];
                        }
                        if (temp1 != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_108: Ref, f_109: (Field A B) ::
                            { newPMask[o_108, f_109] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_108, f_109] || Heap[null, tree#sm(temp1)][o_108, f_109] ==> newPMask[o_108, f_109]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_109: Ref, f_110: (Field A B) ::
                            { newPMask[o_109, f_110] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_109, f_110] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_109, f_110] ==> newPMask[o_109, f_110]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: concat(this.Nodes, temp1, tmp) -- BinomialHeap.vpr@320.6--320.36
                        PreCallHeap := Heap;
                        PreCallMask := Mask;
                        
                        // -- Check definedness of this.Nodes
                          assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@320.6--320.36) [100804]"}
                            HasDirectPerm(Mask, this, Nodes);
                        arg_a_1 := Heap[this, Nodes];
                        
                        // -- Exhaling precondition
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@320.6--320.36) [100805]"}
                              perm <= Mask[null, heapseg(arg_a_1, temp1)];
                          }
                          Mask := Mask[null, heapseg(arg_a_1, temp1):=Mask[null, heapseg(arg_a_1, temp1)] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@320.6--320.36) [100806]"}
                              perm <= Mask[null, heapseg(temp1, tmp)];
                          }
                          Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] - perm];
                          if (tmp != null) {
                            perm := FullPerm;
                            if (perm != NoPerm) {
                              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@320.6--320.36) [100807]"}
                                perm <= Mask[null, tree(tmp)];
                            }
                            Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                          }
                          if (arg_a_1 != temp1 && temp1 != tmp) {
                            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, tmp) might not hold. (BinomialHeap.vpr@320.6--320.36) [100808]"}
                              segParent(Heap, arg_a_1, temp1) == segParent(Heap, temp1, tmp);
                          }
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                        
                        // -- Inhaling postcondition
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(arg_a_1, tmp):=Mask[null, heapseg(arg_a_1, tmp)] + perm];
                          assume state(Heap, Mask);
                          assume state(Heap, Mask);
                          assume segLength(Heap, arg_a_1, tmp) == segLength(PreCallHeap, arg_a_1, temp1) + segLength(PreCallHeap, temp1, tmp);
                          assume state(Heap, Mask);
                          assume (forall i_2_1: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_1, tmp)], arg_a_1, tmp, i_2_1) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_1, temp1)], arg_a_1, temp1, i_2_1) }
                            0 <= i_2_1 && i_2_1 < segLength(PreCallHeap, arg_a_1, temp1) ==> segDegree(Heap, arg_a_1, tmp, i_2_1) == segDegree(PreCallHeap, arg_a_1, temp1, i_2_1)
                          );
                          assume state(Heap, Mask);
                          assume (forall i_3: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_1, tmp)], arg_a_1, tmp, i_3) }
                            segLength(PreCallHeap, arg_a_1, temp1) <= i_3 && i_3 < segLength(Heap, arg_a_1, tmp) ==> segDegree(Heap, arg_a_1, tmp, i_3) == segDegree(PreCallHeap, temp1, tmp, i_3 - segLength(PreCallHeap, arg_a_1, temp1))
                          );
                          if (tmp != null) {
                            perm := FullPerm;
                            Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] + perm];
                            assume state(Heap, Mask);
                            assume state(Heap, Mask);
                            assume treeDegree(Heap, tmp) == treeDegree(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeSize(Heap, tmp) == treeSize(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeParent(Heap, tmp) == treeParent(PreCallHeap, tmp);
                          }
                          if (sorted(PreCallHeap, arg_a_1, temp1) && (sorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_1, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))) {
                            assume state(Heap, Mask);
                            assume sorted(Heap, arg_a_1, tmp);
                          }
                          if (presorted(PreCallHeap, arg_a_1, temp1) && (presorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_1, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) <= segDegree(PreCallHeap, temp1, tmp, 0) && ((2 <= segLength(PreCallHeap, arg_a_1, temp1) && segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) == segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 2) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)) && (2 <= segLength(PreCallHeap, temp1, tmp) && segDegree(PreCallHeap, temp1, tmp, 0) == segDegree(PreCallHeap, temp1, tmp, 1) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))))) {
                            assume state(Heap, Mask);
                            assume presorted(Heap, arg_a_1, tmp);
                          }
                          if (validChildren(PreCallHeap, arg_a_1, temp1) && (validChildren(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_1, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_1, temp1, segLength(PreCallHeap, arg_a_1, temp1) - 1) == segDegree(PreCallHeap, temp1, tmp, 0) + 1))) {
                            assume state(Heap, Mask);
                            assume validChildren(Heap, arg_a_1, tmp);
                          }
                          assume state(Heap, Mask);
                          assume segSize(Heap, arg_a_1, tmp) == segSize(PreCallHeap, arg_a_1, temp1) + segSize(PreCallHeap, temp1, tmp);
                          if (arg_a_1 != temp1) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_1, tmp) == segParent(PreCallHeap, arg_a_1, temp1);
                          }
                          if (temp1 != tmp) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_1, tmp) == segParent(PreCallHeap, temp1, tmp);
                          }
                          assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp1 := tmp -- BinomialHeap.vpr@322.6--322.18
                        temp1 := tmp;
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@326.6--326.29
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != null) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@326.6--326.29) [100809]"}
                              perm <= Mask[null, tree(tmp)];
                          }
                          Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree(tmp), Heap[null, tree(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@326.6--326.29) [100810]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@326.6--326.29) [100811]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                          if (Heap[tmp, sibling] != null) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@326.6--326.29) [100812]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, null));
                        assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                          Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                        }
                        if (tmp != null) {
                          havoc newPMask;
                          assume (forall <A, B> o_110: Ref, f_111: (Field A B) ::
                            { newPMask[o_110, f_111] }
                            Heap[null, heapseg#sm(tmp, null)][o_110, f_111] || Heap[null, tree#sm(tmp)][o_110, f_111] ==> newPMask[o_110, f_111]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_111: Ref, f_112: (Field A B) ::
                            { newPMask[o_111, f_112] }
                            Heap[null, heapseg#sm(tmp, null)][o_111, f_112] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_111, f_112] ==> newPMask[o_111, f_112]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: tmp := temp1.sibling -- BinomialHeap.vpr@328.6--328.26
                        
                        // -- Check definedness of temp1.sibling
                          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@328.6--328.26) [100813]"}
                            HasDirectPerm(Mask, temp1, sibling);
                        tmp := Heap[temp1, sibling];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(temp2, null), write) -- BinomialHeap.vpr@329.6--329.31
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp2 != null) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. There might be insufficient permission to access tree(temp2) (BinomialHeap.vpr@329.6--329.31) [100814]"}
                              perm <= Mask[null, tree(temp2)];
                          }
                          Mask := Mask[null, tree(temp2):=Mask[null, tree(temp2)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], tree(temp2), Heap[null, tree(temp2)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@329.6--329.31) [100815]"}
                              perm <= Mask[temp2, sibling];
                          }
                          Mask := Mask[temp2, sibling:=Mask[temp2, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. There might be insufficient permission to access heapseg(temp2.sibling, null) (BinomialHeap.vpr@329.6--329.31) [100816]"}
                              perm <= Mask[null, heapseg(Heap[temp2, sibling], null)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp2, sibling], null):=Mask[null, heapseg(Heap[temp2, sibling], null)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp2, null), Heap[null, heapseg(temp2, null)], heapseg(Heap[temp2, sibling], null), Heap[null, heapseg(Heap[temp2, sibling], null)]);
                          if (Heap[temp2, sibling] != null) {
                            assert {:msg "  Folding heapseg(temp2, null) might fail. Assertion treeParent(temp2) == segParent(temp2.sibling, null) might not hold. (BinomialHeap.vpr@329.6--329.31) [100817]"}
                              treeParent(Heap, temp2) == segParent(Heap, Heap[temp2, sibling], null);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp2, null));
                        assume Heap[null, heapseg(temp2, null)] == FrameFragment((if temp2 != null then CombineFrames(Heap[null, tree(temp2)], CombineFrames(FrameFragment(Heap[temp2, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp2, sibling], null)], FrameFragment((if Heap[temp2, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp2, null))) {
                          Heap := Heap[null, heapseg#sm(temp2, null):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp2, null):=freshVersion];
                        }
                        if (temp2 != null) {
                          havoc newPMask;
                          assume (forall <A, B> o_112: Ref, f_113: (Field A B) ::
                            { newPMask[o_112, f_113] }
                            Heap[null, heapseg#sm(temp2, null)][o_112, f_113] || Heap[null, tree#sm(temp2)][o_112, f_113] ==> newPMask[o_112, f_113]
                          );
                          Heap := Heap[null, heapseg#sm(temp2, null):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp2, null):=Heap[null, heapseg#sm(temp2, null)][temp2, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_113: Ref, f_114: (Field A B) ::
                            { newPMask[o_113, f_114] }
                            Heap[null, heapseg#sm(temp2, null)][o_113, f_114] || Heap[null, heapseg#sm(Heap[temp2, sibling], null)][o_113, f_114] ==> newPMask[o_113, f_114]
                          );
                          Heap := Heap[null, heapseg#sm(temp2, null):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, tmp), write) -- BinomialHeap.vpr@330.6--330.28
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@330.6--330.28) [100818]"}
                              perm <= Mask[null, tree(tmp)];
                          }
                          Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], tree(tmp), Heap[null, tree(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@330.6--330.28) [100819]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. There might be insufficient permission to access heapseg(tmp.sibling, tmp) (BinomialHeap.vpr@330.6--330.28) [100820]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], tmp):=Mask[null, heapseg(Heap[tmp, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, tmp), Heap[null, heapseg(tmp, tmp)], heapseg(Heap[tmp, sibling], tmp), Heap[null, heapseg(Heap[tmp, sibling], tmp)]);
                          if (Heap[tmp, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(tmp, tmp) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, tmp) might not hold. (BinomialHeap.vpr@330.6--330.28) [100821]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, tmp):=Mask[null, heapseg(tmp, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, tmp));
                        assume Heap[null, heapseg(tmp, tmp)] == FrameFragment((if tmp != tmp then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], tmp)], FrameFragment((if Heap[tmp, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, tmp))) {
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, tmp):=freshVersion];
                        }
                        if (tmp != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_114: Ref, f_115: (Field A B) ::
                            { newPMask[o_114, f_115] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_114, f_115] || Heap[null, tree#sm(tmp)][o_114, f_115] ==> newPMask[o_114, f_115]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=Heap[null, heapseg#sm(tmp, tmp)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_115: Ref, f_116: (Field A B) ::
                            { newPMask[o_115, f_116] }
                            Heap[null, heapseg#sm(tmp, tmp)][o_115, f_116] || Heap[null, heapseg#sm(Heap[tmp, sibling], tmp)][o_115, f_116] ==> newPMask[o_115, f_116]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(temp1, tmp), write) -- BinomialHeap.vpr@331.6--331.30
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp1 != tmp) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@331.6--331.30) [100822]"}
                              perm <= Mask[null, tree(temp1)];
                          }
                          Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], tree(temp1), Heap[null, tree(temp1)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@331.6--331.30) [100823]"}
                              perm <= Mask[temp1, sibling];
                          }
                          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. There might be insufficient permission to access heapseg(temp1.sibling, tmp) (BinomialHeap.vpr@331.6--331.30) [100824]"}
                              perm <= Mask[null, heapseg(Heap[temp1, sibling], tmp)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp1, sibling], tmp):=Mask[null, heapseg(Heap[temp1, sibling], tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp1, tmp), Heap[null, heapseg(temp1, tmp)], heapseg(Heap[temp1, sibling], tmp), Heap[null, heapseg(Heap[temp1, sibling], tmp)]);
                          if (Heap[temp1, sibling] != tmp) {
                            assert {:msg "  Folding heapseg(temp1, tmp) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, tmp) might not hold. (BinomialHeap.vpr@331.6--331.30) [100825]"}
                              treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], tmp);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp1, tmp));
                        assume Heap[null, heapseg(temp1, tmp)] == FrameFragment((if temp1 != tmp then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], tmp)], FrameFragment((if Heap[temp1, sibling] != tmp then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp1, tmp))) {
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp1, tmp):=freshVersion];
                        }
                        if (temp1 != tmp) {
                          havoc newPMask;
                          assume (forall <A, B> o_116: Ref, f_117: (Field A B) ::
                            { newPMask[o_116, f_117] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_116, f_117] || Heap[null, tree#sm(temp1)][o_116, f_117] ==> newPMask[o_116, f_117]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=Heap[null, heapseg#sm(temp1, tmp)][temp1, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_117: Ref, f_118: (Field A B) ::
                            { newPMask[o_117, f_118] }
                            Heap[null, heapseg#sm(temp1, tmp)][o_117, f_118] || Heap[null, heapseg#sm(Heap[temp1, sibling], tmp)][o_117, f_118] ==> newPMask[o_117, f_118]
                          );
                          Heap := Heap[null, heapseg#sm(temp1, tmp):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: unfold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@332.6--332.31
                        assume heapseg#trigger(Heap, heapseg(tmp, null));
                        assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        perm := FullPerm;
                        if (perm != NoPerm) {
                          assert {:msg "  Unfolding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp, null) (BinomialHeap.vpr@332.6--332.31) [100826]"}
                            perm <= Mask[null, heapseg(tmp, null)];
                        }
                        Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] - perm];
                        
                        // -- Update version of predicate
                          if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                            havoc newVersion;
                            Heap := Heap[null, heapseg(tmp, null):=newVersion];
                          }
                        if (tmp != null) {
                          perm := FullPerm;
                          Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] + perm];
                          
                          // -- Extra unfolding of predicate
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree(tmp), Heap[null, tree(tmp)]);
                          assume state(Heap, Mask);
                          perm := FullPerm;
                          assume tmp != null;
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] + perm];
                          assume state(Heap, Mask);
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] + perm];
                          
                          // -- Extra unfolding of predicate
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                          assume state(Heap, Mask);
                          if (Heap[tmp, sibling] != null) {
                            assume state(Heap, Mask);
                            assume treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                          }
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: concat(this.Nodes, temp1, tmp) -- BinomialHeap.vpr@333.6--333.36
                        PreCallHeap := Heap;
                        PreCallMask := Mask;
                        
                        // -- Check definedness of this.Nodes
                          assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@333.6--333.36) [100827]"}
                            HasDirectPerm(Mask, this, Nodes);
                        arg_a_2 := Heap[this, Nodes];
                        
                        // -- Exhaling precondition
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@333.6--333.36) [100828]"}
                              perm <= Mask[null, heapseg(arg_a_2, temp1)];
                          }
                          Mask := Mask[null, heapseg(arg_a_2, temp1):=Mask[null, heapseg(arg_a_2, temp1)] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, tmp) (BinomialHeap.vpr@333.6--333.36) [100829]"}
                              perm <= Mask[null, heapseg(temp1, tmp)];
                          }
                          Mask := Mask[null, heapseg(temp1, tmp):=Mask[null, heapseg(temp1, tmp)] - perm];
                          if (tmp != null) {
                            perm := FullPerm;
                            if (perm != NoPerm) {
                              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@333.6--333.36) [100830]"}
                                perm <= Mask[null, tree(tmp)];
                            }
                            Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                          }
                          if (arg_a_2 != temp1 && temp1 != tmp) {
                            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, tmp) might not hold. (BinomialHeap.vpr@333.6--333.36) [100831]"}
                              segParent(Heap, arg_a_2, temp1) == segParent(Heap, temp1, tmp);
                          }
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                        
                        // -- Inhaling postcondition
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(arg_a_2, tmp):=Mask[null, heapseg(arg_a_2, tmp)] + perm];
                          assume state(Heap, Mask);
                          assume state(Heap, Mask);
                          assume segLength(Heap, arg_a_2, tmp) == segLength(PreCallHeap, arg_a_2, temp1) + segLength(PreCallHeap, temp1, tmp);
                          assume state(Heap, Mask);
                          assume (forall i_4_1: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_2, tmp)], arg_a_2, tmp, i_4_1) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_2, temp1)], arg_a_2, temp1, i_4_1) }
                            0 <= i_4_1 && i_4_1 < segLength(PreCallHeap, arg_a_2, temp1) ==> segDegree(Heap, arg_a_2, tmp, i_4_1) == segDegree(PreCallHeap, arg_a_2, temp1, i_4_1)
                          );
                          assume state(Heap, Mask);
                          assume (forall i_5: int ::
                            { segDegree#frame(Heap[null, heapseg(arg_a_2, tmp)], arg_a_2, tmp, i_5) }
                            segLength(PreCallHeap, arg_a_2, temp1) <= i_5 && i_5 < segLength(Heap, arg_a_2, tmp) ==> segDegree(Heap, arg_a_2, tmp, i_5) == segDegree(PreCallHeap, temp1, tmp, i_5 - segLength(PreCallHeap, arg_a_2, temp1))
                          );
                          if (tmp != null) {
                            perm := FullPerm;
                            Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] + perm];
                            assume state(Heap, Mask);
                            assume state(Heap, Mask);
                            assume treeDegree(Heap, tmp) == treeDegree(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeSize(Heap, tmp) == treeSize(PreCallHeap, tmp);
                            assume state(Heap, Mask);
                            assume treeParent(Heap, tmp) == treeParent(PreCallHeap, tmp);
                          }
                          if (sorted(PreCallHeap, arg_a_2, temp1) && (sorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_2, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))) {
                            assume state(Heap, Mask);
                            assume sorted(Heap, arg_a_2, tmp);
                          }
                          if (presorted(PreCallHeap, arg_a_2, temp1) && (presorted(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_2, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) <= segDegree(PreCallHeap, temp1, tmp, 0) && ((2 <= segLength(PreCallHeap, arg_a_2, temp1) && segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) == segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 2) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)) && (2 <= segLength(PreCallHeap, temp1, tmp) && segDegree(PreCallHeap, temp1, tmp, 0) == segDegree(PreCallHeap, temp1, tmp, 1) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) < segDegree(PreCallHeap, temp1, tmp, 0)))))) {
                            assume state(Heap, Mask);
                            assume presorted(Heap, arg_a_2, tmp);
                          }
                          if (validChildren(PreCallHeap, arg_a_2, temp1) && (validChildren(PreCallHeap, temp1, tmp) && (0 < segLength(PreCallHeap, arg_a_2, temp1) && 0 < segLength(PreCallHeap, temp1, tmp) ==> segDegree(PreCallHeap, arg_a_2, temp1, segLength(PreCallHeap, arg_a_2, temp1) - 1) == segDegree(PreCallHeap, temp1, tmp, 0) + 1))) {
                            assume state(Heap, Mask);
                            assume validChildren(Heap, arg_a_2, tmp);
                          }
                          assume state(Heap, Mask);
                          assume segSize(Heap, arg_a_2, tmp) == segSize(PreCallHeap, arg_a_2, temp1) + segSize(PreCallHeap, temp1, tmp);
                          if (arg_a_2 != temp1) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_2, tmp) == segParent(PreCallHeap, arg_a_2, temp1);
                          }
                          if (temp1 != tmp) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, arg_a_2, tmp) == segParent(PreCallHeap, temp1, tmp);
                          }
                          assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@334.6--334.29
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (tmp != null) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@334.6--334.29) [100832]"}
                              perm <= Mask[null, tree(tmp)];
                          }
                          Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree(tmp), Heap[null, tree(tmp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@334.6--334.29) [100833]"}
                              perm <= Mask[tmp, sibling];
                          }
                          Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@334.6--334.29) [100834]"}
                              perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                          }
                          Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                          if (Heap[tmp, sibling] != null) {
                            assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@334.6--334.29) [100835]"}
                              treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(tmp, null));
                        assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                          Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                        }
                        if (tmp != null) {
                          havoc newPMask;
                          assume (forall <A, B> o_118: Ref, f_119: (Field A B) ::
                            { newPMask[o_118, f_119] }
                            Heap[null, heapseg#sm(tmp, null)][o_118, f_119] || Heap[null, tree#sm(tmp)][o_118, f_119] ==> newPMask[o_118, f_119]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                          Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_119: Ref, f_120: (Field A B) ::
                            { newPMask[o_119, f_120] }
                            Heap[null, heapseg#sm(tmp, null)][o_119, f_120] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_119, f_120] ==> newPMask[o_119, f_120]
                          );
                          Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: temp1 := tmp -- BinomialHeap.vpr@335.6--335.18
                        temp1 := tmp;
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: tmp := temp1 -- BinomialHeap.vpr@338.5--338.17
                    tmp := temp1;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp1 := temp2 -- BinomialHeap.vpr@339.5--339.19
                    temp1 := temp2;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp2 := temp2.sibling -- BinomialHeap.vpr@340.5--340.27
                    
                    // -- Check definedness of temp2.sibling
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp2.sibling (BinomialHeap.vpr@340.5--340.27) [100836]"}
                        HasDirectPerm(Mask, temp2, sibling);
                    temp2 := Heap[temp2, sibling];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp1.sibling := tmp -- BinomialHeap.vpr@341.5--341.25
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@341.5--341.25) [100837]"}
                      FullPerm == Mask[temp1, sibling];
                    Heap := Heap[temp1, sibling:=tmp];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(tmp, null), write) -- BinomialHeap.vpr@342.5--342.28
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (tmp != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tree(tmp) (BinomialHeap.vpr@342.5--342.28) [100838]"}
                          perm <= Mask[null, tree(tmp)];
                      }
                      Mask := Mask[null, tree(tmp):=Mask[null, tree(tmp)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], tree(tmp), Heap[null, tree(tmp)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access tmp.sibling (BinomialHeap.vpr@342.5--342.28) [100839]"}
                          perm <= Mask[tmp, sibling];
                      }
                      Mask := Mask[tmp, sibling:=Mask[tmp, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. There might be insufficient permission to access heapseg(tmp.sibling, null) (BinomialHeap.vpr@342.5--342.28) [100840]"}
                          perm <= Mask[null, heapseg(Heap[tmp, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[tmp, sibling], null):=Mask[null, heapseg(Heap[tmp, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(tmp, null), Heap[null, heapseg(tmp, null)], heapseg(Heap[tmp, sibling], null), Heap[null, heapseg(Heap[tmp, sibling], null)]);
                      if (Heap[tmp, sibling] != null) {
                        assert {:msg "  Folding heapseg(tmp, null) might fail. Assertion treeParent(tmp) == segParent(tmp.sibling, null) might not hold. (BinomialHeap.vpr@342.5--342.28) [100841]"}
                          treeParent(Heap, tmp) == segParent(Heap, Heap[tmp, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(tmp, null):=Mask[null, heapseg(tmp, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(tmp, null));
                    assume Heap[null, heapseg(tmp, null)] == FrameFragment((if tmp != null then CombineFrames(Heap[null, tree(tmp)], CombineFrames(FrameFragment(Heap[tmp, sibling]), CombineFrames(Heap[null, heapseg(Heap[tmp, sibling], null)], FrameFragment((if Heap[tmp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(tmp, null))) {
                      Heap := Heap[null, heapseg#sm(tmp, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(tmp, null):=freshVersion];
                    }
                    if (tmp != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_120: Ref, f_121: (Field A B) ::
                        { newPMask[o_120, f_121] }
                        Heap[null, heapseg#sm(tmp, null)][o_120, f_121] || Heap[null, tree#sm(tmp)][o_120, f_121] ==> newPMask[o_120, f_121]
                      );
                      Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(tmp, null):=Heap[null, heapseg#sm(tmp, null)][tmp, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_121: Ref, f_122: (Field A B) ::
                        { newPMask[o_121, f_122] }
                        Heap[null, heapseg#sm(tmp, null)][o_121, f_122] || Heap[null, heapseg#sm(Heap[tmp, sibling], null)][o_121, f_122] ==> newPMask[o_121, f_122]
                      );
                      Heap := Heap[null, heapseg#sm(tmp, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@343.5--343.30
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (temp1 != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@343.5--343.30) [100842]"}
                          perm <= Mask[null, tree(temp1)];
                      }
                      Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree(temp1), Heap[null, tree(temp1)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@343.5--343.30) [100843]"}
                          perm <= Mask[temp1, sibling];
                      }
                      Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@343.5--343.30) [100844]"}
                          perm <= Mask[null, heapseg(Heap[temp1, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                      if (Heap[temp1, sibling] != null) {
                        assert {:msg "  Folding heapseg(temp1, null) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, null) might not hold. (BinomialHeap.vpr@343.5--343.30) [100845]"}
                          treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(temp1, null));
                    assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                      Heap := Heap[null, heapseg#sm(temp1, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(temp1, null):=freshVersion];
                    }
                    if (temp1 != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_122: Ref, f_123: (Field A B) ::
                        { newPMask[o_122, f_123] }
                        Heap[null, heapseg#sm(temp1, null)][o_122, f_123] || Heap[null, tree#sm(temp1)][o_122, f_123] ==> newPMask[o_122, f_123]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_123: Ref, f_124: (Field A B) ::
                        { newPMask[o_123, f_124] }
                        Heap[null, heapseg#sm(temp1, null)][o_123, f_124] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_123, f_124] ==> newPMask[o_123, f_124]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: if (tmp == this.Nodes) -- BinomialHeap.vpr@344.5--349.6
                    
                    // -- Check definedness of tmp == this.Nodes
                      assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@344.8--344.25) [100846]"}
                        HasDirectPerm(Mask, this, Nodes);
                    if (tmp == Heap[this, Nodes]) {
                      
                      // -- Translating statement: this.Nodes := temp1 -- BinomialHeap.vpr@345.6--345.25
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@345.6--345.25) [100847]"}
                          FullPerm == Mask[this, Nodes];
                        Heap := Heap[this, Nodes:=temp1];
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(this.Nodes, temp1), write) -- BinomialHeap.vpr@346.6--346.37
                        
                        // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
                          assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@346.6--346.37) [100848]"}
                            HasDirectPerm(Mask, this, Nodes);
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (Heap[this, Nodes] != temp1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@346.6--346.37) [100849]"}
                              perm <= Mask[null, tree(Heap[this, Nodes])];
                          }
                          Mask := Mask[null, tree(Heap[this, Nodes]):=Mask[null, tree(Heap[this, Nodes])] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(Heap[this, Nodes], temp1), Heap[null, heapseg(Heap[this, Nodes], temp1)], tree(Heap[this, Nodes]), Heap[null, tree(Heap[this, Nodes])]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@346.6--346.37) [100850]"}
                              perm <= Mask[Heap[this, Nodes], sibling];
                          }
                          Mask := Mask[Heap[this, Nodes], sibling:=Mask[Heap[this, Nodes], sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp1) (BinomialHeap.vpr@346.6--346.37) [100851]"}
                              perm <= Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)];
                          }
                          Mask := Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1):=Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(Heap[this, Nodes], temp1), Heap[null, heapseg(Heap[this, Nodes], temp1)], heapseg(Heap[Heap[this, Nodes], sibling], temp1), Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)]);
                          if (Heap[Heap[this, Nodes], sibling] != temp1) {
                            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp1) might not hold. (BinomialHeap.vpr@346.6--346.37) [100852]"}
                              treeParent(Heap, Heap[this, Nodes]) == segParent(Heap, Heap[Heap[this, Nodes], sibling], temp1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes], temp1));
                        assume Heap[null, heapseg(Heap[this, Nodes], temp1)] == FrameFragment((if Heap[this, Nodes] != temp1 then CombineFrames(Heap[null, tree(Heap[this, Nodes])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)], FrameFragment((if Heap[Heap[this, Nodes], sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes], temp1))) {
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(Heap[this, Nodes], temp1):=freshVersion];
                        }
                        if (Heap[this, Nodes] != temp1) {
                          havoc newPMask;
                          assume (forall <A, B> o_124: Ref, f_125: (Field A B) ::
                            { newPMask[o_124, f_125] }
                            Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][o_124, f_125] || Heap[null, tree#sm(Heap[this, Nodes])][o_124, f_125] ==> newPMask[o_124, f_125]
                          );
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=newPMask];
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][Heap[this, Nodes], sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_125: Ref, f_126: (Field A B) ::
                            { newPMask[o_125, f_126] }
                            Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][o_125, f_126] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes], sibling], temp1)][o_125, f_126] ==> newPMask[o_125, f_126]
                          );
                          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: assert false -- BinomialHeap.vpr@348.6--348.18
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        assert {:msg "  Assert might fail. Assertion false might not hold. (BinomialHeap.vpr@348.13--348.18) [100853]"}
                          false;
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        // Exhale invariant
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not be preserved. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@263.13--263.56) [100854]"}
            perm <= Mask[null, heapseg(temp1, null)];
        }
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && sorted(temp1, null) might not be preserved. Assertion sorted(temp1, null) might not hold. (BinomialHeap.vpr@263.13--263.56) [100855]"}
          sorted(Heap, temp1, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@264.13--264.56) [100856]"}
            perm <= Mask[null, heapseg(temp2, null)];
        }
        Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@264.13--264.56) [100857]"}
          sorted(Heap, temp2, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@265.13--265.50) [100858]"}
            perm <= Mask[this, Nodes];
        }
        Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
        assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@265.13--265.50) [100859]"}
          Heap[this, Nodes] != null;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@266.13--266.71) [100860]"}
            perm <= Mask[null, heapseg(Heap[this, Nodes], temp1)];
        }
        Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@266.13--266.71) [100861]"}
          presorted(Heap, Heap[this, Nodes], temp1);
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp1, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [100862]"}
            segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp1, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@267.13--271.93) [100863]"}
              segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp2, null)) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [100864]"}
            segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
          if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
            assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && 0 < segLength(temp2, null) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@272.13--276.93) [100865]"}
              segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
          }
        }
        if (0 < segLength(Heap, Heap[this, Nodes], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) || segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@277.13--279.93) [100866]"}
            segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
        if (temp1 != Heap[this, Nodes] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
          assert {:msg "  Loop invariant temp1 != this.Nodes && (0 < segLength(temp1, null) && 0 < segLength(temp2, null)) ==> segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not be preserved. Assertion segDegree(temp1, null, 0) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@280.13--281.56) [100867]"}
            segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
        }
        assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@282.13--282.149) [100868]"}
          segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        if (temp1 != null && temp2 != null) {
          assert {:msg "  Loop invariant temp1 != null && temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not be preserved. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@283.13--283.96) [100869]"}
            segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes] != temp1 && temp1 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp1 != null ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@284.13--284.108) [100870]"}
            segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
        }
        if (Heap[this, Nodes] != temp1 && temp2 != null) {
          assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@285.13--285.108) [100871]"}
            segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
        }
        if (Heap[this, Nodes] != temp1) {
          assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(this.Nodes, temp1) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@286.13--286.101) [100872]"}
            segParent(Heap, Heap[this, Nodes], temp1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        if (temp1 != null) {
          assert {:msg "  Loop invariant temp1 != null ==> segParent(temp1, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@287.13--287.89) [100873]"}
            segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        if (temp2 != null) {
          assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@288.13--288.89) [100874]"}
            segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
        }
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Terminate execution
        assume false;
      }
    
    // -- Inhale loop invariant after loop, and assume guard
      assume !(temp1 != null && temp2 != null);
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted(Heap, temp1, null);
      perm := FullPerm;
      Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume sorted(Heap, temp2, null);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
      assume state(Heap, Mask);
      assume Heap[this, Nodes] != null;
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume presorted(Heap, Heap[this, Nodes], temp1);
      if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp1, null)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
        if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
        }
      }
      if (0 < segLength(Heap, Heap[this, Nodes], temp1) && 0 < segLength(Heap, temp2, null)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp2, null, 0);
        if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
        }
      }
      if (0 < segLength(Heap, Heap[this, Nodes], temp1) && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0) || segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp2, null, 0);
      }
      if (temp1 != Heap[this, Nodes] && (0 < segLength(Heap, temp1, null) && 0 < segLength(Heap, temp2, null))) {
        assume state(Heap, Mask);
        assume segDegree(Heap, temp1, null, 0) <= segDegree(Heap, temp2, null, 0);
      }
      assume state(Heap, Mask);
      assume segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
      if (temp1 != null && temp2 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
      }
      if (Heap[this, Nodes] != temp1 && temp1 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
      }
      if (Heap[this, Nodes] != temp1 && temp2 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
      }
      if (Heap[this, Nodes] != temp1) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(oldHeap, oldHeap[this, Nodes], null);
      }
      if (temp1 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
      }
      if (temp2 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: if (temp1 == null) -- BinomialHeap.vpr@353.2--406.3
    if (temp1 == null) {
      
      // -- Translating statement: temp1 := this.Nodes -- BinomialHeap.vpr@354.3--354.22
        
        // -- Check definedness of this.Nodes
          assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@354.3--354.22) [100875]"}
            HasDirectPerm(Mask, this, Nodes);
        temp1 := Heap[this, Nodes];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(this.Nodes, temp1), write) -- BinomialHeap.vpr@355.3--355.34
        
        // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
          assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@355.3--355.34) [100876]"}
            HasDirectPerm(Mask, this, Nodes);
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (Heap[this, Nodes] != temp1) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@355.3--355.34) [100879]"}
              perm <= Mask[null, tree(Heap[this, Nodes])];
          }
          Mask := Mask[null, tree(Heap[this, Nodes]):=Mask[null, tree(Heap[this, Nodes])] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(Heap[this, Nodes], temp1), Heap[null, heapseg(Heap[this, Nodes], temp1)], tree(Heap[this, Nodes]), Heap[null, tree(Heap[this, Nodes])]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@355.3--355.34) [100881]"}
              perm <= Mask[Heap[this, Nodes], sibling];
          }
          Mask := Mask[Heap[this, Nodes], sibling:=Mask[Heap[this, Nodes], sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp1) (BinomialHeap.vpr@355.3--355.34) [100883]"}
              perm <= Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)];
          }
          Mask := Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1):=Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(Heap[this, Nodes], temp1), Heap[null, heapseg(Heap[this, Nodes], temp1)], heapseg(Heap[Heap[this, Nodes], sibling], temp1), Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)]);
          if (Heap[Heap[this, Nodes], sibling] != temp1) {
            assert {:msg "  Folding heapseg(this.Nodes, temp1) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp1) might not hold. (BinomialHeap.vpr@355.3--355.34) [100884]"}
              treeParent(Heap, Heap[this, Nodes]) == segParent(Heap, Heap[Heap[this, Nodes], sibling], temp1);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes], temp1));
        assume Heap[null, heapseg(Heap[this, Nodes], temp1)] == FrameFragment((if Heap[this, Nodes] != temp1 then CombineFrames(Heap[null, tree(Heap[this, Nodes])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp1)], FrameFragment((if Heap[Heap[this, Nodes], sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes], temp1))) {
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(Heap[this, Nodes], temp1):=freshVersion];
        }
        if (Heap[this, Nodes] != temp1) {
          havoc newPMask;
          assume (forall <A, B> o_126: Ref, f_127: (Field A B) ::
            { newPMask[o_126, f_127] }
            Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][o_126, f_127] || Heap[null, tree#sm(Heap[this, Nodes])][o_126, f_127] ==> newPMask[o_126, f_127]
          );
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=newPMask];
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][Heap[this, Nodes], sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_127: Ref, f_128: (Field A B) ::
            { newPMask[o_127, f_128] }
            Heap[null, heapseg#sm(Heap[this, Nodes], temp1)][o_127, f_128] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes], sibling], temp1)][o_127, f_128] ==> newPMask[o_127, f_128]
          );
          Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp1):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: while ((unfolding acc(heapseg(temp1, null), write) in temp1.sibling != null)) -- BinomialHeap.vpr@357.3--397.4
        
        // -- Before loop head
          
          // -- Exhale loop invariant before loop
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            assert {:msg "  Loop invariant temp1 != null might not hold on entry. Assertion temp1 != null might not hold. (BinomialHeap.vpr@358.14--358.27) [100886]"}
              temp1 != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not hold on entry. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@359.14--359.60) [100887]"}
                perm <= Mask[null, heapseg(temp1, null)];
            }
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not hold on entry. Assertion presorted(temp1, null) might not hold. (BinomialHeap.vpr@359.14--359.60) [100888]"}
              presorted(Heap, temp1, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@360.14--360.57) [100889]"}
                perm <= Mask[null, heapseg(temp2, null)];
            }
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not hold on entry. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@360.14--360.57) [100890]"}
              sorted(Heap, temp2, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@361.14--361.51) [100891]"}
                perm <= Mask[this, Nodes];
            }
            Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
            assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not hold on entry. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@361.14--361.51) [100892]"}
              Heap[this, Nodes] != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@362.14--362.72) [100893]"}
                perm <= Mask[null, heapseg(Heap[this, Nodes], temp1)];
            }
            Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not hold on entry. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@362.14--362.72) [100894]"}
              presorted(Heap, Heap[this, Nodes], temp1);
            assert {:msg "  Loop invariant 0 < segLength(temp1, null) might not hold on entry. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@363.14--363.40) [100895]"}
              0 < segLength(Heap, temp1, null);
            if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
              assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [100896]"}
                segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [100897]"}
                  segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not hold on entry. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [100898]"}
                  segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            if (0 < segLength(Heap, temp2, null)) {
              assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [100899]"}
                segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not hold on entry. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [100900]"}
                  segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@380.14--380.150) [100901]"}
              segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not hold on entry. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@381.14--381.80) [100902]"}
                segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            if (Heap[this, Nodes] != temp1) {
              assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@382.14--382.92) [100903]"}
                segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
            }
            if (Heap[this, Nodes] != temp1 && temp2 != null) {
              assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold on entry. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@383.14--383.109) [100904]"}
                segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
            }
            assert {:msg "  Loop invariant segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@384.14--384.72) [100905]"}
              segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@385.14--385.90) [100906]"}
                segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            }
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
        
        // -- Havoc loop written variables (except locals)
          havoc temp1;
          assume Heap[temp1, $allocated];
        
        // -- Check definedness of invariant
          if (*) {
            assume temp1 != null;
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of presorted(temp1, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@359.38--359.60) [100907]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume presorted(Heap, temp1, null);
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of sorted(temp2, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@360.38--360.57) [100908]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume sorted(Heap, temp2, null);
            assume state(Heap, Mask);
            perm := FullPerm;
            assume this != null;
            Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
            assume state(Heap, Mask);
            
            // -- Check definedness of this.Nodes != null
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@361.14--361.51) [100909]"}
                HasDirectPerm(Mask, this, Nodes);
            assume Heap[this, Nodes] != null;
            assume state(Heap, Mask);
            
            // -- Check definedness of acc(heapseg(this.Nodes, temp1), write)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@362.14--362.72) [100910]"}
                HasDirectPerm(Mask, this, Nodes);
            perm := FullPerm;
            Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of presorted(this.Nodes, temp1)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@362.14--362.72) [100911]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@362.44--362.72) [100912]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume presorted(Heap, Heap[this, Nodes], temp1);
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(temp1, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@363.18--363.40) [100913]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume 0 < segLength(Heap, temp1, null);
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(this.Nodes, temp1)
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100914]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@364.18--364.46) [100915]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100916]"}
                  HasDirectPerm(Mask, this, Nodes);
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100917]"}
                  HasDirectPerm(Mask, this, Nodes);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@365.32--365.60) [100918]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@365.3--365.65) [100919]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@365.3--365.65) [100920]"}
                    0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@365.3--365.65) [100921]"}
                    segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@365.69--365.94) [100922]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@365.69--365.94) [100923]"}
                    0 < segLength(Heap, temp1, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              
              // -- Check definedness of 2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100924]"}
                  HasDirectPerm(Mask, this, Nodes);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@367.9--367.37) [100925]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(Heap, Heap[this, Nodes], temp1)) {
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100926]"}
                    HasDirectPerm(Mask, this, Nodes);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100927]"}
                    HasDirectPerm(Mask, this, Nodes);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.32--368.60) [100928]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.3--368.65) [100929]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@368.3--368.65) [100930]"}
                      0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@368.3--368.65) [100931]"}
                      segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100932]"}
                    HasDirectPerm(Mask, this, Nodes);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100933]"}
                    HasDirectPerm(Mask, this, Nodes);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.98--368.126) [100934]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@368.69--368.131) [100935]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 2 might not hold. (BinomialHeap.vpr@368.69--368.131) [100936]"}
                      0 <= segLength(Heap, Heap[this, Nodes], temp1) - 2;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 2 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@368.69--368.131) [100937]"}
                      segLength(Heap, Heap[this, Nodes], temp1) - 2 < segLength(Heap, Heap[this, Nodes], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
                assume state(Heap, Mask);
                
                // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100938]"}
                    HasDirectPerm(Mask, this, Nodes);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100939]"}
                    HasDirectPerm(Mask, this, Nodes);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@369.32--369.60) [100940]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@369.3--369.65) [100941]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@369.3--369.65) [100942]"}
                      0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@369.3--369.65) [100943]"}
                      segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@369.68--369.93) [100944]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@369.68--369.93) [100945]"}
                      0 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              
              // -- Check definedness of 2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1)
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@371.9--371.31) [100946]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(Heap, temp1, null)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@372.3--372.28) [100947]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@372.3--372.28) [100948]"}
                      0 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@372.32--372.57) [100949]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@372.32--372.57) [100950]"}
                      1 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assume state(Heap, Mask);
                
                // -- Check definedness of segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100951]"}
                    HasDirectPerm(Mask, this, Nodes);
                  assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@364.14--373.94) [100952]"}
                    HasDirectPerm(Mask, this, Nodes);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@373.32--373.60) [100953]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@373.3--373.65) [100954]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@373.3--373.65) [100955]"}
                      0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@373.3--373.65) [100956]"}
                      segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@373.68--373.93) [100957]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@373.68--373.93) [100958]"}
                      0 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(temp2, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@374.18--374.40) [100959]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            if (0 < segLength(Heap, temp2, null)) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0)
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@375.26--375.48) [100960]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@375.3--375.53) [100961]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 1 might not hold. (BinomialHeap.vpr@375.3--375.53) [100962]"}
                    0 <= segLength(Heap, temp1, null) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@375.3--375.53) [100963]"}
                    segLength(Heap, temp1, null) - 1 < segLength(Heap, temp1, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@375.57--375.82) [100964]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@375.57--375.82) [100965]"}
                    0 < segLength(Heap, temp2, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              
              // -- Check definedness of 2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@374.14--379.82) [100966]"}
                  HasDirectPerm(Mask, this, Nodes);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@377.9--377.37) [100967]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@377.40--377.62) [100968]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (2 <= segLength(Heap, Heap[this, Nodes], temp1) + segLength(Heap, temp1, null)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.9--378.31) [100969]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (2 <= segLength(Heap, temp1, null)) {
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.57--378.79) [100970]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.34--378.84) [100971]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 2 might not hold. (BinomialHeap.vpr@378.34--378.84) [100972]"}
                        0 <= segLength(Heap, temp1, null) - 2;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 2 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@378.34--378.84) [100973]"}
                        segLength(Heap, temp1, null) - 2 < segLength(Heap, temp1, null);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  } else {
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@374.14--379.82) [100974]"}
                      HasDirectPerm(Mask, this, Nodes);
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@374.14--379.82) [100975]"}
                      HasDirectPerm(Mask, this, Nodes);
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@378.115--378.143) [100976]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@378.86--378.148) [100977]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, temp1) - 1 might not hold. (BinomialHeap.vpr@378.86--378.148) [100978]"}
                        0 <= segLength(Heap, Heap[this, Nodes], temp1) - 1;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, temp1) - 1 < segLength(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@378.86--378.148) [100979]"}
                        segLength(Heap, Heap[this, Nodes], temp1) - 1 < segLength(Heap, Heap[this, Nodes], temp1);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.176--378.198) [100980]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@378.153--378.203) [100981]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 1 might not hold. (BinomialHeap.vpr@378.153--378.203) [100982]"}
                      0 <= segLength(Heap, temp1, null) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@378.153--378.203) [100983]"}
                      segLength(Heap, temp1, null) - 1 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assume state(Heap, Mask);
                
                // -- Check definedness of segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@379.26--379.48) [100984]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@379.3--379.53) [100985]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp1, null) - 1 might not hold. (BinomialHeap.vpr@379.3--379.53) [100986]"}
                      0 <= segLength(Heap, temp1, null) - 1;
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp1, null) - 1 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@379.3--379.53) [100987]"}
                      segLength(Heap, temp1, null) - 1 < segLength(Heap, temp1, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@379.56--379.81) [100988]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@379.56--379.81) [100989]"}
                      0 < segLength(Heap, temp2, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@380.14--380.150) [100990]"}
                HasDirectPerm(Mask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@380.14--380.40) [100991]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@380.43--380.63) [100992]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@380.66--380.86) [100993]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@380.14--380.150) [100994]"}
                HasDirectPerm(oldMask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@380.94--380.119) [100995]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
                // Finish exhale
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@380.127--380.149) [100996]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
                // Finish exhale
                // Stop execution
                assume false;
              }
            assume segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
            assume state(Heap, Mask);
            if (temp2 != null) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(temp1, null) == segParent(temp2, null)
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@381.32--381.54) [100997]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@381.32--381.54) [100998]"}
                    temp1 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@381.58--381.80) [100999]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@381.58--381.80) [101000]"}
                    temp2 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            assume state(Heap, Mask);
            
            // -- Check definedness of this.Nodes != temp1
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@382.14--382.92) [101001]"}
                HasDirectPerm(Mask, this, Nodes);
            if (Heap[this, Nodes] != temp1) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp1, null)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@382.14--382.92) [101002]"}
                  HasDirectPerm(Mask, this, Nodes);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@382.38--382.66) [101003]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@382.38--382.66) [101004]"}
                    Heap[this, Nodes] != temp1;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@382.70--382.92) [101005]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@382.70--382.92) [101006]"}
                    temp1 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
            }
            assume state(Heap, Mask);
            
            // -- Check definedness of this.Nodes != temp1 && temp2 != null
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@383.14--383.109) [101007]"}
                HasDirectPerm(Mask, this, Nodes);
            if (Heap[this, Nodes] != temp1 && temp2 != null) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(this.Nodes, temp1) == segParent(temp2, null)
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@383.14--383.109) [101008]"}
                  HasDirectPerm(Mask, this, Nodes);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@383.55--383.83) [101009]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], temp1)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != temp1 might not hold. (BinomialHeap.vpr@383.55--383.83) [101010]"}
                    Heap[this, Nodes] != temp1;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@383.87--383.109) [101011]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@383.87--383.109) [101012]"}
                    temp2 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of segParent(temp1, null) == old(segParent(this.Nodes, null))
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@384.14--384.36) [101013]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp1, null)];
                assert {:msg "  Precondition of function segParent might not hold. Assertion temp1 != null might not hold. (BinomialHeap.vpr@384.14--384.36) [101014]"}
                  temp1 != null;
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@384.14--384.72) [101015]"}
                HasDirectPerm(oldMask, this, Nodes);
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := oldHeap;
                ExhaleWellDef0Mask := oldMask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@384.44--384.71) [101016]"}
                  NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
                assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@384.44--384.71) [101017]"}
                  oldHeap[this, Nodes] != null;
                // Finish exhale
                // Stop execution
                assume false;
              }
            assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            assume state(Heap, Mask);
            if (temp2 != null) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(temp2, null) == old(segParent(this.Nodes, null))
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@385.32--385.54) [101018]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp2, null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion temp2 != null might not hold. (BinomialHeap.vpr@385.32--385.54) [101019]"}
                    temp2 != null;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@385.14--385.90) [101020]"}
                  HasDirectPerm(oldMask, this, Nodes);
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := oldHeap;
                  ExhaleWellDef0Mask := oldMask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@385.62--385.89) [101021]"}
                    NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@385.62--385.89) [101022]"}
                    oldHeap[this, Nodes] != null;
                  // Finish exhale
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            }
            assume state(Heap, Mask);
            assume false;
          }
        
        // -- Check the loop body
          if (*) {
            // Reset state
            loopHeap := Heap;
            loopMask := Mask;
            Mask := ZeroMask;
            assume state(Heap, Mask);
            // Inhale invariant
            assume temp1 != null;
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume presorted(Heap, temp1, null);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume sorted(Heap, temp2, null);
            perm := FullPerm;
            assume this != null;
            Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
            assume state(Heap, Mask);
            assume Heap[this, Nodes] != null;
            perm := FullPerm;
            Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume presorted(Heap, Heap[this, Nodes], temp1);
            assume state(Heap, Mask);
            assume 0 < segLength(Heap, temp1, null);
            if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
                assume state(Heap, Mask);
                assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assume state(Heap, Mask);
                assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            if (0 < segLength(Heap, temp2, null)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assume state(Heap, Mask);
                assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assume state(Heap, Mask);
            assume segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
            if (temp2 != null) {
              assume state(Heap, Mask);
              assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            if (Heap[this, Nodes] != temp1) {
              assume state(Heap, Mask);
              assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
            }
            if (Heap[this, Nodes] != temp1 && temp2 != null) {
              assume state(Heap, Mask);
              assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
            }
            assume state(Heap, Mask);
            assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            if (temp2 != null) {
              assume state(Heap, Mask);
              assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            }
            assume state(Heap, Mask);
            // Check and assume guard
            
            // -- Check definedness of (unfolding acc(heapseg(temp1, null), write) in temp1.sibling != null)
              UnfoldingHeap := Heap;
              UnfoldingMask := Mask;
              assume heapseg#trigger(UnfoldingHeap, heapseg(temp1, null));
              assume UnfoldingHeap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(UnfoldingHeap[null, tree(temp1)], CombineFrames(FrameFragment(UnfoldingHeap[temp1, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)], FrameFragment((if UnfoldingHeap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
              ExhaleWellDef0Heap := UnfoldingHeap;
              ExhaleWellDef0Mask := UnfoldingMask;
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  While statement might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@357.9--357.64) [101023]"}
                  perm <= UnfoldingMask[null, heapseg(temp1, null)];
              }
              UnfoldingMask := UnfoldingMask[null, heapseg(temp1, null):=UnfoldingMask[null, heapseg(temp1, null)] - perm];
              if (temp1 != null) {
                perm := FullPerm;
                UnfoldingMask := UnfoldingMask[null, tree(temp1):=UnfoldingMask[null, tree(temp1)] + perm];
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], tree(temp1), UnfoldingHeap[null, tree(temp1)]);
                assume state(UnfoldingHeap, UnfoldingMask);
                perm := FullPerm;
                assume temp1 != null;
                UnfoldingMask := UnfoldingMask[temp1, sibling:=UnfoldingMask[temp1, sibling] + perm];
                assume state(UnfoldingHeap, UnfoldingMask);
                perm := FullPerm;
                UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null)] + perm];
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], heapseg(UnfoldingHeap[temp1, sibling], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)]);
                assume state(UnfoldingHeap, UnfoldingMask);
                if (UnfoldingHeap[temp1, sibling] != null) {
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume treeParent(UnfoldingHeap, temp1) == segParent(UnfoldingHeap, UnfoldingHeap[temp1, sibling], null);
                }
              }
              assume state(UnfoldingHeap, UnfoldingMask);
              assert {:msg "  While statement might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@357.9--357.64) [101024]"}
                HasDirectPerm(UnfoldingMask, temp1, sibling);
              
              // -- Free assumptions (exp module)
                if (temp1 != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_128: Ref, f_129: (Field A B) ::
                    { newPMask[o_128, f_129] }
                    Heap[null, heapseg#sm(temp1, null)][o_128, f_129] || Heap[null, tree#sm(temp1)][o_128, f_129] ==> newPMask[o_128, f_129]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_129: Ref, f_130: (Field A B) ::
                    { newPMask[o_129, f_130] }
                    Heap[null, heapseg#sm(temp1, null)][o_129, f_130] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_129, f_130] ==> newPMask[o_129, f_130]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                }
                assume state(Heap, Mask);
            assume Heap[temp1, sibling] != null;
            assume state(Heap, Mask);
            
            // -- Translate loop body
              
              // -- Assumptions about local variables
                assume Heap[t_2, $allocated];
              
              // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@387.4--387.31
                assume heapseg#trigger(Heap, heapseg(temp1, null));
                assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@387.4--387.31) [101025]"}
                    perm <= Mask[null, heapseg(temp1, null)];
                }
                Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp1, null):=newVersion];
                  }
                if (temp1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree(temp1), Heap[null, tree(temp1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: t := temp1 -- BinomialHeap.vpr@388.4--388.23
                t_2 := temp1;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp1 := temp1.sibling -- BinomialHeap.vpr@389.4--389.26
                
                // -- Check definedness of temp1.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@389.4--389.26) [101026]"}
                    HasDirectPerm(Mask, temp1, sibling);
                temp1 := Heap[temp1, sibling];
                assume state(Heap, Mask);
              
              // -- Translating statement: assert (unfolding acc(heapseg(temp1, null), write) in
  //     (unfolding acc(tree(t), write) in
  //       (unfolding acc(tree(temp1), write) in t != temp1))) -- BinomialHeap.vpr@390.4--390.101
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                
                // -- Check definedness of (unfolding acc(heapseg(temp1, null), write) in (unfolding acc(tree(t), write) in (unfolding acc(tree(temp1), write) in t != temp1)))
                  UnfoldingHeap := ExhaleWellDef0Heap;
                  UnfoldingMask := ExhaleWellDef0Mask;
                  assume heapseg#trigger(UnfoldingHeap, heapseg(temp1, null));
                  assume UnfoldingHeap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(UnfoldingHeap[null, tree(temp1)], CombineFrames(FrameFragment(UnfoldingHeap[temp1, sibling]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)], FrameFragment((if UnfoldingHeap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                  ExhaleWellDef1Heap := UnfoldingHeap;
                  ExhaleWellDef1Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@390.11--390.101) [101027]"}
                      perm <= UnfoldingMask[null, heapseg(temp1, null)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heapseg(temp1, null):=UnfoldingMask[null, heapseg(temp1, null)] - perm];
                  if (temp1 != null) {
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, tree(temp1):=UnfoldingMask[null, tree(temp1)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], tree(temp1), UnfoldingHeap[null, tree(temp1)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    assume temp1 != null;
                    UnfoldingMask := UnfoldingMask[temp1, sibling:=UnfoldingMask[temp1, sibling] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[temp1, sibling], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heapseg(temp1, null), UnfoldingHeap[null, heapseg(temp1, null)], heapseg(UnfoldingHeap[temp1, sibling], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[temp1, sibling], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    if (UnfoldingHeap[temp1, sibling] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume treeParent(UnfoldingHeap, temp1) == segParent(UnfoldingHeap, UnfoldingHeap[temp1, sibling], null);
                    }
                  }
                  assume state(UnfoldingHeap, UnfoldingMask);
                  Unfolding1Heap := UnfoldingHeap;
                  Unfolding1Mask := UnfoldingMask;
                  assume tree#trigger(Unfolding1Heap, tree(t_2));
                  assume Unfolding1Heap[null, tree(t_2)] == CombineFrames(FrameFragment(Unfolding1Heap[t_2, key]), CombineFrames(FrameFragment(Unfolding1Heap[t_2, degree]), CombineFrames(FrameFragment(Unfolding1Heap[t_2, child]), CombineFrames(FrameFragment(Unfolding1Heap[t_2, parent]), CombineFrames(Unfolding1Heap[null, heapseg(Unfolding1Heap[t_2, child], null)], CombineFrames(FrameFragment((if 0 < Unfolding1Heap[t_2, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Unfolding1Heap[t_2, child] != null then EmptyFrame else EmptyFrame))))))));
                  ExhaleWellDef1Heap := Unfolding1Heap;
                  ExhaleWellDef1Mask := Unfolding1Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access tree(t) (BinomialHeap.vpr@390.11--390.101) [101028]"}
                      perm <= Unfolding1Mask[null, tree(t_2)];
                  }
                  Unfolding1Mask := Unfolding1Mask[null, tree(t_2):=Unfolding1Mask[null, tree(t_2)] - perm];
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, key:=Unfolding1Mask[t_2, key] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, degree:=Unfolding1Mask[t_2, degree] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, child:=Unfolding1Mask[t_2, child] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  perm := FullPerm;
                  assume t_2 != null;
                  Unfolding1Mask := Unfolding1Mask[t_2, parent:=Unfolding1Mask[t_2, parent] + perm];
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume 0 <= Unfolding1Heap[t_2, degree];
                  perm := FullPerm;
                  Unfolding1Mask := Unfolding1Mask[null, heapseg(Unfolding1Heap[t_2, child], null):=Unfolding1Mask[null, heapseg(Unfolding1Heap[t_2, child], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(tree(t_2), Unfolding1Heap[null, tree(t_2)], heapseg(Unfolding1Heap[t_2, child], null), Unfolding1Heap[null, heapseg(Unfolding1Heap[t_2, child], null)]);
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume Unfolding1Heap[t_2, degree] == segLength(Unfolding1Heap, Unfolding1Heap[t_2, child], null);
                  if (0 < Unfolding1Heap[t_2, degree]) {
                    assume state(Unfolding1Heap, Unfolding1Mask);
                    assume segDegree(Unfolding1Heap, Unfolding1Heap[t_2, child], null, 0) == Unfolding1Heap[t_2, degree] - 1;
                  }
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  assume validChildren(Unfolding1Heap, Unfolding1Heap[t_2, child], null);
                  if (Unfolding1Heap[t_2, child] != null) {
                    assume state(Unfolding1Heap, Unfolding1Mask);
                    assume segParent(Unfolding1Heap, Unfolding1Heap[t_2, child], null) == t_2;
                  }
                  assume state(Unfolding1Heap, Unfolding1Mask);
                  Unfolding2Heap := Unfolding1Heap;
                  Unfolding2Mask := Unfolding1Mask;
                  assume tree#trigger(Unfolding2Heap, tree(temp1));
                  assume Unfolding2Heap[null, tree(temp1)] == CombineFrames(FrameFragment(Unfolding2Heap[temp1, key]), CombineFrames(FrameFragment(Unfolding2Heap[temp1, degree]), CombineFrames(FrameFragment(Unfolding2Heap[temp1, child]), CombineFrames(FrameFragment(Unfolding2Heap[temp1, parent]), CombineFrames(Unfolding2Heap[null, heapseg(Unfolding2Heap[temp1, child], null)], CombineFrames(FrameFragment((if 0 < Unfolding2Heap[temp1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Unfolding2Heap[temp1, child] != null then EmptyFrame else EmptyFrame))))))));
                  ExhaleWellDef1Heap := Unfolding2Heap;
                  ExhaleWellDef1Mask := Unfolding2Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Assert might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@390.11--390.101) [101029]"}
                      perm <= Unfolding2Mask[null, tree(temp1)];
                  }
                  Unfolding2Mask := Unfolding2Mask[null, tree(temp1):=Unfolding2Mask[null, tree(temp1)] - perm];
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, key:=Unfolding2Mask[temp1, key] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, degree:=Unfolding2Mask[temp1, degree] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, child:=Unfolding2Mask[temp1, child] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Unfolding2Mask := Unfolding2Mask[temp1, parent:=Unfolding2Mask[temp1, parent] + perm];
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume 0 <= Unfolding2Heap[temp1, degree];
                  perm := FullPerm;
                  Unfolding2Mask := Unfolding2Mask[null, heapseg(Unfolding2Heap[temp1, child], null):=Unfolding2Mask[null, heapseg(Unfolding2Heap[temp1, child], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(tree(temp1), Unfolding2Heap[null, tree(temp1)], heapseg(Unfolding2Heap[temp1, child], null), Unfolding2Heap[null, heapseg(Unfolding2Heap[temp1, child], null)]);
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume Unfolding2Heap[temp1, degree] == segLength(Unfolding2Heap, Unfolding2Heap[temp1, child], null);
                  if (0 < Unfolding2Heap[temp1, degree]) {
                    assume state(Unfolding2Heap, Unfolding2Mask);
                    assume segDegree(Unfolding2Heap, Unfolding2Heap[temp1, child], null, 0) == Unfolding2Heap[temp1, degree] - 1;
                  }
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  assume validChildren(Unfolding2Heap, Unfolding2Heap[temp1, child], null);
                  if (Unfolding2Heap[temp1, child] != null) {
                    assume state(Unfolding2Heap, Unfolding2Mask);
                    assume segParent(Unfolding2Heap, Unfolding2Heap[temp1, child], null) == temp1;
                  }
                  assume state(Unfolding2Heap, Unfolding2Mask);
                  
                  // -- Free assumptions (exp module)
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_130: Ref, f_131: (Field A B) ::
                      { newPMask[o_130, f_131] }
                      Heap[null, tree#sm(temp1)][o_130, f_131] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_130, f_131] ==> newPMask[o_130, f_131]
                    );
                    Heap := Heap[null, tree#sm(temp1):=newPMask];
                    assume state(Heap, Mask);
                  
                  // -- Free assumptions (exp module)
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, key:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, degree:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, child:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_131: Ref, f_132: (Field A B) ::
                      { newPMask[o_131, f_132] }
                      Heap[null, tree#sm(t_2)][o_131, f_132] || Heap[null, heapseg#sm(Heap[t_2, child], null)][o_131, f_132] ==> newPMask[o_131, f_132]
                    );
                    Heap := Heap[null, tree#sm(t_2):=newPMask];
                    assume state(Heap, Mask);
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_132: Ref, f_133: (Field A B) ::
                      { newPMask[o_132, f_133] }
                      Heap[null, tree#sm(temp1)][o_132, f_133] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_132, f_133] ==> newPMask[o_132, f_133]
                    );
                    Heap := Heap[null, tree#sm(temp1):=newPMask];
                    assume state(Heap, Mask);
                  
                  // -- Free assumptions (exp module)
                    if (temp1 != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_133: Ref, f_134: (Field A B) ::
                        { newPMask[o_133, f_134] }
                        Heap[null, heapseg#sm(temp1, null)][o_133, f_134] || Heap[null, tree#sm(temp1)][o_133, f_134] ==> newPMask[o_133, f_134]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_134: Ref, f_135: (Field A B) ::
                        { newPMask[o_134, f_135] }
                        Heap[null, heapseg#sm(temp1, null)][o_134, f_135] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_134, f_135] ==> newPMask[o_134, f_135]
                      );
                      Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, key:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, degree:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, child:=true]];
                    Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_135: Ref, f_136: (Field A B) ::
                      { newPMask[o_135, f_136] }
                      Heap[null, tree#sm(t_2)][o_135, f_136] || Heap[null, heapseg#sm(Heap[t_2, child], null)][o_135, f_136] ==> newPMask[o_135, f_136]
                    );
                    Heap := Heap[null, tree#sm(t_2):=newPMask];
                    assume state(Heap, Mask);
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                    Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_136: Ref, f_137: (Field A B) ::
                      { newPMask[o_136, f_137] }
                      Heap[null, tree#sm(temp1)][o_136, f_137] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_136, f_137] ==> newPMask[o_136, f_137]
                    );
                    Heap := Heap[null, tree#sm(temp1):=newPMask];
                    assume state(Heap, Mask);
                assert {:msg "  Assert might fail. Assertion t != temp1 might not hold. (BinomialHeap.vpr@390.11--390.101) [101030]"}
                  t_2 != temp1;
                
                // -- Free assumptions (exhale module)
                  if (temp1 != null) {
                    havoc newPMask;
                    assume (forall <A, B> o_137: Ref, f_138: (Field A B) ::
                      { newPMask[o_137, f_138] }
                      Heap[null, heapseg#sm(temp1, null)][o_137, f_138] || Heap[null, tree#sm(temp1)][o_137, f_138] ==> newPMask[o_137, f_138]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                    Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_138: Ref, f_139: (Field A B) ::
                      { newPMask[o_138, f_139] }
                      Heap[null, heapseg#sm(temp1, null)][o_138, f_139] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_138, f_139] ==> newPMask[o_138, f_139]
                    );
                    Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                  }
                  assume state(Heap, Mask);
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, key:=true]];
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, degree:=true]];
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, child:=true]];
                  Heap := Heap[null, tree#sm(t_2):=Heap[null, tree#sm(t_2)][t_2, parent:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_139: Ref, f_140: (Field A B) ::
                    { newPMask[o_139, f_140] }
                    Heap[null, tree#sm(t_2)][o_139, f_140] || Heap[null, heapseg#sm(Heap[t_2, child], null)][o_139, f_140] ==> newPMask[o_139, f_140]
                  );
                  Heap := Heap[null, tree#sm(t_2):=newPMask];
                  assume state(Heap, Mask);
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, key:=true]];
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, degree:=true]];
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, child:=true]];
                  Heap := Heap[null, tree#sm(temp1):=Heap[null, tree#sm(temp1)][temp1, parent:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_140: Ref, f_141: (Field A B) ::
                    { newPMask[o_140, f_141] }
                    Heap[null, tree#sm(temp1)][o_140, f_141] || Heap[null, heapseg#sm(Heap[temp1, child], null)][o_140, f_141] ==> newPMask[o_140, f_141]
                  );
                  Heap := Heap[null, tree#sm(temp1):=newPMask];
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp1, temp1), write) -- BinomialHeap.vpr@392.4--392.30
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp1 != temp1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@392.4--392.30) [101031]"}
                      perm <= Mask[null, tree(temp1)];
                  }
                  Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, temp1), Heap[null, heapseg(temp1, temp1)], tree(temp1), Heap[null, tree(temp1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@392.4--392.30) [101032]"}
                      perm <= Mask[temp1, sibling];
                  }
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. There might be insufficient permission to access heapseg(temp1.sibling, temp1) (BinomialHeap.vpr@392.4--392.30) [101033]"}
                      perm <= Mask[null, heapseg(Heap[temp1, sibling], temp1)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], temp1):=Mask[null, heapseg(Heap[temp1, sibling], temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, temp1), Heap[null, heapseg(temp1, temp1)], heapseg(Heap[temp1, sibling], temp1), Heap[null, heapseg(Heap[temp1, sibling], temp1)]);
                  if (Heap[temp1, sibling] != temp1) {
                    assert {:msg "  Folding heapseg(temp1, temp1) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, temp1) might not hold. (BinomialHeap.vpr@392.4--392.30) [101034]"}
                      treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], temp1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp1, temp1):=Mask[null, heapseg(temp1, temp1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp1, temp1));
                assume Heap[null, heapseg(temp1, temp1)] == FrameFragment((if temp1 != temp1 then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], temp1)], FrameFragment((if Heap[temp1, sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp1, temp1))) {
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp1, temp1):=freshVersion];
                }
                if (temp1 != temp1) {
                  havoc newPMask;
                  assume (forall <A, B> o_141: Ref, f_142: (Field A B) ::
                    { newPMask[o_141, f_142] }
                    Heap[null, heapseg#sm(temp1, temp1)][o_141, f_142] || Heap[null, tree#sm(temp1)][o_141, f_142] ==> newPMask[o_141, f_142]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=Heap[null, heapseg#sm(temp1, temp1)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_142: Ref, f_143: (Field A B) ::
                    { newPMask[o_142, f_143] }
                    Heap[null, heapseg#sm(temp1, temp1)][o_142, f_143] || Heap[null, heapseg#sm(Heap[temp1, sibling], temp1)][o_142, f_143] ==> newPMask[o_142, f_143]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, temp1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(t, temp1), write) -- BinomialHeap.vpr@393.4--393.26
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (t_2 != temp1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. There might be insufficient permission to access tree(t) (BinomialHeap.vpr@393.4--393.26) [101035]"}
                      perm <= Mask[null, tree(t_2)];
                  }
                  Mask := Mask[null, tree(t_2):=Mask[null, tree(t_2)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(t_2, temp1), Heap[null, heapseg(t_2, temp1)], tree(t_2), Heap[null, tree(t_2)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. There might be insufficient permission to access t.sibling (BinomialHeap.vpr@393.4--393.26) [101036]"}
                      perm <= Mask[t_2, sibling];
                  }
                  Mask := Mask[t_2, sibling:=Mask[t_2, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. There might be insufficient permission to access heapseg(t.sibling, temp1) (BinomialHeap.vpr@393.4--393.26) [101037]"}
                      perm <= Mask[null, heapseg(Heap[t_2, sibling], temp1)];
                  }
                  Mask := Mask[null, heapseg(Heap[t_2, sibling], temp1):=Mask[null, heapseg(Heap[t_2, sibling], temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(t_2, temp1), Heap[null, heapseg(t_2, temp1)], heapseg(Heap[t_2, sibling], temp1), Heap[null, heapseg(Heap[t_2, sibling], temp1)]);
                  if (Heap[t_2, sibling] != temp1) {
                    assert {:msg "  Folding heapseg(t, temp1) might fail. Assertion treeParent(t) == segParent(t.sibling, temp1) might not hold. (BinomialHeap.vpr@393.4--393.26) [101038]"}
                      treeParent(Heap, t_2) == segParent(Heap, Heap[t_2, sibling], temp1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(t_2, temp1):=Mask[null, heapseg(t_2, temp1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(t_2, temp1));
                assume Heap[null, heapseg(t_2, temp1)] == FrameFragment((if t_2 != temp1 then CombineFrames(Heap[null, tree(t_2)], CombineFrames(FrameFragment(Heap[t_2, sibling]), CombineFrames(Heap[null, heapseg(Heap[t_2, sibling], temp1)], FrameFragment((if Heap[t_2, sibling] != temp1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(t_2, temp1))) {
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(t_2, temp1):=freshVersion];
                }
                if (t_2 != temp1) {
                  havoc newPMask;
                  assume (forall <A, B> o_143: Ref, f_144: (Field A B) ::
                    { newPMask[o_143, f_144] }
                    Heap[null, heapseg#sm(t_2, temp1)][o_143, f_144] || Heap[null, tree#sm(t_2)][o_143, f_144] ==> newPMask[o_143, f_144]
                  );
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=newPMask];
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=Heap[null, heapseg#sm(t_2, temp1)][t_2, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_144: Ref, f_145: (Field A B) ::
                    { newPMask[o_144, f_145] }
                    Heap[null, heapseg#sm(t_2, temp1)][o_144, f_145] || Heap[null, heapseg#sm(Heap[t_2, sibling], temp1)][o_144, f_145] ==> newPMask[o_144, f_145]
                  );
                  Heap := Heap[null, heapseg#sm(t_2, temp1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@394.4--394.31
                assume heapseg#trigger(Heap, heapseg(temp1, null));
                assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@394.4--394.31) [101039]"}
                    perm <= Mask[null, heapseg(temp1, null)];
                }
                Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp1, null):=newVersion];
                  }
                if (temp1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree(temp1), Heap[null, tree(temp1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp1 != null;
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: concat(this.Nodes, t, temp1) -- BinomialHeap.vpr@395.4--395.32
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Check definedness of this.Nodes
                  assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@395.4--395.32) [101040]"}
                    HasDirectPerm(Mask, this, Nodes);
                arg_a_3 := Heap[this, Nodes];
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, t) (BinomialHeap.vpr@395.4--395.32) [101041]"}
                      perm <= Mask[null, heapseg(arg_a_3, t_2)];
                  }
                  Mask := Mask[null, heapseg(arg_a_3, t_2):=Mask[null, heapseg(arg_a_3, t_2)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(t, temp1) (BinomialHeap.vpr@395.4--395.32) [101042]"}
                      perm <= Mask[null, heapseg(t_2, temp1)];
                  }
                  Mask := Mask[null, heapseg(t_2, temp1):=Mask[null, heapseg(t_2, temp1)] - perm];
                  if (temp1 != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@395.4--395.32) [101043]"}
                        perm <= Mask[null, tree(temp1)];
                    }
                    Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
                  }
                  if (arg_a_3 != t_2 && t_2 != temp1) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, t) == segParent(t, temp1) might not hold. (BinomialHeap.vpr@395.4--395.32) [101044]"}
                      segParent(Heap, arg_a_3, t_2) == segParent(Heap, t_2, temp1);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(arg_a_3, temp1):=Mask[null, heapseg(arg_a_3, temp1)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, arg_a_3, temp1) == segLength(PreCallHeap, arg_a_3, t_2) + segLength(PreCallHeap, t_2, temp1);
                  assume state(Heap, Mask);
                  assume (forall i_6_1: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a_3, temp1)], arg_a_3, temp1, i_6_1) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_3, t_2)], arg_a_3, t_2, i_6_1) }
                    0 <= i_6_1 && i_6_1 < segLength(PreCallHeap, arg_a_3, t_2) ==> segDegree(Heap, arg_a_3, temp1, i_6_1) == segDegree(PreCallHeap, arg_a_3, t_2, i_6_1)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_7_1: int ::
                    { segDegree#frame(Heap[null, heapseg(arg_a_3, temp1)], arg_a_3, temp1, i_7_1) }
                    segLength(PreCallHeap, arg_a_3, t_2) <= i_7_1 && i_7_1 < segLength(Heap, arg_a_3, temp1) ==> segDegree(Heap, arg_a_3, temp1, i_7_1) == segDegree(PreCallHeap, t_2, temp1, i_7_1 - segLength(PreCallHeap, arg_a_3, t_2))
                  );
                  if (temp1 != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, temp1) == treeDegree(PreCallHeap, temp1);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, temp1) == treeSize(PreCallHeap, temp1);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp1) == treeParent(PreCallHeap, temp1);
                  }
                  if (sorted(PreCallHeap, arg_a_3, t_2) && (sorted(PreCallHeap, t_2, temp1) && (0 < segLength(PreCallHeap, arg_a_3, t_2) && 0 < segLength(PreCallHeap, t_2, temp1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) < segDegree(PreCallHeap, t_2, temp1, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted(Heap, arg_a_3, temp1);
                  }
                  if (presorted(PreCallHeap, arg_a_3, t_2) && (presorted(PreCallHeap, t_2, temp1) && (0 < segLength(PreCallHeap, arg_a_3, t_2) && 0 < segLength(PreCallHeap, t_2, temp1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) <= segDegree(PreCallHeap, t_2, temp1, 0) && ((2 <= segLength(PreCallHeap, arg_a_3, t_2) && segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) == segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 2) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) < segDegree(PreCallHeap, t_2, temp1, 0)) && (2 <= segLength(PreCallHeap, t_2, temp1) && segDegree(PreCallHeap, t_2, temp1, 0) == segDegree(PreCallHeap, t_2, temp1, 1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) < segDegree(PreCallHeap, t_2, temp1, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, arg_a_3, temp1);
                  }
                  if (validChildren(PreCallHeap, arg_a_3, t_2) && (validChildren(PreCallHeap, t_2, temp1) && (0 < segLength(PreCallHeap, arg_a_3, t_2) && 0 < segLength(PreCallHeap, t_2, temp1) ==> segDegree(PreCallHeap, arg_a_3, t_2, segLength(PreCallHeap, arg_a_3, t_2) - 1) == segDegree(PreCallHeap, t_2, temp1, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, arg_a_3, temp1);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, arg_a_3, temp1) == segSize(PreCallHeap, arg_a_3, t_2) + segSize(PreCallHeap, t_2, temp1);
                  if (arg_a_3 != t_2) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a_3, temp1) == segParent(PreCallHeap, arg_a_3, t_2);
                  }
                  if (t_2 != temp1) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, arg_a_3, temp1) == segParent(PreCallHeap, t_2, temp1);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@396.4--396.29
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp1 != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@396.4--396.29) [101045]"}
                      perm <= Mask[null, tree(temp1)];
                  }
                  Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree(temp1), Heap[null, tree(temp1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@396.4--396.29) [101046]"}
                      perm <= Mask[temp1, sibling];
                  }
                  Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@396.4--396.29) [101047]"}
                      perm <= Mask[null, heapseg(Heap[temp1, sibling], null)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
                  if (Heap[temp1, sibling] != null) {
                    assert {:msg "  Folding heapseg(temp1, null) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, null) might not hold. (BinomialHeap.vpr@396.4--396.29) [101048]"}
                      treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp1, null));
                assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
                  Heap := Heap[null, heapseg#sm(temp1, null):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp1, null):=freshVersion];
                }
                if (temp1 != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_145: Ref, f_146: (Field A B) ::
                    { newPMask[o_145, f_146] }
                    Heap[null, heapseg#sm(temp1, null)][o_145, f_146] || Heap[null, tree#sm(temp1)][o_145, f_146] ==> newPMask[o_145, f_146]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_146: Ref, f_147: (Field A B) ::
                    { newPMask[o_146, f_147] }
                    Heap[null, heapseg#sm(temp1, null)][o_146, f_147] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_146, f_147] ==> newPMask[o_146, f_147]
                  );
                  Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            // Exhale invariant
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            assert {:msg "  Loop invariant temp1 != null might not be preserved. Assertion temp1 != null might not hold. (BinomialHeap.vpr@358.14--358.27) [101049]"}
              temp1 != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not be preserved. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@359.14--359.60) [101050]"}
                perm <= Mask[null, heapseg(temp1, null)];
            }
            Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp1, null), write) && presorted(temp1, null) might not be preserved. Assertion presorted(temp1, null) might not hold. (BinomialHeap.vpr@359.14--359.60) [101051]"}
              presorted(Heap, temp1, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@360.14--360.57) [101052]"}
                perm <= Mask[null, heapseg(temp2, null)];
            }
            Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(temp2, null), write) && sorted(temp2, null) might not be preserved. Assertion sorted(temp2, null) might not hold. (BinomialHeap.vpr@360.14--360.57) [101053]"}
              sorted(Heap, temp2, null);
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@361.14--361.51) [101054]"}
                perm <= Mask[this, Nodes];
            }
            Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
            assert {:msg "  Loop invariant acc(this.Nodes, write) && this.Nodes != null might not be preserved. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@361.14--361.51) [101055]"}
              Heap[this, Nodes] != null;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@362.14--362.72) [101056]"}
                perm <= Mask[null, heapseg(Heap[this, Nodes], temp1)];
            }
            Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] - perm];
            assert {:msg "  Loop invariant acc(heapseg(this.Nodes, temp1), write) && presorted(this.Nodes, temp1) might not be preserved. Assertion presorted(this.Nodes, temp1) might not hold. (BinomialHeap.vpr@362.14--362.72) [101057]"}
              presorted(Heap, Heap[this, Nodes], temp1);
            assert {:msg "  Loop invariant 0 < segLength(temp1, null) might not be preserved. Assertion 0 < segLength(temp1, null) might not hold. (BinomialHeap.vpr@363.14--363.40) [101058]"}
              0 < segLength(Heap, temp1, null);
            if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
              assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [101059]"}
                segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [101060]"}
                  segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
              if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
                assert {:msg "  Loop invariant 0 < segLength(this.Nodes, temp1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) <= segDegree(temp1, null, 0) && ((2 <= segLength(this.Nodes, temp1) && segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) == segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 2) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0)) && (2 <= segLength(temp1, null) && segDegree(temp1, null, 0) == segDegree(temp1, null, 1) ==> segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0))) might not be preserved. Assertion segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1) < segDegree(temp1, null, 0) might not hold. (BinomialHeap.vpr@364.14--373.94) [101061]"}
                  segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
              }
            }
            if (0 < segLength(Heap, temp2, null)) {
              assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [101062]"}
                segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
              if (2 <= segLength(Heap, Heap[this, Nodes], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
                assert {:msg "  Loop invariant 0 < segLength(temp2, null) ==> segDegree(temp1, null, segLength(temp1, null) - 1) <= segDegree(temp2, null, 0) && (2 <= segLength(this.Nodes, temp1) + segLength(temp1, null) && (2 <= segLength(temp1, null) ? segDegree(temp1, null, segLength(temp1, null) - 2) : segDegree(this.Nodes, temp1, segLength(this.Nodes, temp1) - 1)) == segDegree(temp1, null, segLength(temp1, null) - 1) ==> segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0)) might not be preserved. Assertion segDegree(temp1, null, segLength(temp1, null) - 1) < segDegree(temp2, null, 0) might not hold. (BinomialHeap.vpr@374.14--379.82) [101063]"}
                  segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
              }
            }
            assert {:msg "  Loop invariant segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion segSize(this.Nodes, temp1) + segSize(temp1, null) + segSize(temp2, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@380.14--380.150) [101064]"}
              segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp1, null) == segParent(temp2, null) might not be preserved. Assertion segParent(temp1, null) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@381.14--381.80) [101065]"}
                segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
            }
            if (Heap[this, Nodes] != temp1) {
              assert {:msg "  Loop invariant this.Nodes != temp1 ==> segParent(this.Nodes, temp1) == segParent(temp1, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@382.14--382.92) [101066]"}
                segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
            }
            if (Heap[this, Nodes] != temp1 && temp2 != null) {
              assert {:msg "  Loop invariant this.Nodes != temp1 && temp2 != null ==> segParent(this.Nodes, temp1) == segParent(temp2, null) might not be preserved. Assertion segParent(this.Nodes, temp1) == segParent(temp2, null) might not hold. (BinomialHeap.vpr@383.14--383.109) [101067]"}
                segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
            }
            assert {:msg "  Loop invariant segParent(temp1, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp1, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@384.14--384.72) [101068]"}
              segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            if (temp2 != null) {
              assert {:msg "  Loop invariant temp2 != null ==> segParent(temp2, null) == old(segParent(this.Nodes, null)) might not be preserved. Assertion segParent(temp2, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@385.14--385.90) [101069]"}
                segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
            }
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Terminate execution
            assume false;
          }
        
        // -- Inhale loop invariant after loop, and assume guard
          assume !(Heap[temp1, sibling] != null);
          assume state(Heap, Mask);
          assume temp1 != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume presorted(Heap, temp1, null);
          perm := FullPerm;
          Mask := Mask[null, heapseg(temp2, null):=Mask[null, heapseg(temp2, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted(Heap, temp2, null);
          perm := FullPerm;
          assume this != null;
          Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
          assume state(Heap, Mask);
          assume Heap[this, Nodes] != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[this, Nodes], temp1):=Mask[null, heapseg(Heap[this, Nodes], temp1)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume presorted(Heap, Heap[this, Nodes], temp1);
          assume state(Heap, Mask);
          assume 0 < segLength(Heap, temp1, null);
          if (0 < segLength(Heap, Heap[this, Nodes], temp1)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) <= segDegree(Heap, temp1, null, 0);
            if (2 <= segLength(Heap, Heap[this, Nodes], temp1) && segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) == segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 2)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
            }
            if (2 <= segLength(Heap, temp1, null) && segDegree(Heap, temp1, null, 0) == segDegree(Heap, temp1, null, 1)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1) < segDegree(Heap, temp1, null, 0);
            }
          }
          if (0 < segLength(Heap, temp2, null)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) <= segDegree(Heap, temp2, null, 0);
            if (2 <= segLength(Heap, Heap[this, Nodes], temp1) + segLength(Heap, temp1, null) && (if 2 <= segLength(Heap, temp1, null) then segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 2) else segDegree(Heap, Heap[this, Nodes], temp1, segLength(Heap, Heap[this, Nodes], temp1) - 1)) == segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, temp1, null, segLength(Heap, temp1, null) - 1) < segDegree(Heap, temp2, null, 0);
            }
          }
          assume state(Heap, Mask);
          assume segSize(Heap, Heap[this, Nodes], temp1) + segSize(Heap, temp1, null) + segSize(Heap, temp2, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
          if (temp2 != null) {
            assume state(Heap, Mask);
            assume segParent(Heap, temp1, null) == segParent(Heap, temp2, null);
          }
          if (Heap[this, Nodes] != temp1) {
            assume state(Heap, Mask);
            assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp1, null);
          }
          if (Heap[this, Nodes] != temp1 && temp2 != null) {
            assume state(Heap, Mask);
            assume segParent(Heap, Heap[this, Nodes], temp1) == segParent(Heap, temp2, null);
          }
          assume state(Heap, Mask);
          assume segParent(Heap, temp1, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
          if (temp2 != null) {
            assume state(Heap, Mask);
            assume segParent(Heap, temp2, null) == segParent(oldHeap, oldHeap[this, Nodes], null);
          }
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: unfold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@400.3--400.30
        assume heapseg#trigger(Heap, heapseg(temp1, null));
        assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Unfolding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@400.3--400.30) [101072]"}
            perm <= Mask[null, heapseg(temp1, null)];
        }
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
        
        // -- Update version of predicate
          if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
            havoc newVersion;
            Heap := Heap[null, heapseg(temp1, null):=newVersion];
          }
        if (temp1 != null) {
          perm := FullPerm;
          Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree(temp1), Heap[null, tree(temp1)]);
          assume state(Heap, Mask);
          perm := FullPerm;
          assume temp1 != null;
          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] + perm];
          
          // -- Extra unfolding of predicate
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
          assume state(Heap, Mask);
          if (Heap[temp1, sibling] != null) {
            assume state(Heap, Mask);
            assume treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
          }
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: assert 1 < segLength(temp2, null) ==>
  //   segDegree(temp2, null, 0) < segDegree(temp2, null, 1) -- BinomialHeap.vpr@403.3--403.94
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        
        // -- Check definedness of 1 < segLength(temp2, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef1Heap := ExhaleWellDef0Heap;
            ExhaleWellDef1Mask := ExhaleWellDef0Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@403.14--403.36) [101076]"}
              NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp2, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
            ExhaleWellDef0Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        if (1 < segLength(Heap, temp2, null)) {
          
          // -- Check definedness of segDegree(temp2, null, 0) < segDegree(temp2, null, 1)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef1Heap := ExhaleWellDef0Heap;
              ExhaleWellDef1Mask := ExhaleWellDef0Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@403.41--403.66) [101077]"}
                NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@403.41--403.66) [101078]"}
                0 < segLength(ExhaleWellDef0Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
              ExhaleWellDef0Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef1Heap := ExhaleWellDef0Heap;
              ExhaleWellDef1Mask := ExhaleWellDef0Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp2, null) (BinomialHeap.vpr@403.69--403.94) [101079]"}
                NoPerm < perm ==> NoPerm < ExhaleWellDef0Mask[null, heapseg(temp2, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(temp2, null) might not hold. (BinomialHeap.vpr@403.69--403.94) [101080]"}
                1 < segLength(ExhaleWellDef0Heap, temp2, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(ExhaleWellDef0Heap, ExhaleHeap, ExhaleWellDef0Mask);
              ExhaleWellDef0Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assert {:msg "  Assert might fail. Assertion segDegree(temp2, null, 0) < segDegree(temp2, null, 1) might not hold. (BinomialHeap.vpr@403.10--403.94) [101081]"}
            segDegree(Heap, temp2, null, 0) < segDegree(Heap, temp2, null, 1);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: temp1.sibling := temp2 -- BinomialHeap.vpr@404.3--404.25
        assert {:msg "  Assignment might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@404.3--404.25) [101082]"}
          FullPerm == Mask[temp1, sibling];
        Heap := Heap[temp1, sibling:=temp2];
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(temp1, null), write) -- BinomialHeap.vpr@405.3--405.28
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (temp1 != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access tree(temp1) (BinomialHeap.vpr@405.3--405.28) [101085]"}
              perm <= Mask[null, tree(temp1)];
          }
          Mask := Mask[null, tree(temp1):=Mask[null, tree(temp1)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], tree(temp1), Heap[null, tree(temp1)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access temp1.sibling (BinomialHeap.vpr@405.3--405.28) [101087]"}
              perm <= Mask[temp1, sibling];
          }
          Mask := Mask[temp1, sibling:=Mask[temp1, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. There might be insufficient permission to access heapseg(temp1.sibling, null) (BinomialHeap.vpr@405.3--405.28) [101089]"}
              perm <= Mask[null, heapseg(Heap[temp1, sibling], null)];
          }
          Mask := Mask[null, heapseg(Heap[temp1, sibling], null):=Mask[null, heapseg(Heap[temp1, sibling], null)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(temp1, null), Heap[null, heapseg(temp1, null)], heapseg(Heap[temp1, sibling], null), Heap[null, heapseg(Heap[temp1, sibling], null)]);
          if (Heap[temp1, sibling] != null) {
            assert {:msg "  Folding heapseg(temp1, null) might fail. Assertion treeParent(temp1) == segParent(temp1.sibling, null) might not hold. (BinomialHeap.vpr@405.3--405.28) [101090]"}
              treeParent(Heap, temp1) == segParent(Heap, Heap[temp1, sibling], null);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(temp1, null));
        assume Heap[null, heapseg(temp1, null)] == FrameFragment((if temp1 != null then CombineFrames(Heap[null, tree(temp1)], CombineFrames(FrameFragment(Heap[temp1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp1, sibling], null)], FrameFragment((if Heap[temp1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(temp1, null))) {
          Heap := Heap[null, heapseg#sm(temp1, null):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(temp1, null):=freshVersion];
        }
        if (temp1 != null) {
          havoc newPMask;
          assume (forall <A, B> o_147: Ref, f_148: (Field A B) ::
            { newPMask[o_147, f_148] }
            Heap[null, heapseg#sm(temp1, null)][o_147, f_148] || Heap[null, tree#sm(temp1)][o_147, f_148] ==> newPMask[o_147, f_148]
          );
          Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
          Heap := Heap[null, heapseg#sm(temp1, null):=Heap[null, heapseg#sm(temp1, null)][temp1, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_148: Ref, f_149: (Field A B) ::
            { newPMask[o_148, f_149] }
            Heap[null, heapseg#sm(temp1, null)][o_148, f_149] || Heap[null, heapseg#sm(Heap[temp1, sibling], null)][o_148, f_149] ==> newPMask[o_148, f_149]
          );
          Heap := Heap[null, heapseg#sm(temp1, null):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: concat(this.Nodes, temp1, null) -- BinomialHeap.vpr@408.2--408.33
    PreCallHeap := Heap;
    PreCallMask := Mask;
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@408.2--408.33) [101092]"}
        HasDirectPerm(Mask, this, Nodes);
    arg_a_4 := Heap[this, Nodes];
    
    // -- Exhaling precondition
      ExhaleWellDef0Heap := Heap;
      ExhaleWellDef0Mask := Mask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, temp1) (BinomialHeap.vpr@408.2--408.33) [101093]"}
          perm <= Mask[null, heapseg(arg_a_4, temp1)];
      }
      Mask := Mask[null, heapseg(arg_a_4, temp1):=Mask[null, heapseg(arg_a_4, temp1)] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(temp1, null) (BinomialHeap.vpr@408.2--408.33) [101094]"}
          perm <= Mask[null, heapseg(temp1, null)];
      }
      Mask := Mask[null, heapseg(temp1, null):=Mask[null, heapseg(temp1, null)] - perm];
      if (null != null) {
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@408.2--408.33) [101095]"}
            perm <= Mask[null, tree(null)];
        }
        Mask := Mask[null, tree(null):=Mask[null, tree(null)] - perm];
      }
      if (arg_a_4 != temp1 && temp1 != null) {
        assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, temp1) == segParent(temp1, null) might not hold. (BinomialHeap.vpr@408.2--408.33) [101096]"}
          segParent(Heap, arg_a_4, temp1) == segParent(Heap, temp1, null);
      }
      // Finish exhale
      havoc ExhaleHeap;
      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
      Heap := ExhaleHeap;
    
    // -- Inhaling postcondition
      perm := FullPerm;
      Mask := Mask[null, heapseg(arg_a_4, null):=Mask[null, heapseg(arg_a_4, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume segLength(Heap, arg_a_4, null) == segLength(PreCallHeap, arg_a_4, temp1) + segLength(PreCallHeap, temp1, null);
      assume state(Heap, Mask);
      assume (forall i_8_2: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_4, null)], arg_a_4, null, i_8_2) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_4, temp1)], arg_a_4, temp1, i_8_2) }
        0 <= i_8_2 && i_8_2 < segLength(PreCallHeap, arg_a_4, temp1) ==> segDegree(Heap, arg_a_4, null, i_8_2) == segDegree(PreCallHeap, arg_a_4, temp1, i_8_2)
      );
      assume state(Heap, Mask);
      assume (forall i_9_1: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_4, null)], arg_a_4, null, i_9_1) }
        segLength(PreCallHeap, arg_a_4, temp1) <= i_9_1 && i_9_1 < segLength(Heap, arg_a_4, null) ==> segDegree(Heap, arg_a_4, null, i_9_1) == segDegree(PreCallHeap, temp1, null, i_9_1 - segLength(PreCallHeap, arg_a_4, temp1))
      );
      if (null != null) {
        perm := FullPerm;
        Mask := Mask[null, tree(null):=Mask[null, tree(null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume treeDegree(Heap, null) == treeDegree(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeSize(Heap, null) == treeSize(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeParent(Heap, null) == treeParent(PreCallHeap, null);
      }
      if (sorted(PreCallHeap, arg_a_4, temp1) && (sorted(PreCallHeap, temp1, null) && (0 < segLength(PreCallHeap, arg_a_4, temp1) && 0 < segLength(PreCallHeap, temp1, null) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) < segDegree(PreCallHeap, temp1, null, 0)))) {
        assume state(Heap, Mask);
        assume sorted(Heap, arg_a_4, null);
      }
      if (presorted(PreCallHeap, arg_a_4, temp1) && (presorted(PreCallHeap, temp1, null) && (0 < segLength(PreCallHeap, arg_a_4, temp1) && 0 < segLength(PreCallHeap, temp1, null) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) <= segDegree(PreCallHeap, temp1, null, 0) && ((2 <= segLength(PreCallHeap, arg_a_4, temp1) && segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) == segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 2) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) < segDegree(PreCallHeap, temp1, null, 0)) && (2 <= segLength(PreCallHeap, temp1, null) && segDegree(PreCallHeap, temp1, null, 0) == segDegree(PreCallHeap, temp1, null, 1) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) < segDegree(PreCallHeap, temp1, null, 0)))))) {
        assume state(Heap, Mask);
        assume presorted(Heap, arg_a_4, null);
      }
      if (validChildren(PreCallHeap, arg_a_4, temp1) && (validChildren(PreCallHeap, temp1, null) && (0 < segLength(PreCallHeap, arg_a_4, temp1) && 0 < segLength(PreCallHeap, temp1, null) ==> segDegree(PreCallHeap, arg_a_4, temp1, segLength(PreCallHeap, arg_a_4, temp1) - 1) == segDegree(PreCallHeap, temp1, null, 0) + 1))) {
        assume state(Heap, Mask);
        assume validChildren(Heap, arg_a_4, null);
      }
      assume state(Heap, Mask);
      assume segSize(Heap, arg_a_4, null) == segSize(PreCallHeap, arg_a_4, temp1) + segSize(PreCallHeap, temp1, null);
      if (arg_a_4 != temp1) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_4, null) == segParent(PreCallHeap, arg_a_4, temp1);
      }
      if (temp1 != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_4, null) == segParent(PreCallHeap, temp1, null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of merge might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@252.10--252.107) [101097]"}
        perm <= Mask[this, Nodes];
    }
    Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
    assert {:msg "  Postcondition of merge might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@252.10--252.107) [101098]"}
      Heap[this, Nodes] != null;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of merge might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@252.10--252.107) [101099]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] - perm];
    assert {:msg "  Postcondition of merge might not hold. Assertion presorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@252.10--252.107) [101100]"}
      presorted(Heap, Heap[this, Nodes], null);
    assert {:msg "  Postcondition of merge might not hold. Assertion segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@253.10--253.99) [101101]"}
      segSize(Heap, Heap[this, Nodes], null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
    assert {:msg "  Postcondition of merge might not hold. Assertion segParent(this.Nodes, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@254.10--254.73) [101102]"}
      segParent(Heap, Heap[this, Nodes], null) == segParent(oldHeap, oldHeap[this, Nodes], null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method unionNodes
// ==================================================

procedure unionNodes(this: Ref, binHeap: Ref) returns ()
  modifies Heap, Mask;
{
  var perm: Perm;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var ExhaleHeap: HeapType;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var prevTemp: Ref;
  var temp_1: Ref;
  var nextTemp: Ref;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var newVersion: FrameType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var arg_a: Ref;
  var arg_a_1: Ref;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
    assume Heap[binHeap, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
    assume state(Heap, Mask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@419.11--420.54) [101103]"}
        HasDirectPerm(Mask, this, Nodes);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@419.11--420.54) [101104]"}
        HasDirectPerm(Mask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@420.30--420.54) [101105]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(Heap, Heap[this, Nodes], null);
    assume state(Heap, Mask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@421.11--421.29) [101106]"}
        HasDirectPerm(Mask, this, Nodes);
    assume Heap[this, Nodes] != null;
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(binHeap, null):=Mask[null, heapseg(binHeap, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    
    // -- Check definedness of sorted(binHeap, null)
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@422.37--422.58) [101107]"}
          NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(Heap, binHeap, null);
    assume state(Heap, Mask);
    if (binHeap != null) {
      assume state(Heap, Mask);
      
      // -- Check definedness of segParent(this.Nodes, null) == segParent(binHeap, null)
        assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@423.11--423.86) [101108]"}
          HasDirectPerm(Mask, this, Nodes);
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@423.31--423.58) [101109]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@423.31--423.58) [101110]"}
            Heap[this, Nodes] != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
        if (*) {
          // Exhale precondition of function application
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          perm := FullPerm;
          assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@423.62--423.86) [101111]"}
            NoPerm < perm ==> NoPerm < Mask[null, heapseg(binHeap, null)];
          assert {:msg "  Precondition of function segParent might not hold. Assertion binHeap != null might not hold. (BinomialHeap.vpr@423.62--423.86) [101112]"}
            binHeap != null;
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
          // Stop execution
          assume false;
        }
      assume segParent(Heap, Heap[this, Nodes], null) == segParent(Heap, binHeap, null);
    }
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    assume this != null;
    PostMask := PostMask[this, Nodes:=PostMask[this, Nodes] + perm];
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@424.10--425.54) [101113]"}
        HasDirectPerm(PostMask, this, Nodes);
    perm := FullPerm;
    PostMask := PostMask[null, heapseg(PostHeap[this, Nodes], null):=PostMask[null, heapseg(PostHeap[this, Nodes], null)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of sorted(this.Nodes, null)
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@424.10--425.54) [101114]"}
        HasDirectPerm(PostMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@425.30--425.54) [101115]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
    assume sorted(PostHeap, PostHeap[this, Nodes], null);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of this.Nodes != null
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@426.10--426.28) [101116]"}
        HasDirectPerm(PostMask, this, Nodes);
    assume PostHeap[this, Nodes] != null;
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@427.10--427.99) [101117]"}
        HasDirectPerm(PostMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@427.10--427.35) [101118]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes], null)];
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@427.10--427.99) [101119]"}
        HasDirectPerm(oldMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@427.43--427.68) [101120]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@427.76--427.98) [101121]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segSize(PostHeap, PostHeap[this, Nodes], null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    
    // -- Check definedness of segParent(this.Nodes, null) == old(segParent(this.Nodes, null))
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@428.10--428.73) [101122]"}
        HasDirectPerm(PostMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := PostHeap;
        ExhaleWellDef0Mask := PostMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@428.10--428.37) [101123]"}
          NoPerm < perm ==> NoPerm < PostMask[null, heapseg(PostHeap[this, Nodes], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@428.10--428.37) [101124]"}
          PostHeap[this, Nodes] != null;
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(PostHeap, ExhaleHeap, PostMask);
        PostHeap := ExhaleHeap;
        // Stop execution
        assume false;
      }
      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@428.10--428.73) [101125]"}
        HasDirectPerm(oldMask, this, Nodes);
      if (*) {
        // Exhale precondition of function application
        ExhaleWellDef0Heap := oldHeap;
        ExhaleWellDef0Mask := oldMask;
        perm := FullPerm;
        assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@428.45--428.72) [101126]"}
          NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
        assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@428.45--428.72) [101127]"}
          oldHeap[this, Nodes] != null;
        // Finish exhale
        // Stop execution
        assume false;
      }
    assume segParent(PostHeap, PostHeap[this, Nodes], null) == segParent(oldHeap, oldHeap[this, Nodes], null);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[prevTemp, $allocated];
    assume Heap[temp_1, $allocated];
    assume Heap[nextTemp, $allocated];
  
  // -- Translating statement: merge(this, binHeap) -- BinomialHeap.vpr@430.2--430.22
    PreCallHeap := Heap;
    PreCallMask := Mask;
    
    // -- Exhaling precondition
      ExhaleWellDef0Heap := Heap;
      ExhaleWellDef0Mask := Mask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method merge might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@430.2--430.22) [101128]"}
          perm <= Mask[this, Nodes];
      }
      Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method merge might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@430.2--430.22) [101129]"}
          perm <= Mask[null, heapseg(Heap[this, Nodes], null)];
      }
      Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] - perm];
      assert {:msg "  The precondition of method merge might not hold. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@430.2--430.22) [101130]"}
        sorted(Heap, Heap[this, Nodes], null);
      assert {:msg "  The precondition of method merge might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@430.2--430.22) [101131]"}
        Heap[this, Nodes] != null;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method merge might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@430.2--430.22) [101132]"}
          perm <= Mask[null, heapseg(binHeap, null)];
      }
      Mask := Mask[null, heapseg(binHeap, null):=Mask[null, heapseg(binHeap, null)] - perm];
      assert {:msg "  The precondition of method merge might not hold. Assertion sorted(binHeap, null) might not hold. (BinomialHeap.vpr@430.2--430.22) [101133]"}
        sorted(Heap, binHeap, null);
      if (binHeap != null) {
        assert {:msg "  The precondition of method merge might not hold. Assertion segParent(this.Nodes, null) == segParent(binHeap, null) might not hold. (BinomialHeap.vpr@430.2--430.22) [101134]"}
          segParent(Heap, Heap[this, Nodes], null) == segParent(Heap, binHeap, null);
      }
      // Finish exhale
      havoc ExhaleHeap;
      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
      Heap := ExhaleHeap;
    
    // -- Inhaling postcondition
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
      assume state(Heap, Mask);
      assume Heap[this, Nodes] != null;
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume presorted(Heap, Heap[this, Nodes], null);
      assume state(Heap, Mask);
      assume segSize(Heap, Heap[this, Nodes], null) == segSize(PreCallHeap, PreCallHeap[this, Nodes], null) + segSize(PreCallHeap, binHeap, null);
      assume state(Heap, Mask);
      assume segParent(Heap, Heap[this, Nodes], null) == segParent(PreCallHeap, PreCallHeap[this, Nodes], null);
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: prevTemp := null -- BinomialHeap.vpr@435.2--435.18
    prevTemp := null;
    assume state(Heap, Mask);
  
  // -- Translating statement: temp := this.Nodes -- BinomialHeap.vpr@436.2--436.20
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@436.2--436.20) [101135]"}
        HasDirectPerm(Mask, this, Nodes);
    temp_1 := Heap[this, Nodes];
    assume state(Heap, Mask);
  
  // -- Translating statement: unfold acc(heapseg(this.Nodes, null), write) -- BinomialHeap.vpr@437.2--437.34
    
    // -- Check definedness of acc(heapseg(this.Nodes, null), write)
      assert {:msg "  Unfolding heapseg(this.Nodes, null) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@437.2--437.34) [101136]"}
        HasDirectPerm(Mask, this, Nodes);
    assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes], null));
    assume Heap[null, heapseg(Heap[this, Nodes], null)] == FrameFragment((if Heap[this, Nodes] != null then CombineFrames(Heap[null, tree(Heap[this, Nodes])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], null)], FrameFragment((if Heap[Heap[this, Nodes], sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Unfolding heapseg(this.Nodes, null) might fail. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@437.2--437.34) [101139]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] - perm];
    
    // -- Update version of predicate
      if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes], null))) {
        havoc newVersion;
        Heap := Heap[null, heapseg(Heap[this, Nodes], null):=newVersion];
      }
    if (Heap[this, Nodes] != null) {
      perm := FullPerm;
      Mask := Mask[null, tree(Heap[this, Nodes]):=Mask[null, tree(Heap[this, Nodes])] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(Heap[this, Nodes], null), Heap[null, heapseg(Heap[this, Nodes], null)], tree(Heap[this, Nodes]), Heap[null, tree(Heap[this, Nodes])]);
      assume state(Heap, Mask);
      perm := FullPerm;
      assume Heap[this, Nodes] != null;
      Mask := Mask[Heap[this, Nodes], sibling:=Mask[Heap[this, Nodes], sibling] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      Mask := Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], null):=Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], null)] + perm];
      
      // -- Extra unfolding of predicate
        assume InsidePredicate(heapseg(Heap[this, Nodes], null), Heap[null, heapseg(Heap[this, Nodes], null)], heapseg(Heap[Heap[this, Nodes], sibling], null), Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], null)]);
      assume state(Heap, Mask);
      if (Heap[Heap[this, Nodes], sibling] != null) {
        assume state(Heap, Mask);
        assume treeParent(Heap, Heap[this, Nodes]) == segParent(Heap, Heap[Heap[this, Nodes], sibling], null);
      }
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: nextTemp := temp.sibling -- BinomialHeap.vpr@438.2--438.26
    
    // -- Check definedness of temp.sibling
      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@438.2--438.26) [101143]"}
        HasDirectPerm(Mask, temp_1, sibling);
    nextTemp := Heap[temp_1, sibling];
    assume state(Heap, Mask);
  
  // -- Translating statement: while (nextTemp != null) -- BinomialHeap.vpr@440.2--515.3
    
    // -- Before loop head
      
      // -- Exhale loop invariant before loop
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) might not hold on entry. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@441.13--441.28) [101144]"}
            perm <= Mask[this, Nodes];
        }
        Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not hold on entry. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@442.13--442.95) [101145]"}
              perm <= Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
          }
          Mask := Mask[null, heapseg(Heap[this, Nodes], prevTemp):=Mask[null, heapseg(Heap[this, Nodes], prevTemp)] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not hold on entry. Assertion sorted(this.Nodes, prevTemp) might not hold. (BinomialHeap.vpr@442.13--442.95) [101146]"}
            sorted(Heap, Heap[this, Nodes], prevTemp);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> this.Nodes == temp might not hold on entry. Assertion this.Nodes == temp might not hold. (BinomialHeap.vpr@443.13--443.52) [101147]"}
            Heap[this, Nodes] == temp_1;
        }
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not hold on entry. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@444.13--444.65) [101148]"}
            perm <= Mask[null, heapseg(nextTemp, null)];
        }
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not hold on entry. Assertion presorted(nextTemp, null) might not hold. (BinomialHeap.vpr@444.13--444.65) [101149]"}
          presorted(Heap, nextTemp, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@445.13--447.48) [101150]"}
            perm <= Mask[null, tree(temp_1)];
        }
        Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@445.13--447.48) [101151]"}
            perm <= Mask[temp_1, sibling];
        }
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
        assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. Assertion temp.sibling == nextTemp might not hold. (BinomialHeap.vpr@445.13--447.48) [101152]"}
          Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. Assertion treeDegree(temp) <= segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@445.13--447.48) [101153]"}
            treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not hold on entry. Assertion treeParent(temp) == segParent(nextTemp, null) might not hold. (BinomialHeap.vpr@445.13--447.48) [101154]"}
            treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@448.13--450.42) [101155]"}
              perm <= Mask[null, tree(prevTemp)];
          }
          Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@448.13--450.42) [101156]"}
              perm <= Mask[prevTemp, sibling];
          }
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@448.13--450.42) [101157]"}
            Heap[prevTemp, sibling] == temp_1;
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. Assertion treeDegree(prevTemp) <= treeDegree(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [101158]"}
            treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not hold on entry. Assertion treeParent(prevTemp) == treeParent(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [101159]"}
            treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assert {:msg "  Loop invariant prevTemp != null && (0 < segLength(this.Nodes, prevTemp) && (2 <= segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && segDegree(nextTemp, null, 0) == segDegree(nextTemp, null, 1)))) ==> treeDegree(prevTemp) < treeDegree(temp) might not hold on entry. Assertion treeDegree(prevTemp) < treeDegree(temp) might not hold. (BinomialHeap.vpr@451.13--454.41) [101160]"}
            treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not hold on entry. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@455.13--458.98) [101161]"}
            0 < segLength(Heap, nextTemp, null);
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not hold on entry. Assertion treeDegree(temp) == segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@455.13--458.98) [101162]"}
            treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          if (2 <= segLength(Heap, nextTemp, null)) {
            assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not hold on entry. Assertion segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1) might not hold. (BinomialHeap.vpr@455.13--458.98) [101163]"}
              segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes], prevTemp)) {
          assert {:msg "  Loop invariant prevTemp != null && 0 < segLength(this.Nodes, prevTemp) ==> segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold on entry. Assertion segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@459.13--461.93) [101164]"}
            segDegree(Heap, Heap[this, Nodes], prevTemp, segLength(Heap, Heap[this, Nodes], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        if (prevTemp != null) {
          assert {:msg "  Loop invariant prevTemp != null ==> segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@462.13--463.159) [101165]"}
            segSize(Heap, Heap[this, Nodes], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold on entry. Assertion treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@464.13--465.106) [101166]"}
            treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp != null && Heap[this, Nodes] != prevTemp) {
          assert {:msg "  Loop invariant prevTemp != null && this.Nodes != prevTemp ==> segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not hold on entry. Assertion segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not hold. (BinomialHeap.vpr@466.13--466.115) [101167]"}
            segParent(Heap, Heap[this, Nodes], prevTemp) == treeParent(Heap, prevTemp);
        }
        assert {:msg "  Loop invariant treeParent(temp) == old(segParent(this.Nodes, null)) might not hold on entry. Assertion treeParent(temp) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@467.13--467.65) [101168]"}
          treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
    
    // -- Havoc loop written variables (except locals)
      havoc nextTemp, temp_1, prevTemp;
      assume Heap[nextTemp, $allocated];
      assume Heap[temp_1, $allocated];
      assume Heap[prevTemp, $allocated];
    
    // -- Check definedness of invariant
      if (*) {
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        if (prevTemp != null) {
          
          // -- Check definedness of acc(heapseg(this.Nodes, prevTemp), write)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@442.13--442.95) [101169]"}
              HasDirectPerm(Mask, this, Nodes);
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[this, Nodes], prevTemp):=Mask[null, heapseg(Heap[this, Nodes], prevTemp)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          
          // -- Check definedness of sorted(this.Nodes, prevTemp)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@442.13--442.95) [101170]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@442.67--442.95) [101171]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume sorted(Heap, Heap[this, Nodes], prevTemp);
        }
        assume state(Heap, Mask);
        if (prevTemp == null) {
          
          // -- Check definedness of this.Nodes == temp
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@443.13--443.52) [101172]"}
              HasDirectPerm(Mask, this, Nodes);
          assume Heap[this, Nodes] == temp_1;
        }
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of presorted(nextTemp, null)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function presorted might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@444.40--444.65) [101173]"}
              NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        assume presorted(Heap, nextTemp, null);
        assume state(Heap, Mask);
        perm := FullPerm;
        Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
        assume state(Heap, Mask);
        
        // -- Check definedness of temp.sibling == nextTemp
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@445.13--447.48) [101174]"}
            HasDirectPerm(Mask, temp_1, sibling);
        assume Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(temp) <= segDegree(nextTemp, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@446.24--446.40) [101175]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@446.44--446.72) [101176]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@446.44--446.72) [101177]"}
                0 < segLength(Heap, nextTemp, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assume state(Heap, Mask);
          
          // -- Check definedness of treeParent(temp) == segParent(nextTemp, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@447.2--447.18) [101178]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@447.22--447.47) [101179]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion nextTemp != null might not hold. (BinomialHeap.vpr@447.22--447.47) [101180]"}
                nextTemp != null;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        assume state(Heap, Mask);
        if (prevTemp != null) {
          perm := FullPerm;
          Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          assume prevTemp != null;
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
          assume state(Heap, Mask);
          
          // -- Check definedness of prevTemp.sibling == temp
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@448.13--450.42) [101181]"}
              HasDirectPerm(Mask, prevTemp, sibling);
          assume Heap[prevTemp, sibling] == temp_1;
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(prevTemp) <= treeDegree(temp)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@449.2--449.22) [101182]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@449.26--449.42) [101183]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assume state(Heap, Mask);
          
          // -- Check definedness of treeParent(prevTemp) == treeParent(temp)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@450.2--450.22) [101184]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@450.26--450.42) [101185]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && (0 < segLength(this.Nodes, prevTemp) && (2 <= segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && segDegree(nextTemp, null, 0) == segDegree(nextTemp, null, 1))))
          if (prevTemp != null) {
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@451.13--454.41) [101186]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@451.37--451.68) [101187]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (0 < segLength(Heap, Heap[this, Nodes], prevTemp)) {
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@451.77--451.102) [101188]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (2 <= segLength(Heap, nextTemp, null)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@452.2--452.18) [101189]"}
                    NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@452.22--452.50) [101190]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@452.22--452.50) [101191]"}
                    0 < segLength(Heap, nextTemp, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0)) {
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@452.54--452.82) [101192]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@452.54--452.82) [101193]"}
                      0 < segLength(Heap, nextTemp, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@452.86--452.114) [101194]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@452.86--452.114) [101195]"}
                      1 < segLength(Heap, nextTemp, null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              }
            }
          }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(prevTemp) < treeDegree(temp)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@454.2--454.22) [101196]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@454.25--454.41) [101197]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && treeDegree(prevTemp) == treeDegree(temp)
          if (prevTemp != null) {
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@455.33--455.53) [101198]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@455.57--455.73) [101199]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of 0 < segLength(nextTemp, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@457.6--457.31) [101200]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume 0 < segLength(Heap, nextTemp, null);
          assume state(Heap, Mask);
          
          // -- Check definedness of treeDegree(temp) == segDegree(nextTemp, null, 0)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@457.35--457.51) [101201]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@457.55--457.83) [101202]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@457.55--457.83) [101203]"}
                0 < segLength(Heap, nextTemp, null);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          
          // -- Check definedness of 2 <= segLength(nextTemp, null)
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@458.8--458.33) [101204]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          if (2 <= segLength(Heap, nextTemp, null)) {
            assume state(Heap, Mask);
            
            // -- Check definedness of segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@458.38--458.66) [101205]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@458.38--458.66) [101206]"}
                  0 < segLength(Heap, nextTemp, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@458.69--458.97) [101207]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
                assert {:msg "  Precondition of function segDegree might not hold. Assertion 1 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@458.69--458.97) [101208]"}
                  1 < segLength(Heap, nextTemp, null);
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && 0 < segLength(this.Nodes, prevTemp)
          if (prevTemp != null) {
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@459.13--461.93) [101209]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@459.37--459.68) [101210]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes], prevTemp)) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@459.13--461.93) [101211]"}
              HasDirectPerm(Mask, this, Nodes);
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@459.13--461.93) [101212]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@461.34--461.65) [101213]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@461.2--461.70) [101214]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
              assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(this.Nodes, prevTemp) - 1 might not hold. (BinomialHeap.vpr@461.2--461.70) [101215]"}
                0 <= segLength(Heap, Heap[this, Nodes], prevTemp) - 1;
              assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(this.Nodes, prevTemp) - 1 < segLength(this.Nodes, prevTemp) might not hold. (BinomialHeap.vpr@461.2--461.70) [101216]"}
                segLength(Heap, Heap[this, Nodes], prevTemp) - 1 < segLength(Heap, Heap[this, Nodes], prevTemp);
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@461.73--461.93) [101217]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segDegree(Heap, Heap[this, Nodes], prevTemp, segLength(Heap, Heap[this, Nodes], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        assume state(Heap, Mask);
        if (prevTemp != null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@462.13--463.159) [101218]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@463.2--463.31) [101219]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@463.34--463.52) [101220]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@463.55--463.69) [101221]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@463.72--463.95) [101222]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@462.13--463.159) [101223]"}
              HasDirectPerm(oldMask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@463.103--463.128) [101224]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@463.136--463.158) [101225]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume segSize(Heap, Heap[this, Nodes], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        assume state(Heap, Mask);
        if (prevTemp == null) {
          assume state(Heap, Mask);
          
          // -- Check definedness of treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null))
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@465.2--465.16) [101226]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@465.19--465.42) [101227]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(nextTemp, null)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@464.13--465.106) [101228]"}
              HasDirectPerm(oldMask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@465.50--465.75) [101229]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := oldHeap;
              ExhaleWellDef0Mask := oldMask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(binHeap, null) (BinomialHeap.vpr@465.83--465.105) [101230]"}
                NoPerm < perm ==> NoPerm < oldMask[null, heapseg(binHeap, null)];
              // Finish exhale
              // Stop execution
              assume false;
            }
          assume treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        assume state(Heap, Mask);
        
        // -- Check definedness of prevTemp != null && this.Nodes != prevTemp
          if (prevTemp != null) {
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@466.13--466.115) [101231]"}
              HasDirectPerm(Mask, this, Nodes);
          }
        if (prevTemp != null && Heap[this, Nodes] != prevTemp) {
          assume state(Heap, Mask);
          
          // -- Check definedness of segParent(this.Nodes, prevTemp) == treeParent(prevTemp)
            assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@466.13--466.115) [101232]"}
              HasDirectPerm(Mask, this, Nodes);
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@466.60--466.91) [101233]"}
                NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
              assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != prevTemp might not hold. (BinomialHeap.vpr@466.60--466.91) [101234]"}
                Heap[this, Nodes] != prevTemp;
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
            if (*) {
              // Exhale precondition of function application
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@466.95--466.115) [101235]"}
                NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
              // Stop execution
              assume false;
            }
          assume segParent(Heap, Heap[this, Nodes], prevTemp) == treeParent(Heap, prevTemp);
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        
        // -- Check definedness of treeParent(temp) == old(segParent(this.Nodes, null))
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@467.13--467.29) [101236]"}
              NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
          assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@467.13--467.65) [101237]"}
            HasDirectPerm(oldMask, this, Nodes);
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := oldHeap;
            ExhaleWellDef0Mask := oldMask;
            perm := FullPerm;
            assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@467.37--467.64) [101238]"}
              NoPerm < perm ==> NoPerm < oldMask[null, heapseg(oldHeap[this, Nodes], null)];
            assert {:msg "  Precondition of function segParent might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@467.37--467.64) [101239]"}
              oldHeap[this, Nodes] != null;
            // Finish exhale
            // Stop execution
            assume false;
          }
        assume treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        assume state(Heap, Mask);
        assume false;
      }
    
    // -- Check the loop body
      if (*) {
        // Reset state
        loopHeap := Heap;
        loopMask := Mask;
        Mask := ZeroMask;
        assume state(Heap, Mask);
        // Inhale invariant
        perm := FullPerm;
        assume this != null;
        Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
        assume state(Heap, Mask);
        if (prevTemp != null) {
          perm := FullPerm;
          Mask := Mask[null, heapseg(Heap[this, Nodes], prevTemp):=Mask[null, heapseg(Heap[this, Nodes], prevTemp)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted(Heap, Heap[this, Nodes], prevTemp);
        }
        if (prevTemp == null) {
          assume Heap[this, Nodes] == temp_1;
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume presorted(Heap, nextTemp, null);
        perm := FullPerm;
        Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
        assume state(Heap, Mask);
        assume Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assume state(Heap, Mask);
          assume treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assume state(Heap, Mask);
          assume treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        if (prevTemp != null) {
          perm := FullPerm;
          Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          assume prevTemp != null;
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
          assume state(Heap, Mask);
          assume Heap[prevTemp, sibling] == temp_1;
          assume state(Heap, Mask);
          assume treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assume state(Heap, Mask);
          assume treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assume state(Heap, Mask);
          assume treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assume state(Heap, Mask);
          assume 0 < segLength(Heap, nextTemp, null);
          assume state(Heap, Mask);
          assume treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          if (2 <= segLength(Heap, nextTemp, null)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes], prevTemp)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[this, Nodes], prevTemp, segLength(Heap, Heap[this, Nodes], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        if (prevTemp != null) {
          assume state(Heap, Mask);
          assume segSize(Heap, Heap[this, Nodes], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp == null) {
          assume state(Heap, Mask);
          assume treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp != null && Heap[this, Nodes] != prevTemp) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[this, Nodes], prevTemp) == treeParent(Heap, prevTemp);
        }
        assume state(Heap, Mask);
        assume treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        assume state(Heap, Mask);
        // Check and assume guard
        assume nextTemp != null;
        assume state(Heap, Mask);
        
        // -- Translate loop body
          
          // -- Translating statement: unfold acc(heapseg(nextTemp, null), write) -- BinomialHeap.vpr@469.3--469.33
            assume heapseg#trigger(Heap, heapseg(nextTemp, null));
            assume Heap[null, heapseg(nextTemp, null)] == FrameFragment((if nextTemp != null then CombineFrames(Heap[null, tree(nextTemp)], CombineFrames(FrameFragment(Heap[nextTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, sibling], null)], FrameFragment((if Heap[nextTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(nextTemp, null) might fail. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@469.3--469.33) [101240]"}
                perm <= Mask[null, heapseg(nextTemp, null)];
            }
            Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(nextTemp, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(nextTemp, null):=newVersion];
              }
            if (nextTemp != null) {
              perm := FullPerm;
              Mask := Mask[null, tree(nextTemp):=Mask[null, tree(nextTemp)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], tree(nextTemp), Heap[null, tree(nextTemp)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume nextTemp != null;
              Mask := Mask[nextTemp, sibling:=Mask[nextTemp, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[nextTemp, sibling], null):=Mask[null, heapseg(Heap[nextTemp, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], heapseg(Heap[nextTemp, sibling], null), Heap[null, heapseg(Heap[nextTemp, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[nextTemp, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, nextTemp) == segParent(Heap, Heap[nextTemp, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: if (treeDegree(temp) != treeDegree(nextTemp) || nextTemp.sibling != null && segDegree(nextTemp.sibling, null, 0) == treeDegree(temp)) -- BinomialHeap.vpr@470.3--512.4
            
            // -- Check definedness of treeDegree(temp) != treeDegree(nextTemp) || nextTemp.sibling != null && segDegree(nextTemp.sibling, null, 0) == treeDegree(temp)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@470.6--470.22) [101241]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@470.26--470.46) [101242]"}
                  NoPerm < perm ==> NoPerm < Mask[null, tree(nextTemp)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (!(treeDegree(Heap, temp_1) != treeDegree(Heap, nextTemp))) {
                assert {:msg "  Conditional statement might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@470.6--471.91) [101243]"}
                  HasDirectPerm(Mask, nextTemp, sibling);
                if (Heap[nextTemp, sibling] != null) {
                  assert {:msg "  Conditional statement might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@470.6--471.91) [101244]"}
                    HasDirectPerm(Mask, nextTemp, sibling);
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nextTemp.sibling, null) (BinomialHeap.vpr@471.34--471.70) [101245]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(Heap[nextTemp, sibling], null)];
                    assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(nextTemp.sibling, null) might not hold. (BinomialHeap.vpr@471.34--471.70) [101246]"}
                      0 < segLength(Heap, Heap[nextTemp, sibling], null);
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@471.74--471.90) [101247]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                }
              }
            if (treeDegree(Heap, temp_1) != treeDegree(Heap, nextTemp) || (Heap[nextTemp, sibling] != null && segDegree(Heap, Heap[nextTemp, sibling], null, 0) == treeDegree(Heap, temp_1))) {
              
              // -- Translating statement: if (prevTemp == null) -- BinomialHeap.vpr@472.4--479.5
                if (prevTemp == null) {
                  
                  // -- Translating statement: fold acc(heapseg(this.Nodes, temp), write) -- BinomialHeap.vpr@474.5--474.35
                    
                    // -- Check definedness of acc(heapseg(this.Nodes, temp), write)
                      assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@474.5--474.35) [101248]"}
                        HasDirectPerm(Mask, this, Nodes);
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (Heap[this, Nodes] != temp_1) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access tree(this.Nodes) (BinomialHeap.vpr@474.5--474.35) [101249]"}
                          perm <= Mask[null, tree(Heap[this, Nodes])];
                      }
                      Mask := Mask[null, tree(Heap[this, Nodes]):=Mask[null, tree(Heap[this, Nodes])] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[this, Nodes], temp_1), Heap[null, heapseg(Heap[this, Nodes], temp_1)], tree(Heap[this, Nodes]), Heap[null, tree(Heap[this, Nodes])]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access this.Nodes.sibling (BinomialHeap.vpr@474.5--474.35) [101250]"}
                          perm <= Mask[Heap[this, Nodes], sibling];
                      }
                      Mask := Mask[Heap[this, Nodes], sibling:=Mask[Heap[this, Nodes], sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. There might be insufficient permission to access heapseg(this.Nodes.sibling, temp) (BinomialHeap.vpr@474.5--474.35) [101251]"}
                          perm <= Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp_1)];
                      }
                      Mask := Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp_1):=Mask[null, heapseg(Heap[Heap[this, Nodes], sibling], temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[this, Nodes], temp_1), Heap[null, heapseg(Heap[this, Nodes], temp_1)], heapseg(Heap[Heap[this, Nodes], sibling], temp_1), Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp_1)]);
                      if (Heap[Heap[this, Nodes], sibling] != temp_1) {
                        assert {:msg "  Folding heapseg(this.Nodes, temp) might fail. Assertion treeParent(this.Nodes) == segParent(this.Nodes.sibling, temp) might not hold. (BinomialHeap.vpr@474.5--474.35) [101252]"}
                          treeParent(Heap, Heap[this, Nodes]) == segParent(Heap, Heap[Heap[this, Nodes], sibling], temp_1);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[this, Nodes], temp_1):=Mask[null, heapseg(Heap[this, Nodes], temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(Heap[this, Nodes], temp_1));
                    assume Heap[null, heapseg(Heap[this, Nodes], temp_1)] == FrameFragment((if Heap[this, Nodes] != temp_1 then CombineFrames(Heap[null, tree(Heap[this, Nodes])], CombineFrames(FrameFragment(Heap[Heap[this, Nodes], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[this, Nodes], sibling], temp_1)], FrameFragment((if Heap[Heap[this, Nodes], sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(Heap[this, Nodes], temp_1))) {
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(Heap[this, Nodes], temp_1):=freshVersion];
                    }
                    if (Heap[this, Nodes] != temp_1) {
                      havoc newPMask;
                      assume (forall <A, B> o_149: Ref, f_150: (Field A B) ::
                        { newPMask[o_149, f_150] }
                        Heap[null, heapseg#sm(Heap[this, Nodes], temp_1)][o_149, f_150] || Heap[null, tree#sm(Heap[this, Nodes])][o_149, f_150] ==> newPMask[o_149, f_150]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp_1):=newPMask];
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp_1):=Heap[null, heapseg#sm(Heap[this, Nodes], temp_1)][Heap[this, Nodes], sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_150: Ref, f_151: (Field A B) ::
                        { newPMask[o_150, f_151] }
                        Heap[null, heapseg#sm(Heap[this, Nodes], temp_1)][o_150, f_151] || Heap[null, heapseg#sm(Heap[Heap[this, Nodes], sibling], temp_1)][o_150, f_151] ==> newPMask[o_150, f_151]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[this, Nodes], temp_1):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: fold acc(heapseg(temp, temp), write) -- BinomialHeap.vpr@476.5--476.29
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (temp_1 != temp_1) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@476.5--476.29) [101253]"}
                          perm <= Mask[null, tree(temp_1)];
                      }
                      Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], tree(temp_1), Heap[null, tree(temp_1)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@476.5--476.29) [101254]"}
                          perm <= Mask[temp_1, sibling];
                      }
                      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access heapseg(temp.sibling, temp) (BinomialHeap.vpr@476.5--476.29) [101255]"}
                          perm <= Mask[null, heapseg(Heap[temp_1, sibling], temp_1)];
                      }
                      Mask := Mask[null, heapseg(Heap[temp_1, sibling], temp_1):=Mask[null, heapseg(Heap[temp_1, sibling], temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], heapseg(Heap[temp_1, sibling], temp_1), Heap[null, heapseg(Heap[temp_1, sibling], temp_1)]);
                      if (Heap[temp_1, sibling] != temp_1) {
                        assert {:msg "  Folding heapseg(temp, temp) might fail. Assertion treeParent(temp) == segParent(temp.sibling, temp) might not hold. (BinomialHeap.vpr@476.5--476.29) [101256]"}
                          treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], temp_1);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(temp_1, temp_1):=Mask[null, heapseg(temp_1, temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(temp_1, temp_1));
                    assume Heap[null, heapseg(temp_1, temp_1)] == FrameFragment((if temp_1 != temp_1 then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], temp_1)], FrameFragment((if Heap[temp_1, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(temp_1, temp_1))) {
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(temp_1, temp_1):=freshVersion];
                    }
                    if (temp_1 != temp_1) {
                      havoc newPMask;
                      assume (forall <A, B> o_151: Ref, f_152: (Field A B) ::
                        { newPMask[o_151, f_152] }
                        Heap[null, heapseg#sm(temp_1, temp_1)][o_151, f_152] || Heap[null, tree#sm(temp_1)][o_151, f_152] ==> newPMask[o_151, f_152]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=Heap[null, heapseg#sm(temp_1, temp_1)][temp_1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_152: Ref, f_153: (Field A B) ::
                        { newPMask[o_152, f_153] }
                        Heap[null, heapseg#sm(temp_1, temp_1)][o_152, f_153] || Heap[null, heapseg#sm(Heap[temp_1, sibling], temp_1)][o_152, f_153] ==> newPMask[o_152, f_153]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(prevTemp, temp), write) -- BinomialHeap.vpr@477.5--477.33
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (prevTemp != temp_1) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@477.5--477.33) [101257]"}
                          perm <= Mask[null, tree(prevTemp)];
                      }
                      Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], tree(prevTemp), Heap[null, tree(prevTemp)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@477.5--477.33) [101258]"}
                          perm <= Mask[prevTemp, sibling];
                      }
                      Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, temp) (BinomialHeap.vpr@477.5--477.33) [101259]"}
                          perm <= Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)];
                      }
                      Mask := Mask[null, heapseg(Heap[prevTemp, sibling], temp_1):=Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], heapseg(Heap[prevTemp, sibling], temp_1), Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)]);
                      if (Heap[prevTemp, sibling] != temp_1) {
                        assert {:msg "  Folding heapseg(prevTemp, temp) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, temp) might not hold. (BinomialHeap.vpr@477.5--477.33) [101260]"}
                          treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], temp_1);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(prevTemp, temp_1));
                    assume Heap[null, heapseg(prevTemp, temp_1)] == FrameFragment((if prevTemp != temp_1 then CombineFrames(Heap[null, tree(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)], FrameFragment((if Heap[prevTemp, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(prevTemp, temp_1))) {
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(prevTemp, temp_1):=freshVersion];
                    }
                    if (prevTemp != temp_1) {
                      havoc newPMask;
                      assume (forall <A, B> o_153: Ref, f_154: (Field A B) ::
                        { newPMask[o_153, f_154] }
                        Heap[null, heapseg#sm(prevTemp, temp_1)][o_153, f_154] || Heap[null, tree#sm(prevTemp)][o_153, f_154] ==> newPMask[o_153, f_154]
                      );
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=Heap[null, heapseg#sm(prevTemp, temp_1)][prevTemp, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_154: Ref, f_155: (Field A B) ::
                        { newPMask[o_154, f_155] }
                        Heap[null, heapseg#sm(prevTemp, temp_1)][o_154, f_155] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], temp_1)][o_154, f_155] ==> newPMask[o_154, f_155]
                      );
                      Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: concat(this.Nodes, prevTemp, temp) -- BinomialHeap.vpr@478.5--478.39
                    PreCallHeap := Heap;
                    PreCallMask := Mask;
                    
                    // -- Check definedness of this.Nodes
                      assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@478.5--478.39) [101261]"}
                        HasDirectPerm(Mask, this, Nodes);
                    arg_a := Heap[this, Nodes];
                    
                    // -- Exhaling precondition
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@478.5--478.39) [101262]"}
                          perm <= Mask[null, heapseg(arg_a, prevTemp)];
                      }
                      Mask := Mask[null, heapseg(arg_a, prevTemp):=Mask[null, heapseg(arg_a, prevTemp)] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, temp) (BinomialHeap.vpr@478.5--478.39) [101263]"}
                          perm <= Mask[null, heapseg(prevTemp, temp_1)];
                      }
                      Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] - perm];
                      if (temp_1 != null) {
                        perm := FullPerm;
                        if (perm != NoPerm) {
                          assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@478.5--478.39) [101264]"}
                            perm <= Mask[null, tree(temp_1)];
                        }
                        Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                      }
                      if (arg_a != prevTemp && prevTemp != temp_1) {
                        assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, prevTemp) == segParent(prevTemp, temp) might not hold. (BinomialHeap.vpr@478.5--478.39) [101265]"}
                          segParent(Heap, arg_a, prevTemp) == segParent(Heap, prevTemp, temp_1);
                      }
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                    
                    // -- Inhaling postcondition
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(arg_a, temp_1):=Mask[null, heapseg(arg_a, temp_1)] + perm];
                      assume state(Heap, Mask);
                      assume state(Heap, Mask);
                      assume segLength(Heap, arg_a, temp_1) == segLength(PreCallHeap, arg_a, prevTemp) + segLength(PreCallHeap, prevTemp, temp_1);
                      assume state(Heap, Mask);
                      assume (forall i: int ::
                        { segDegree#frame(Heap[null, heapseg(arg_a, temp_1)], arg_a, temp_1, i) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a, prevTemp)], arg_a, prevTemp, i) }
                        0 <= i && i < segLength(PreCallHeap, arg_a, prevTemp) ==> segDegree(Heap, arg_a, temp_1, i) == segDegree(PreCallHeap, arg_a, prevTemp, i)
                      );
                      assume state(Heap, Mask);
                      assume (forall i_1: int ::
                        { segDegree#frame(Heap[null, heapseg(arg_a, temp_1)], arg_a, temp_1, i_1) }
                        segLength(PreCallHeap, arg_a, prevTemp) <= i_1 && i_1 < segLength(Heap, arg_a, temp_1) ==> segDegree(Heap, arg_a, temp_1, i_1) == segDegree(PreCallHeap, prevTemp, temp_1, i_1 - segLength(PreCallHeap, arg_a, prevTemp))
                      );
                      if (temp_1 != null) {
                        perm := FullPerm;
                        Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume treeDegree(Heap, temp_1) == treeDegree(PreCallHeap, temp_1);
                        assume state(Heap, Mask);
                        assume treeSize(Heap, temp_1) == treeSize(PreCallHeap, temp_1);
                        assume state(Heap, Mask);
                        assume treeParent(Heap, temp_1) == treeParent(PreCallHeap, temp_1);
                      }
                      if (sorted(PreCallHeap, arg_a, prevTemp) && (sorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, arg_a, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))) {
                        assume state(Heap, Mask);
                        assume sorted(Heap, arg_a, temp_1);
                      }
                      if (presorted(PreCallHeap, arg_a, prevTemp) && (presorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, arg_a, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, temp_1, 0) && ((2 <= segLength(PreCallHeap, arg_a, prevTemp) && segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) == segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 2) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)) && (2 <= segLength(PreCallHeap, prevTemp, temp_1) && segDegree(PreCallHeap, prevTemp, temp_1, 0) == segDegree(PreCallHeap, prevTemp, temp_1, 1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))))) {
                        assume state(Heap, Mask);
                        assume presorted(Heap, arg_a, temp_1);
                      }
                      if (validChildren(PreCallHeap, arg_a, prevTemp) && (validChildren(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, arg_a, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, arg_a, prevTemp, segLength(PreCallHeap, arg_a, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, temp_1, 0) + 1))) {
                        assume state(Heap, Mask);
                        assume validChildren(Heap, arg_a, temp_1);
                      }
                      assume state(Heap, Mask);
                      assume segSize(Heap, arg_a, temp_1) == segSize(PreCallHeap, arg_a, prevTemp) + segSize(PreCallHeap, prevTemp, temp_1);
                      if (arg_a != prevTemp) {
                        assume state(Heap, Mask);
                        assume segParent(Heap, arg_a, temp_1) == segParent(PreCallHeap, arg_a, prevTemp);
                      }
                      if (prevTemp != temp_1) {
                        assume state(Heap, Mask);
                        assume segParent(Heap, arg_a, temp_1) == segParent(PreCallHeap, prevTemp, temp_1);
                      }
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
              
              // -- Translating statement: prevTemp := temp -- BinomialHeap.vpr@480.4--480.20
                prevTemp := temp_1;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp := nextTemp -- BinomialHeap.vpr@481.4--481.20
                temp_1 := nextTemp;
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: if (treeKey(temp) <= treeKey(nextTemp)) -- BinomialHeap.vpr@483.4--511.5
                
                // -- Check definedness of treeKey(temp) <= treeKey(nextTemp)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@483.7--483.20) [101266]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function treeKey might not hold. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@483.24--483.41) [101267]"}
                      NoPerm < perm ==> NoPerm < Mask[null, tree(nextTemp)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                if (treeKey(Heap, temp_1) <= treeKey(Heap, nextTemp)) {
                  
                  // -- Translating statement: temp.sibling := nextTemp.sibling -- BinomialHeap.vpr@484.5--484.37
                    
                    // -- Check definedness of nextTemp.sibling
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@484.5--484.37) [101268]"}
                        HasDirectPerm(Mask, nextTemp, sibling);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@484.5--484.37) [101269]"}
                      FullPerm == Mask[temp_1, sibling];
                    Heap := Heap[temp_1, sibling:=Heap[nextTemp, sibling]];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(nextTemp), write) -- BinomialHeap.vpr@485.5--485.26
                    assume tree#trigger(Heap, tree(nextTemp));
                    assume Heap[null, tree(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(nextTemp) might fail. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@485.5--485.26) [101270]"}
                        perm <= Mask[null, tree(nextTemp)];
                    }
                    Mask := Mask[null, tree(nextTemp):=Mask[null, tree(nextTemp)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree(nextTemp))) {
                        havoc newVersion;
                        Heap := Heap[null, tree(nextTemp):=newVersion];
                      }
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, key:=Mask[nextTemp, key] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree(nextTemp), Heap[null, tree(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.parent := temp -- BinomialHeap.vpr@486.5--486.28
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.parent (BinomialHeap.vpr@486.5--486.28) [101271]"}
                      FullPerm == Mask[nextTemp, parent];
                    Heap := Heap[nextTemp, parent:=temp_1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(nextTemp), write) -- BinomialHeap.vpr@487.5--487.24
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.key (BinomialHeap.vpr@487.5--487.24) [101272]"}
                        perm <= Mask[nextTemp, key];
                    }
                    Mask := Mask[nextTemp, key:=Mask[nextTemp, key] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@487.5--487.24) [101273]"}
                        perm <= Mask[nextTemp, degree];
                    }
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@487.5--487.24) [101274]"}
                        perm <= Mask[nextTemp, child];
                    }
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.parent (BinomialHeap.vpr@487.5--487.24) [101275]"}
                        perm <= Mask[nextTemp, parent];
                    }
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] - perm];
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion 0 <= nextTemp.degree might not hold. (BinomialHeap.vpr@487.5--487.24) [101276]"}
                      0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access heapseg(nextTemp.child, null) (BinomialHeap.vpr@487.5--487.24) [101277]"}
                        perm <= Mask[null, heapseg(Heap[nextTemp, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree(nextTemp), Heap[null, tree(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion nextTemp.degree == segLength(nextTemp.child, null) might not hold. (BinomialHeap.vpr@487.5--487.24) [101278]"}
                      Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segDegree(nextTemp.child, null, 0) == nextTemp.degree - 1 might not hold. (BinomialHeap.vpr@487.5--487.24) [101279]"}
                        segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion validChildren(nextTemp.child, null) might not hold. (BinomialHeap.vpr@487.5--487.24) [101280]"}
                      validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segParent(nextTemp.child, null) == nextTemp might not hold. (BinomialHeap.vpr@487.5--487.24) [101281]"}
                        segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree(nextTemp):=Mask[null, tree(nextTemp)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree(nextTemp));
                    assume Heap[null, tree(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree(nextTemp))) {
                      Heap := Heap[null, tree#sm(nextTemp):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree(nextTemp):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, key:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, degree:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, child:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_155: Ref, f_156: (Field A B) ::
                      { newPMask[o_155, f_156] }
                      Heap[null, tree#sm(nextTemp)][o_155, f_156] || Heap[null, heapseg#sm(Heap[nextTemp, child], null)][o_155, f_156] ==> newPMask[o_155, f_156]
                    );
                    Heap := Heap[null, tree#sm(nextTemp):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@488.5--488.22
                    assume tree#trigger(Heap, tree(temp_1));
                    assume Heap[null, tree(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@488.5--488.22) [101282]"}
                        perm <= Mask[null, tree(temp_1)];
                    }
                    Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree(temp_1))) {
                        havoc newVersion;
                        Heap := Heap[null, tree(temp_1):=newVersion];
                      }
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, key:=Mask[temp_1, key] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree(temp_1), Heap[null, tree(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.sibling := temp.child -- BinomialHeap.vpr@489.5--489.35
                    
                    // -- Check definedness of temp.child
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@489.5--489.35) [101283]"}
                        HasDirectPerm(Mask, temp_1, child);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@489.5--489.35) [101284]"}
                      FullPerm == Mask[nextTemp, sibling];
                    Heap := Heap[nextTemp, sibling:=Heap[temp_1, child]];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.child := nextTemp -- BinomialHeap.vpr@490.5--490.27
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@490.5--490.27) [101285]"}
                      FullPerm == Mask[temp_1, child];
                    Heap := Heap[temp_1, child:=nextTemp];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.degree := temp.degree + 1 -- BinomialHeap.vpr@491.5--491.35
                    
                    // -- Check definedness of temp.degree + 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@491.5--491.35) [101286]"}
                        HasDirectPerm(Mask, temp_1, degree);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@491.5--491.35) [101287]"}
                      FullPerm == Mask[temp_1, degree];
                    Heap := Heap[temp_1, degree:=Heap[temp_1, degree] + 1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(temp.child, null), write) -- BinomialHeap.vpr@492.5--492.35
                    
                    // -- Check definedness of acc(heapseg(temp.child, null), write)
                      assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@492.5--492.35) [101288]"}
                        HasDirectPerm(Mask, temp_1, child);
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (Heap[temp_1, child] != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access tree(temp.child) (BinomialHeap.vpr@492.5--492.35) [101289]"}
                          perm <= Mask[null, tree(Heap[temp_1, child])];
                      }
                      Mask := Mask[null, tree(Heap[temp_1, child]):=Mask[null, tree(Heap[temp_1, child])] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)], tree(Heap[temp_1, child]), Heap[null, tree(Heap[temp_1, child])]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access temp.child.sibling (BinomialHeap.vpr@492.5--492.35) [101290]"}
                          perm <= Mask[Heap[temp_1, child], sibling];
                      }
                      Mask := Mask[Heap[temp_1, child], sibling:=Mask[Heap[temp_1, child], sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. There might be insufficient permission to access heapseg(temp.child.sibling, null) (BinomialHeap.vpr@492.5--492.35) [101291]"}
                          perm <= Mask[null, heapseg(Heap[Heap[temp_1, child], sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[Heap[temp_1, child], sibling], null):=Mask[null, heapseg(Heap[Heap[temp_1, child], sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)], heapseg(Heap[Heap[temp_1, child], sibling], null), Heap[null, heapseg(Heap[Heap[temp_1, child], sibling], null)]);
                      if (Heap[Heap[temp_1, child], sibling] != null) {
                        assert {:msg "  Folding heapseg(temp.child, null) might fail. Assertion treeParent(temp.child) == segParent(temp.child.sibling, null) might not hold. (BinomialHeap.vpr@492.5--492.35) [101292]"}
                          treeParent(Heap, Heap[temp_1, child]) == segParent(Heap, Heap[Heap[temp_1, child], sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(Heap[temp_1, child], null));
                    assume Heap[null, heapseg(Heap[temp_1, child], null)] == FrameFragment((if Heap[temp_1, child] != null then CombineFrames(Heap[null, tree(Heap[temp_1, child])], CombineFrames(FrameFragment(Heap[Heap[temp_1, child], sibling]), CombineFrames(Heap[null, heapseg(Heap[Heap[temp_1, child], sibling], null)], FrameFragment((if Heap[Heap[temp_1, child], sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(Heap[temp_1, child], null))) {
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(Heap[temp_1, child], null):=freshVersion];
                    }
                    if (Heap[temp_1, child] != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_156: Ref, f_157: (Field A B) ::
                        { newPMask[o_156, f_157] }
                        Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_156, f_157] || Heap[null, tree#sm(Heap[temp_1, child])][o_156, f_157] ==> newPMask[o_156, f_157]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=newPMask];
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=Heap[null, heapseg#sm(Heap[temp_1, child], null)][Heap[temp_1, child], sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_157: Ref, f_158: (Field A B) ::
                        { newPMask[o_157, f_158] }
                        Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_157, f_158] || Heap[null, heapseg#sm(Heap[Heap[temp_1, child], sibling], null)][o_157, f_158] ==> newPMask[o_157, f_158]
                      );
                      Heap := Heap[null, heapseg#sm(Heap[temp_1, child], null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(temp), write) -- BinomialHeap.vpr@493.5--493.20
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.key (BinomialHeap.vpr@493.5--493.20) [101293]"}
                        perm <= Mask[temp_1, key];
                    }
                    Mask := Mask[temp_1, key:=Mask[temp_1, key] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@493.5--493.20) [101294]"}
                        perm <= Mask[temp_1, degree];
                    }
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@493.5--493.20) [101295]"}
                        perm <= Mask[temp_1, child];
                    }
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@493.5--493.20) [101296]"}
                        perm <= Mask[temp_1, parent];
                    }
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] - perm];
                    assert {:msg "  Folding tree(temp) might fail. Assertion 0 <= temp.degree might not hold. (BinomialHeap.vpr@493.5--493.20) [101297]"}
                      0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access heapseg(temp.child, null) (BinomialHeap.vpr@493.5--493.20) [101298]"}
                        perm <= Mask[null, heapseg(Heap[temp_1, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree(temp_1), Heap[null, tree(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assert {:msg "  Folding tree(temp) might fail. Assertion temp.degree == segLength(temp.child, null) might not hold. (BinomialHeap.vpr@493.5--493.20) [101299]"}
                      Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segDegree(temp.child, null, 0) == temp.degree - 1 might not hold. (BinomialHeap.vpr@493.5--493.20) [101300]"}
                        segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assert {:msg "  Folding tree(temp) might fail. Assertion validChildren(temp.child, null) might not hold. (BinomialHeap.vpr@493.5--493.20) [101301]"}
                      validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segParent(temp.child, null) == temp might not hold. (BinomialHeap.vpr@493.5--493.20) [101302]"}
                        segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree(temp_1));
                    assume Heap[null, tree(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree(temp_1))) {
                      Heap := Heap[null, tree#sm(temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree(temp_1):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, key:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, child:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_158: Ref, f_159: (Field A B) ::
                      { newPMask[o_158, f_159] }
                      Heap[null, tree#sm(temp_1)][o_158, f_159] || Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_158, f_159] ==> newPMask[o_158, f_159]
                    );
                    Heap := Heap[null, tree#sm(temp_1):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: if (prevTemp == null) -- BinomialHeap.vpr@495.5--499.6
                    if (prevTemp == null) {
                      
                      // -- Translating statement: this.Nodes := nextTemp -- BinomialHeap.vpr@496.6--496.28
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@496.6--496.28) [101303]"}
                          FullPerm == Mask[this, Nodes];
                        Heap := Heap[this, Nodes:=nextTemp];
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: prevTemp.sibling := nextTemp -- BinomialHeap.vpr@498.6--498.34
                        assert {:msg "  Assignment might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@498.6--498.34) [101304]"}
                          FullPerm == Mask[prevTemp, sibling];
                        Heap := Heap[prevTemp, sibling:=nextTemp];
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@500.5--500.22
                    assume tree#trigger(Heap, tree(temp_1));
                    assume Heap[null, tree(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@500.5--500.22) [101305]"}
                        perm <= Mask[null, tree(temp_1)];
                    }
                    Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree(temp_1))) {
                        havoc newVersion;
                        Heap := Heap[null, tree(temp_1):=newVersion];
                      }
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, key:=Mask[temp_1, key] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume temp_1 != null;
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree(temp_1), Heap[null, tree(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.parent := nextTemp -- BinomialHeap.vpr@501.5--501.28
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@501.5--501.28) [101306]"}
                      FullPerm == Mask[temp_1, parent];
                    Heap := Heap[temp_1, parent:=nextTemp];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(temp), write) -- BinomialHeap.vpr@502.5--502.20
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.key (BinomialHeap.vpr@502.5--502.20) [101307]"}
                        perm <= Mask[temp_1, key];
                    }
                    Mask := Mask[temp_1, key:=Mask[temp_1, key] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@502.5--502.20) [101308]"}
                        perm <= Mask[temp_1, degree];
                    }
                    Mask := Mask[temp_1, degree:=Mask[temp_1, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@502.5--502.20) [101309]"}
                        perm <= Mask[temp_1, child];
                    }
                    Mask := Mask[temp_1, child:=Mask[temp_1, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@502.5--502.20) [101310]"}
                        perm <= Mask[temp_1, parent];
                    }
                    Mask := Mask[temp_1, parent:=Mask[temp_1, parent] - perm];
                    assert {:msg "  Folding tree(temp) might fail. Assertion 0 <= temp.degree might not hold. (BinomialHeap.vpr@502.5--502.20) [101311]"}
                      0 <= Heap[temp_1, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access heapseg(temp.child, null) (BinomialHeap.vpr@502.5--502.20) [101312]"}
                        perm <= Mask[null, heapseg(Heap[temp_1, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree(temp_1), Heap[null, tree(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                    assert {:msg "  Folding tree(temp) might fail. Assertion temp.degree == segLength(temp.child, null) might not hold. (BinomialHeap.vpr@502.5--502.20) [101313]"}
                      Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                    if (0 < Heap[temp_1, degree]) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segDegree(temp.child, null, 0) == temp.degree - 1 might not hold. (BinomialHeap.vpr@502.5--502.20) [101314]"}
                        segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                    }
                    assert {:msg "  Folding tree(temp) might fail. Assertion validChildren(temp.child, null) might not hold. (BinomialHeap.vpr@502.5--502.20) [101315]"}
                      validChildren(Heap, Heap[temp_1, child], null);
                    if (Heap[temp_1, child] != null) {
                      assert {:msg "  Folding tree(temp) might fail. Assertion segParent(temp.child, null) == temp might not hold. (BinomialHeap.vpr@502.5--502.20) [101316]"}
                        segParent(Heap, Heap[temp_1, child], null) == temp_1;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree(temp_1));
                    assume Heap[null, tree(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree(temp_1))) {
                      Heap := Heap[null, tree#sm(temp_1):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree(temp_1):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, key:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, degree:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, child:=true]];
                    Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_159: Ref, f_160: (Field A B) ::
                      { newPMask[o_159, f_160] }
                      Heap[null, tree#sm(temp_1)][o_159, f_160] || Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_159, f_160] ==> newPMask[o_159, f_160]
                    );
                    Heap := Heap[null, tree#sm(temp_1):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unfold acc(tree(nextTemp), write) -- BinomialHeap.vpr@503.5--503.26
                    assume tree#trigger(Heap, tree(nextTemp));
                    assume Heap[null, tree(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding tree(nextTemp) might fail. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@503.5--503.26) [101317]"}
                        perm <= Mask[null, tree(nextTemp)];
                    }
                    Mask := Mask[null, tree(nextTemp):=Mask[null, tree(nextTemp)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, tree(nextTemp))) {
                        havoc newVersion;
                        Heap := Heap[null, tree(nextTemp):=newVersion];
                      }
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, key:=Mask[nextTemp, key] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] + perm];
                    assume state(Heap, Mask);
                    perm := FullPerm;
                    assume nextTemp != null;
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] + perm];
                    assume state(Heap, Mask);
                    assume 0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(tree(nextTemp), Heap[null, tree(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assume state(Heap, Mask);
                      assume segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assume state(Heap, Mask);
                    assume validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp.sibling := nextTemp.child -- BinomialHeap.vpr@504.5--504.35
                    
                    // -- Check definedness of nextTemp.child
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@504.5--504.35) [101318]"}
                        HasDirectPerm(Mask, nextTemp, child);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@504.5--504.35) [101319]"}
                      FullPerm == Mask[temp_1, sibling];
                    Heap := Heap[temp_1, sibling:=Heap[nextTemp, child]];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@505.5--505.29
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (temp_1 != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@505.5--505.29) [101320]"}
                          perm <= Mask[null, tree(temp_1)];
                      }
                      Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree(temp_1), Heap[null, tree(temp_1)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@505.5--505.29) [101321]"}
                          perm <= Mask[temp_1, sibling];
                      }
                      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp.sibling, null) (BinomialHeap.vpr@505.5--505.29) [101322]"}
                          perm <= Mask[null, heapseg(Heap[temp_1, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                      if (Heap[temp_1, sibling] != null) {
                        assert {:msg "  Folding heapseg(temp, null) might fail. Assertion treeParent(temp) == segParent(temp.sibling, null) might not hold. (BinomialHeap.vpr@505.5--505.29) [101323]"}
                          treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(temp_1, null));
                    assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                      Heap := Heap[null, heapseg#sm(temp_1, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(temp_1, null):=freshVersion];
                    }
                    if (temp_1 != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_160: Ref, f_161: (Field A B) ::
                        { newPMask[o_160, f_161] }
                        Heap[null, heapseg#sm(temp_1, null)][o_160, f_161] || Heap[null, tree#sm(temp_1)][o_160, f_161] ==> newPMask[o_160, f_161]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(temp_1, null):=Heap[null, heapseg#sm(temp_1, null)][temp_1, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_161: Ref, f_162: (Field A B) ::
                        { newPMask[o_161, f_162] }
                        Heap[null, heapseg#sm(temp_1, null)][o_161, f_162] || Heap[null, heapseg#sm(Heap[temp_1, sibling], null)][o_161, f_162] ==> newPMask[o_161, f_162]
                      );
                      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.child := temp -- BinomialHeap.vpr@506.5--506.27
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@506.5--506.27) [101324]"}
                      FullPerm == Mask[nextTemp, child];
                    Heap := Heap[nextTemp, child:=temp_1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: nextTemp.degree := nextTemp.degree + 1 -- BinomialHeap.vpr@507.5--507.43
                    
                    // -- Check definedness of nextTemp.degree + 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@507.5--507.43) [101325]"}
                        HasDirectPerm(Mask, nextTemp, degree);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@507.5--507.43) [101326]"}
                      FullPerm == Mask[nextTemp, degree];
                    Heap := Heap[nextTemp, degree:=Heap[nextTemp, degree] + 1];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: fold acc(tree(nextTemp), write) -- BinomialHeap.vpr@508.5--508.24
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.key (BinomialHeap.vpr@508.5--508.24) [101327]"}
                        perm <= Mask[nextTemp, key];
                    }
                    Mask := Mask[nextTemp, key:=Mask[nextTemp, key] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.degree (BinomialHeap.vpr@508.5--508.24) [101328]"}
                        perm <= Mask[nextTemp, degree];
                    }
                    Mask := Mask[nextTemp, degree:=Mask[nextTemp, degree] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.child (BinomialHeap.vpr@508.5--508.24) [101329]"}
                        perm <= Mask[nextTemp, child];
                    }
                    Mask := Mask[nextTemp, child:=Mask[nextTemp, child] - perm];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access nextTemp.parent (BinomialHeap.vpr@508.5--508.24) [101330]"}
                        perm <= Mask[nextTemp, parent];
                    }
                    Mask := Mask[nextTemp, parent:=Mask[nextTemp, parent] - perm];
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion 0 <= nextTemp.degree might not hold. (BinomialHeap.vpr@508.5--508.24) [101331]"}
                      0 <= Heap[nextTemp, degree];
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Folding tree(nextTemp) might fail. There might be insufficient permission to access heapseg(nextTemp.child, null) (BinomialHeap.vpr@508.5--508.24) [101332]"}
                        perm <= Mask[null, heapseg(Heap[nextTemp, child], null)];
                    }
                    Mask := Mask[null, heapseg(Heap[nextTemp, child], null):=Mask[null, heapseg(Heap[nextTemp, child], null)] - perm];
                    
                    // -- Record predicate instance information
                      assume InsidePredicate(tree(nextTemp), Heap[null, tree(nextTemp)], heapseg(Heap[nextTemp, child], null), Heap[null, heapseg(Heap[nextTemp, child], null)]);
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion nextTemp.degree == segLength(nextTemp.child, null) might not hold. (BinomialHeap.vpr@508.5--508.24) [101333]"}
                      Heap[nextTemp, degree] == segLength(Heap, Heap[nextTemp, child], null);
                    if (0 < Heap[nextTemp, degree]) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segDegree(nextTemp.child, null, 0) == nextTemp.degree - 1 might not hold. (BinomialHeap.vpr@508.5--508.24) [101334]"}
                        segDegree(Heap, Heap[nextTemp, child], null, 0) == Heap[nextTemp, degree] - 1;
                    }
                    assert {:msg "  Folding tree(nextTemp) might fail. Assertion validChildren(nextTemp.child, null) might not hold. (BinomialHeap.vpr@508.5--508.24) [101335]"}
                      validChildren(Heap, Heap[nextTemp, child], null);
                    if (Heap[nextTemp, child] != null) {
                      assert {:msg "  Folding tree(nextTemp) might fail. Assertion segParent(nextTemp.child, null) == nextTemp might not hold. (BinomialHeap.vpr@508.5--508.24) [101336]"}
                        segParent(Heap, Heap[nextTemp, child], null) == nextTemp;
                    }
                    perm := FullPerm;
                    Mask := Mask[null, tree(nextTemp):=Mask[null, tree(nextTemp)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume tree#trigger(Heap, tree(nextTemp));
                    assume Heap[null, tree(nextTemp)] == CombineFrames(FrameFragment(Heap[nextTemp, key]), CombineFrames(FrameFragment(Heap[nextTemp, degree]), CombineFrames(FrameFragment(Heap[nextTemp, child]), CombineFrames(FrameFragment(Heap[nextTemp, parent]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, child], null)], CombineFrames(FrameFragment((if 0 < Heap[nextTemp, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[nextTemp, child] != null then EmptyFrame else EmptyFrame))))))));
                    if (!HasDirectPerm(Mask, null, tree(nextTemp))) {
                      Heap := Heap[null, tree#sm(nextTemp):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, tree(nextTemp):=freshVersion];
                    }
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, key:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, degree:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, child:=true]];
                    Heap := Heap[null, tree#sm(nextTemp):=Heap[null, tree#sm(nextTemp)][nextTemp, parent:=true]];
                    havoc newPMask;
                    assume (forall <A, B> o_162: Ref, f_163: (Field A B) ::
                      { newPMask[o_162, f_163] }
                      Heap[null, tree#sm(nextTemp)][o_162, f_163] || Heap[null, heapseg#sm(Heap[nextTemp, child], null)][o_162, f_163] ==> newPMask[o_162, f_163]
                    );
                    Heap := Heap[null, tree#sm(nextTemp):=newPMask];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp := nextTemp -- BinomialHeap.vpr@510.5--510.21
                    temp_1 := nextTemp;
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
          
          // -- Translating statement: nextTemp := temp.sibling -- BinomialHeap.vpr@514.3--514.27
            
            // -- Check definedness of temp.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@514.3--514.27) [101337]"}
                HasDirectPerm(Mask, temp_1, sibling);
            nextTemp := Heap[temp_1, sibling];
            assume state(Heap, Mask);
        // Exhale invariant
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(this.Nodes, write) might not be preserved. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@441.13--441.28) [101338]"}
            perm <= Mask[this, Nodes];
        }
        Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not be preserved. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@442.13--442.95) [101339]"}
              perm <= Mask[null, heapseg(Heap[this, Nodes], prevTemp)];
          }
          Mask := Mask[null, heapseg(Heap[this, Nodes], prevTemp):=Mask[null, heapseg(Heap[this, Nodes], prevTemp)] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(this.Nodes, prevTemp), write) && sorted(this.Nodes, prevTemp) might not be preserved. Assertion sorted(this.Nodes, prevTemp) might not hold. (BinomialHeap.vpr@442.13--442.95) [101340]"}
            sorted(Heap, Heap[this, Nodes], prevTemp);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> this.Nodes == temp might not be preserved. Assertion this.Nodes == temp might not hold. (BinomialHeap.vpr@443.13--443.52) [101341]"}
            Heap[this, Nodes] == temp_1;
        }
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not be preserved. There might be insufficient permission to access heapseg(nextTemp, null) (BinomialHeap.vpr@444.13--444.65) [101342]"}
            perm <= Mask[null, heapseg(nextTemp, null)];
        }
        Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] - perm];
        assert {:msg "  Loop invariant acc(heapseg(nextTemp, null), write) && presorted(nextTemp, null) might not be preserved. Assertion presorted(nextTemp, null) might not hold. (BinomialHeap.vpr@444.13--444.65) [101343]"}
          presorted(Heap, nextTemp, null);
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@445.13--447.48) [101344]"}
            perm <= Mask[null, tree(temp_1)];
        }
        Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@445.13--447.48) [101345]"}
            perm <= Mask[temp_1, sibling];
        }
        Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
        assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. Assertion temp.sibling == nextTemp might not hold. (BinomialHeap.vpr@445.13--447.48) [101346]"}
          Heap[temp_1, sibling] == nextTemp;
        if (nextTemp != null) {
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. Assertion treeDegree(temp) <= segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@445.13--447.48) [101347]"}
            treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
          assert {:msg "  Loop invariant acc(tree(temp), write) && (acc(temp.sibling, write) && (temp.sibling == nextTemp && (nextTemp != null ==> treeDegree(temp) <= segDegree(nextTemp, null, 0) && treeParent(temp) == segParent(nextTemp, null)))) might not be preserved. Assertion treeParent(temp) == segParent(nextTemp, null) might not hold. (BinomialHeap.vpr@445.13--447.48) [101348]"}
            treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
        }
        if (prevTemp != null) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@448.13--450.42) [101349]"}
              perm <= Mask[null, tree(prevTemp)];
          }
          Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@448.13--450.42) [101350]"}
              perm <= Mask[prevTemp, sibling];
          }
          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@448.13--450.42) [101351]"}
            Heap[prevTemp, sibling] == temp_1;
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. Assertion treeDegree(prevTemp) <= treeDegree(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [101352]"}
            treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
          assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && (prevTemp.sibling == temp && (treeDegree(prevTemp) <= treeDegree(temp) && treeParent(prevTemp) == treeParent(temp)))) might not be preserved. Assertion treeParent(prevTemp) == treeParent(temp) might not hold. (BinomialHeap.vpr@448.13--450.42) [101353]"}
            treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
        }
        if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
          assert {:msg "  Loop invariant prevTemp != null && (0 < segLength(this.Nodes, prevTemp) && (2 <= segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && segDegree(nextTemp, null, 0) == segDegree(nextTemp, null, 1)))) ==> treeDegree(prevTemp) < treeDegree(temp) might not be preserved. Assertion treeDegree(prevTemp) < treeDegree(temp) might not hold. (BinomialHeap.vpr@451.13--454.41) [101354]"}
            treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
        }
        if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not be preserved. Assertion 0 < segLength(nextTemp, null) might not hold. (BinomialHeap.vpr@455.13--458.98) [101355]"}
            0 < segLength(Heap, nextTemp, null);
          assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not be preserved. Assertion treeDegree(temp) == segDegree(nextTemp, null, 0) might not hold. (BinomialHeap.vpr@455.13--458.98) [101356]"}
            treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
          if (2 <= segLength(Heap, nextTemp, null)) {
            assert {:msg "  Loop invariant prevTemp != null && treeDegree(prevTemp) == treeDegree(temp) ==> 0 < segLength(nextTemp, null) && (treeDegree(temp) == segDegree(nextTemp, null, 0) && (2 <= segLength(nextTemp, null) ==> segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1))) might not be preserved. Assertion segDegree(nextTemp, null, 0) < segDegree(nextTemp, null, 1) might not hold. (BinomialHeap.vpr@455.13--458.98) [101357]"}
              segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
          }
        }
        if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes], prevTemp)) {
          assert {:msg "  Loop invariant prevTemp != null && 0 < segLength(this.Nodes, prevTemp) ==> segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not be preserved. Assertion segDegree(this.Nodes, prevTemp, segLength(this.Nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@459.13--461.93) [101358]"}
            segDegree(Heap, Heap[this, Nodes], prevTemp, segLength(Heap, Heap[this, Nodes], prevTemp) - 1) < treeDegree(Heap, prevTemp);
        }
        if (prevTemp != null) {
          assert {:msg "  Loop invariant prevTemp != null ==> segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion segSize(this.Nodes, prevTemp) + treeSize(prevTemp) + treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@462.13--463.159) [101359]"}
            segSize(Heap, Heap[this, Nodes], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp == null) {
          assert {:msg "  Loop invariant prevTemp == null ==> treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not be preserved. Assertion treeSize(temp) + segSize(nextTemp, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@464.13--465.106) [101360]"}
            treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
        }
        if (prevTemp != null && Heap[this, Nodes] != prevTemp) {
          assert {:msg "  Loop invariant prevTemp != null && this.Nodes != prevTemp ==> segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not be preserved. Assertion segParent(this.Nodes, prevTemp) == treeParent(prevTemp) might not hold. (BinomialHeap.vpr@466.13--466.115) [101361]"}
            segParent(Heap, Heap[this, Nodes], prevTemp) == treeParent(Heap, prevTemp);
        }
        assert {:msg "  Loop invariant treeParent(temp) == old(segParent(this.Nodes, null)) might not be preserved. Assertion treeParent(temp) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@467.13--467.65) [101362]"}
          treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes], null);
        // Finish exhale
        havoc ExhaleHeap;
        assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
        Heap := ExhaleHeap;
        // Terminate execution
        assume false;
      }
    
    // -- Inhale loop invariant after loop, and assume guard
      assume !(nextTemp != null);
      assume state(Heap, Mask);
      perm := FullPerm;
      assume this != null;
      Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
      assume state(Heap, Mask);
      if (prevTemp != null) {
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[this, Nodes], prevTemp):=Mask[null, heapseg(Heap[this, Nodes], prevTemp)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume sorted(Heap, Heap[this, Nodes], prevTemp);
      }
      if (prevTemp == null) {
        assume Heap[this, Nodes] == temp_1;
      }
      perm := FullPerm;
      Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume presorted(Heap, nextTemp, null);
      perm := FullPerm;
      Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
      assume state(Heap, Mask);
      perm := FullPerm;
      assume temp_1 != null;
      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
      assume state(Heap, Mask);
      assume Heap[temp_1, sibling] == nextTemp;
      if (nextTemp != null) {
        assume state(Heap, Mask);
        assume treeDegree(Heap, temp_1) <= segDegree(Heap, nextTemp, null, 0);
        assume state(Heap, Mask);
        assume treeParent(Heap, temp_1) == segParent(Heap, nextTemp, null);
      }
      if (prevTemp != null) {
        perm := FullPerm;
        Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume prevTemp != null;
        Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
        assume state(Heap, Mask);
        assume Heap[prevTemp, sibling] == temp_1;
        assume state(Heap, Mask);
        assume treeDegree(Heap, prevTemp) <= treeDegree(Heap, temp_1);
        assume state(Heap, Mask);
        assume treeParent(Heap, prevTemp) == treeParent(Heap, temp_1);
      }
      if (prevTemp != null && (0 < segLength(Heap, Heap[this, Nodes], prevTemp) && (2 <= segLength(Heap, nextTemp, null) && (treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0) && segDegree(Heap, nextTemp, null, 0) == segDegree(Heap, nextTemp, null, 1))))) {
        assume state(Heap, Mask);
        assume treeDegree(Heap, prevTemp) < treeDegree(Heap, temp_1);
      }
      if (prevTemp != null && treeDegree(Heap, prevTemp) == treeDegree(Heap, temp_1)) {
        assume state(Heap, Mask);
        assume 0 < segLength(Heap, nextTemp, null);
        assume state(Heap, Mask);
        assume treeDegree(Heap, temp_1) == segDegree(Heap, nextTemp, null, 0);
        if (2 <= segLength(Heap, nextTemp, null)) {
          assume state(Heap, Mask);
          assume segDegree(Heap, nextTemp, null, 0) < segDegree(Heap, nextTemp, null, 1);
        }
      }
      if (prevTemp != null && 0 < segLength(Heap, Heap[this, Nodes], prevTemp)) {
        assume state(Heap, Mask);
        assume segDegree(Heap, Heap[this, Nodes], prevTemp, segLength(Heap, Heap[this, Nodes], prevTemp) - 1) < treeDegree(Heap, prevTemp);
      }
      if (prevTemp != null) {
        assume state(Heap, Mask);
        assume segSize(Heap, Heap[this, Nodes], prevTemp) + treeSize(Heap, prevTemp) + treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
      }
      if (prevTemp == null) {
        assume state(Heap, Mask);
        assume treeSize(Heap, temp_1) + segSize(Heap, nextTemp, null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
      }
      if (prevTemp != null && Heap[this, Nodes] != prevTemp) {
        assume state(Heap, Mask);
        assume segParent(Heap, Heap[this, Nodes], prevTemp) == treeParent(Heap, prevTemp);
      }
      assume state(Heap, Mask);
      assume treeParent(Heap, temp_1) == segParent(oldHeap, oldHeap[this, Nodes], null);
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(nextTemp, null), write) -- BinomialHeap.vpr@516.2--516.30
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (nextTemp != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. There might be insufficient permission to access tree(nextTemp) (BinomialHeap.vpr@516.2--516.30) [101365]"}
          perm <= Mask[null, tree(nextTemp)];
      }
      Mask := Mask[null, tree(nextTemp):=Mask[null, tree(nextTemp)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], tree(nextTemp), Heap[null, tree(nextTemp)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. There might be insufficient permission to access nextTemp.sibling (BinomialHeap.vpr@516.2--516.30) [101367]"}
          perm <= Mask[nextTemp, sibling];
      }
      Mask := Mask[nextTemp, sibling:=Mask[nextTemp, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. There might be insufficient permission to access heapseg(nextTemp.sibling, null) (BinomialHeap.vpr@516.2--516.30) [101369]"}
          perm <= Mask[null, heapseg(Heap[nextTemp, sibling], null)];
      }
      Mask := Mask[null, heapseg(Heap[nextTemp, sibling], null):=Mask[null, heapseg(Heap[nextTemp, sibling], null)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(nextTemp, null), Heap[null, heapseg(nextTemp, null)], heapseg(Heap[nextTemp, sibling], null), Heap[null, heapseg(Heap[nextTemp, sibling], null)]);
      if (Heap[nextTemp, sibling] != null) {
        assert {:msg "  Folding heapseg(nextTemp, null) might fail. Assertion treeParent(nextTemp) == segParent(nextTemp.sibling, null) might not hold. (BinomialHeap.vpr@516.2--516.30) [101370]"}
          treeParent(Heap, nextTemp) == segParent(Heap, Heap[nextTemp, sibling], null);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(nextTemp, null):=Mask[null, heapseg(nextTemp, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(nextTemp, null));
    assume Heap[null, heapseg(nextTemp, null)] == FrameFragment((if nextTemp != null then CombineFrames(Heap[null, tree(nextTemp)], CombineFrames(FrameFragment(Heap[nextTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[nextTemp, sibling], null)], FrameFragment((if Heap[nextTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(nextTemp, null))) {
      Heap := Heap[null, heapseg#sm(nextTemp, null):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(nextTemp, null):=freshVersion];
    }
    if (nextTemp != null) {
      havoc newPMask;
      assume (forall <A, B> o_163: Ref, f_164: (Field A B) ::
        { newPMask[o_163, f_164] }
        Heap[null, heapseg#sm(nextTemp, null)][o_163, f_164] || Heap[null, tree#sm(nextTemp)][o_163, f_164] ==> newPMask[o_163, f_164]
      );
      Heap := Heap[null, heapseg#sm(nextTemp, null):=newPMask];
      Heap := Heap[null, heapseg#sm(nextTemp, null):=Heap[null, heapseg#sm(nextTemp, null)][nextTemp, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_164: Ref, f_165: (Field A B) ::
        { newPMask[o_164, f_165] }
        Heap[null, heapseg#sm(nextTemp, null)][o_164, f_165] || Heap[null, heapseg#sm(Heap[nextTemp, sibling], null)][o_164, f_165] ==> newPMask[o_164, f_165]
      );
      Heap := Heap[null, heapseg#sm(nextTemp, null):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@517.2--517.26
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (temp_1 != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@517.2--517.26) [101374]"}
          perm <= Mask[null, tree(temp_1)];
      }
      Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree(temp_1), Heap[null, tree(temp_1)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@517.2--517.26) [101376]"}
          perm <= Mask[temp_1, sibling];
      }
      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp.sibling, null) (BinomialHeap.vpr@517.2--517.26) [101378]"}
          perm <= Mask[null, heapseg(Heap[temp_1, sibling], null)];
      }
      Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
      if (Heap[temp_1, sibling] != null) {
        assert {:msg "  Folding heapseg(temp, null) might fail. Assertion treeParent(temp) == segParent(temp.sibling, null) might not hold. (BinomialHeap.vpr@517.2--517.26) [101379]"}
          treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(temp_1, null));
    assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
      Heap := Heap[null, heapseg#sm(temp_1, null):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(temp_1, null):=freshVersion];
    }
    if (temp_1 != null) {
      havoc newPMask;
      assume (forall <A, B> o_165: Ref, f_166: (Field A B) ::
        { newPMask[o_165, f_166] }
        Heap[null, heapseg#sm(temp_1, null)][o_165, f_166] || Heap[null, tree#sm(temp_1)][o_165, f_166] ==> newPMask[o_165, f_166]
      );
      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
      Heap := Heap[null, heapseg#sm(temp_1, null):=Heap[null, heapseg#sm(temp_1, null)][temp_1, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_166: Ref, f_167: (Field A B) ::
        { newPMask[o_166, f_167] }
        Heap[null, heapseg#sm(temp_1, null)][o_166, f_167] || Heap[null, heapseg#sm(Heap[temp_1, sibling], null)][o_166, f_167] ==> newPMask[o_166, f_167]
      );
      Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heapseg(prevTemp, null), write) -- BinomialHeap.vpr@518.2--518.30
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    if (prevTemp != null) {
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@518.2--518.30) [101383]"}
          perm <= Mask[null, tree(prevTemp)];
      }
      Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], tree(prevTemp), Heap[null, tree(prevTemp)]);
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@518.2--518.30) [101385]"}
          perm <= Mask[prevTemp, sibling];
      }
      Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, null) (BinomialHeap.vpr@518.2--518.30) [101387]"}
          perm <= Mask[null, heapseg(Heap[prevTemp, sibling], null)];
      }
      Mask := Mask[null, heapseg(Heap[prevTemp, sibling], null):=Mask[null, heapseg(Heap[prevTemp, sibling], null)] - perm];
      
      // -- Record predicate instance information
        assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], heapseg(Heap[prevTemp, sibling], null), Heap[null, heapseg(Heap[prevTemp, sibling], null)]);
      if (Heap[prevTemp, sibling] != null) {
        assert {:msg "  Folding heapseg(prevTemp, null) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, null) might not hold. (BinomialHeap.vpr@518.2--518.30) [101388]"}
          treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], null);
      }
    }
    perm := FullPerm;
    Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heapseg#trigger(Heap, heapseg(prevTemp, null));
    assume Heap[null, heapseg(prevTemp, null)] == FrameFragment((if prevTemp != null then CombineFrames(Heap[null, tree(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], null)], FrameFragment((if Heap[prevTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
    if (!HasDirectPerm(Mask, null, heapseg(prevTemp, null))) {
      Heap := Heap[null, heapseg#sm(prevTemp, null):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heapseg(prevTemp, null):=freshVersion];
    }
    if (prevTemp != null) {
      havoc newPMask;
      assume (forall <A, B> o_167: Ref, f_168: (Field A B) ::
        { newPMask[o_167, f_168] }
        Heap[null, heapseg#sm(prevTemp, null)][o_167, f_168] || Heap[null, tree#sm(prevTemp)][o_167, f_168] ==> newPMask[o_167, f_168]
      );
      Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
      Heap := Heap[null, heapseg#sm(prevTemp, null):=Heap[null, heapseg#sm(prevTemp, null)][prevTemp, sibling:=true]];
      havoc newPMask;
      assume (forall <A, B> o_168: Ref, f_169: (Field A B) ::
        { newPMask[o_168, f_169] }
        Heap[null, heapseg#sm(prevTemp, null)][o_168, f_169] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], null)][o_168, f_169] ==> newPMask[o_168, f_169]
      );
      Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
    }
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: concat(this.Nodes, prevTemp, null) -- BinomialHeap.vpr@519.2--519.36
    PreCallHeap := Heap;
    PreCallMask := Mask;
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Method call might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@519.2--519.36) [101390]"}
        HasDirectPerm(Mask, this, Nodes);
    arg_a_1 := Heap[this, Nodes];
    
    // -- Exhaling precondition
      ExhaleWellDef0Heap := Heap;
      ExhaleWellDef0Mask := Mask;
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(this.Nodes, prevTemp) (BinomialHeap.vpr@519.2--519.36) [101391]"}
          perm <= Mask[null, heapseg(arg_a_1, prevTemp)];
      }
      Mask := Mask[null, heapseg(arg_a_1, prevTemp):=Mask[null, heapseg(arg_a_1, prevTemp)] - perm];
      perm := FullPerm;
      if (perm != NoPerm) {
        assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, null) (BinomialHeap.vpr@519.2--519.36) [101392]"}
          perm <= Mask[null, heapseg(prevTemp, null)];
      }
      Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] - perm];
      if (null != null) {
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@519.2--519.36) [101393]"}
            perm <= Mask[null, tree(null)];
        }
        Mask := Mask[null, tree(null):=Mask[null, tree(null)] - perm];
      }
      if (arg_a_1 != prevTemp && prevTemp != null) {
        assert {:msg "  The precondition of method concat might not hold. Assertion segParent(this.Nodes, prevTemp) == segParent(prevTemp, null) might not hold. (BinomialHeap.vpr@519.2--519.36) [101394]"}
          segParent(Heap, arg_a_1, prevTemp) == segParent(Heap, prevTemp, null);
      }
      // Finish exhale
      havoc ExhaleHeap;
      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
      Heap := ExhaleHeap;
    
    // -- Inhaling postcondition
      perm := FullPerm;
      Mask := Mask[null, heapseg(arg_a_1, null):=Mask[null, heapseg(arg_a_1, null)] + perm];
      assume state(Heap, Mask);
      assume state(Heap, Mask);
      assume segLength(Heap, arg_a_1, null) == segLength(PreCallHeap, arg_a_1, prevTemp) + segLength(PreCallHeap, prevTemp, null);
      assume state(Heap, Mask);
      assume (forall i_2_1: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_1, null)], arg_a_1, null, i_2_1) } { segDegree#frame(PreCallHeap[null, heapseg(arg_a_1, prevTemp)], arg_a_1, prevTemp, i_2_1) }
        0 <= i_2_1 && i_2_1 < segLength(PreCallHeap, arg_a_1, prevTemp) ==> segDegree(Heap, arg_a_1, null, i_2_1) == segDegree(PreCallHeap, arg_a_1, prevTemp, i_2_1)
      );
      assume state(Heap, Mask);
      assume (forall i_3: int ::
        { segDegree#frame(Heap[null, heapseg(arg_a_1, null)], arg_a_1, null, i_3) }
        segLength(PreCallHeap, arg_a_1, prevTemp) <= i_3 && i_3 < segLength(Heap, arg_a_1, null) ==> segDegree(Heap, arg_a_1, null, i_3) == segDegree(PreCallHeap, prevTemp, null, i_3 - segLength(PreCallHeap, arg_a_1, prevTemp))
      );
      if (null != null) {
        perm := FullPerm;
        Mask := Mask[null, tree(null):=Mask[null, tree(null)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume treeDegree(Heap, null) == treeDegree(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeSize(Heap, null) == treeSize(PreCallHeap, null);
        assume state(Heap, Mask);
        assume treeParent(Heap, null) == treeParent(PreCallHeap, null);
      }
      if (sorted(PreCallHeap, arg_a_1, prevTemp) && (sorted(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, arg_a_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))) {
        assume state(Heap, Mask);
        assume sorted(Heap, arg_a_1, null);
      }
      if (presorted(PreCallHeap, arg_a_1, prevTemp) && (presorted(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, arg_a_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, null, 0) && ((2 <= segLength(PreCallHeap, arg_a_1, prevTemp) && segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) == segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 2) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)) && (2 <= segLength(PreCallHeap, prevTemp, null) && segDegree(PreCallHeap, prevTemp, null, 0) == segDegree(PreCallHeap, prevTemp, null, 1) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))))) {
        assume state(Heap, Mask);
        assume presorted(Heap, arg_a_1, null);
      }
      if (validChildren(PreCallHeap, arg_a_1, prevTemp) && (validChildren(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, arg_a_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, arg_a_1, prevTemp, segLength(PreCallHeap, arg_a_1, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, null, 0) + 1))) {
        assume state(Heap, Mask);
        assume validChildren(Heap, arg_a_1, null);
      }
      assume state(Heap, Mask);
      assume segSize(Heap, arg_a_1, null) == segSize(PreCallHeap, arg_a_1, prevTemp) + segSize(PreCallHeap, prevTemp, null);
      if (arg_a_1 != prevTemp) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_1, null) == segParent(PreCallHeap, arg_a_1, prevTemp);
      }
      if (prevTemp != null) {
        assume state(Heap, Mask);
        assume segParent(Heap, arg_a_1, null) == segParent(PreCallHeap, prevTemp, null);
      }
      assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of unionNodes might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@424.10--425.54) [101395]"}
        perm <= Mask[this, Nodes];
    }
    Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of unionNodes might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@424.10--425.54) [101396]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] - perm];
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@424.10--425.54) [101397]"}
      sorted(Heap, Heap[this, Nodes], null);
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@426.10--426.28) [101398]"}
      Heap[this, Nodes] != null;
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion segSize(this.Nodes, null) == old(segSize(this.Nodes, null)) + old(segSize(binHeap, null)) might not hold. (BinomialHeap.vpr@427.10--427.99) [101399]"}
      segSize(Heap, Heap[this, Nodes], null) == segSize(oldHeap, oldHeap[this, Nodes], null) + segSize(oldHeap, binHeap, null);
    assert {:msg "  Postcondition of unionNodes might not hold. Assertion segParent(this.Nodes, null) == old(segParent(this.Nodes, null)) might not hold. (BinomialHeap.vpr@428.10--428.73) [101400]"}
      segParent(Heap, Heap[this, Nodes], null) == segParent(oldHeap, oldHeap[this, Nodes], null);
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}

// ==================================================
// Translation of method extractMin
// ==================================================

procedure extractMin(this: Ref) returns (res: Ref)
  modifies Heap, Mask;
{
  var perm: Perm;
  var oldHeap: HeapType;
  var oldMask: MaskType;
  var PostHeap: HeapType;
  var PostMask: MaskType;
  var nodes_1: Ref;
  var ExhaleWellDef0Heap: HeapType;
  var ExhaleWellDef0Mask: MaskType;
  var newVersion: FrameType;
  var temp_1: Ref;
  var prevTemp: Ref;
  var minNode: Ref;
  var fakeNode: Ref;
  var r_1: Ref;
  var PreCallHeap: HeapType;
  var PreCallMask: MaskType;
  var ExhaleHeap: HeapType;
  var UnfoldingHeap: HeapType;
  var UnfoldingMask: MaskType;
  var loopHeap: HeapType;
  var loopMask: MaskType;
  var freshVersion: FrameType;
  var newPMask: PMaskType;
  var oldTreeSize: int;
  
  // -- Initializing the state
    Mask := ZeroMask;
    assume state(Heap, Mask);
    assume AssumeFunctionsAbove == -1;
    assume AssumePermUpperBound;
  
  // -- Assumptions about method arguments
    assume Heap[this, $allocated];
  
  // -- Checked inhaling of precondition
    perm := FullPerm;
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Initializing of old state
    
    // -- Initializing the old state
      oldHeap := Heap;
      oldMask := Mask;
  if (*) {
    havoc PostHeap;
    PostMask := ZeroMask;
    assume state(PostHeap, PostMask);
    // Checked inhaling of postcondition to check definedness
    perm := FullPerm;
    PostMask := PostMask[null, heap_1(this):=PostMask[null, heap_1(this)] + perm];
    assume state(PostHeap, PostMask);
    assume state(PostHeap, PostMask);
    // Stop execution
    assume false;
  }
  
  // -- Assumptions about local variables
    assume Heap[nodes_1, $allocated];
  
  // -- Translating statement: unfold acc(heap(this), write) -- BinomialHeap.vpr@532.2--532.19
    assume heap#trigger(Heap, heap_1(this));
    assume Heap[null, heap_1(this)] == CombineFrames(FrameFragment(Heap[this, Nodes]), CombineFrames(Heap[null, heapseg(Heap[this, Nodes], null)], CombineFrames(FrameFragment((if Heap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(Heap[this, size]))));
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Unfolding heap(this) might fail. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@532.2--532.19) [101403]"}
        perm <= Mask[null, heap_1(this)];
    }
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] - perm];
    
    // -- Update version of predicate
      if (!HasDirectPerm(Mask, null, heap_1(this))) {
        havoc newVersion;
        Heap := Heap[null, heap_1(this):=newVersion];
      }
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
    assume state(Heap, Mask);
    perm := FullPerm;
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] + perm];
    
    // -- Extra unfolding of predicate
      assume InsidePredicate(heap_1(this), Heap[null, heap_1(this)], heapseg(Heap[this, Nodes], null), Heap[null, heapseg(Heap[this, Nodes], null)]);
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume sorted(Heap, Heap[this, Nodes], null);
    if (Heap[this, Nodes] != null) {
      assume state(Heap, Mask);
      assume segParent(Heap, Heap[this, Nodes], null) == null;
    }
    perm := FullPerm;
    assume this != null;
    Mask := Mask[this, size:=Mask[this, size] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume Heap[this, size] == segSize(Heap, Heap[this, Nodes], null);
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Translating statement: nodes := this.Nodes -- BinomialHeap.vpr@533.2--533.30
    
    // -- Check definedness of this.Nodes
      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@533.2--533.30) [101407]"}
        HasDirectPerm(Mask, this, Nodes);
    nodes_1 := Heap[this, Nodes];
    assume state(Heap, Mask);
  
  // -- Translating statement: if (nodes == null) -- BinomialHeap.vpr@534.2--639.3
    if (nodes_1 == null) {
      
      // -- Translating statement: res := null -- BinomialHeap.vpr@535.3--535.14
        res := null;
        assume state(Heap, Mask);
    } else {
      
      // -- Assumptions about local variables
        assume Heap[temp_1, $allocated];
        assume Heap[prevTemp, $allocated];
        assume Heap[minNode, $allocated];
        assume Heap[fakeNode, $allocated];
        assume Heap[r_1, $allocated];
      
      // -- Translating statement: temp := nodes -- BinomialHeap.vpr@537.3--537.25
        temp_1 := nodes_1;
        assume state(Heap, Mask);
      
      // -- Translating statement: prevTemp := null -- BinomialHeap.vpr@538.3--538.28
        prevTemp := null;
        assume state(Heap, Mask);
      
      // -- Translating statement: minNode := findMinNode(nodes) -- BinomialHeap.vpr@540.3--540.32
        PreCallHeap := Heap;
        PreCallMask := Mask;
        
        // -- Exhaling precondition
          ExhaleWellDef0Heap := Heap;
          ExhaleWellDef0Mask := Mask;
          assert {:msg "  The precondition of method findMinNode might not hold. Assertion nodes != null might not hold. (BinomialHeap.vpr@540.3--540.32) [101408]"}
            nodes_1 != null;
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  The precondition of method findMinNode might not hold. There might be insufficient permission to access heapseg(nodes, null) (BinomialHeap.vpr@540.3--540.32) [101409]"}
              perm <= Mask[null, heapseg(nodes_1, null)];
          }
          Mask := Mask[null, heapseg(nodes_1, null):=Mask[null, heapseg(nodes_1, null)] - perm];
          assert {:msg "  The precondition of method findMinNode might not hold. Assertion sorted(nodes, null) might not hold. (BinomialHeap.vpr@540.3--540.32) [101410]"}
            sorted(Heap, nodes_1, null);
          // Finish exhale
          havoc ExhaleHeap;
          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
          Heap := ExhaleHeap;
        
        // -- Havocing target variables
          havoc minNode;
        
        // -- Inhaling postcondition
          assume minNode != null;
          perm := FullPerm;
          Mask := Mask[null, heapseg(nodes_1, minNode):=Mask[null, heapseg(nodes_1, minNode)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted(Heap, nodes_1, minNode);
          perm := FullPerm;
          Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume sorted(Heap, minNode, null);
          if (nodes_1 != minNode) {
            assume state(Heap, Mask);
            assume segDegree(Heap, nodes_1, minNode, segLength(Heap, nodes_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
          }
          assume state(Heap, Mask);
          assume segSize(Heap, nodes_1, minNode) + segSize(Heap, minNode, null) == segSize(PreCallHeap, nodes_1, null);
          if (nodes_1 != minNode) {
            assume state(Heap, Mask);
            assume segParent(Heap, nodes_1, minNode) == segParent(PreCallHeap, nodes_1, null);
          }
          assume state(Heap, Mask);
          assume segParent(Heap, minNode, null) == segParent(PreCallHeap, nodes_1, null);
          assume state(Heap, Mask);
        assume Heap[minNode, $allocated];
        assume state(Heap, Mask);
      
      // -- Translating statement: if (minNode == nodes) -- BinomialHeap.vpr@543.3--582.4
        if (minNode == nodes_1) {
          
          // -- Translating statement: unfold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@544.4--544.30
            assume heapseg#trigger(Heap, heapseg(temp_1, null));
            assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@544.4--544.30) [101413]"}
                perm <= Mask[null, heapseg(temp_1, null)];
            }
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(temp_1, null):=newVersion];
              }
            if (temp_1 != null) {
              perm := FullPerm;
              Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree(temp_1), Heap[null, tree(temp_1)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume temp_1 != null;
              Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[temp_1, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: this.Nodes := temp.sibling -- BinomialHeap.vpr@545.4--545.30
            
            // -- Check definedness of temp.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@545.4--545.30) [101417]"}
                HasDirectPerm(Mask, temp_1, sibling);
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@545.4--545.30) [101418]"}
              FullPerm == Mask[this, Nodes];
            Heap := Heap[this, Nodes:=Heap[temp_1, sibling]];
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: while (temp != minNode) -- BinomialHeap.vpr@547.4--576.5
            
            // -- Before loop head
              
              // -- Exhale loop invariant before loop
                
                // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp != null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [101419]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                
                // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp == null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [101420]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not hold on entry. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@548.15--548.62) [101421]"}
                    perm <= Mask[null, heapseg(temp_1, minNode)];
                }
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not hold on entry. Assertion sorted(temp, minNode) might not hold. (BinomialHeap.vpr@548.15--548.62) [101422]"}
                  sorted(Heap, temp_1, minNode);
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not hold on entry. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@549.15--549.62) [101423]"}
                    perm <= Mask[null, heapseg(minNode, null)];
                }
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not hold on entry. Assertion sorted(minNode, null) might not hold. (BinomialHeap.vpr@549.15--549.62) [101424]"}
                  sorted(Heap, minNode, null);
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> temp == nodes might not hold on entry. Assertion temp == nodes might not hold. (BinomialHeap.vpr@550.15--550.49) [101425]"}
                    temp_1 == nodes_1;
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not hold on entry. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@551.15--551.87) [101426]"}
                      perm <= Mask[null, heapseg(nodes_1, prevTemp)];
                  }
                  Mask := Mask[null, heapseg(nodes_1, prevTemp):=Mask[null, heapseg(nodes_1, prevTemp)] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not hold on entry. Assertion sorted(nodes, prevTemp) might not hold. (BinomialHeap.vpr@551.15--551.87) [101427]"}
                    sorted(Heap, nodes_1, prevTemp);
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not hold on entry. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@552.15--552.103) [101428]"}
                      perm <= Mask[null, tree(prevTemp)];
                  }
                  Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not hold on entry. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@552.15--552.103) [101429]"}
                      perm <= Mask[prevTemp, sibling];
                  }
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not hold on entry. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@552.15--552.103) [101430]"}
                    Heap[prevTemp, sibling] == temp_1;
                }
                if (prevTemp != null && prevTemp != nodes_1) {
                  assert {:msg "  Loop invariant prevTemp != null && prevTemp != nodes ==> segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold on entry. Assertion segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@553.15--553.138) [101431]"}
                    segDegree(Heap, nodes_1, prevTemp, segLength(Heap, nodes_1, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                if (prevTemp != null && temp_1 != minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp != minNode ==> treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not hold on entry. Assertion treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not hold. (BinomialHeap.vpr@554.15--554.105) [101432]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                if (prevTemp != null && temp_1 == minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp == minNode ==> treeDegree(prevTemp) < segDegree(minNode, null, 0) might not hold on entry. Assertion treeDegree(prevTemp) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@555.15--555.105) [101433]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not hold on entry. Assertion segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@556.15--556.119) [101434]"}
                    segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. Assertion segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@557.15--557.189) [101435]"}
                    segSize(Heap, nodes_1, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold on entry. Assertion segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@558.15--558.141) [101436]"}
                    segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segParent(temp, minNode) == null might not hold on entry. Assertion segParent(temp, minNode) == null might not hold. (BinomialHeap.vpr@559.15--559.67) [101437]"}
                    segParent(Heap, temp_1, minNode) == null;
                }
                if (minNode != null) {
                  assert {:msg "  Loop invariant minNode != null ==> segParent(minNode, null) == null might not hold on entry. Assertion segParent(minNode, null) == null might not hold. (BinomialHeap.vpr@560.15--560.67) [101438]"}
                    segParent(Heap, minNode, null) == null;
                }
                if (prevTemp != null && nodes_1 != prevTemp) {
                  assert {:msg "  Loop invariant prevTemp != null && nodes != prevTemp ==> segParent(nodes, prevTemp) == null might not hold on entry. Assertion segParent(nodes, prevTemp) == null might not hold. (BinomialHeap.vpr@561.15--561.91) [101439]"}
                    segParent(Heap, nodes_1, prevTemp) == null;
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> treeParent(prevTemp) == null might not hold on entry. Assertion treeParent(prevTemp) == null might not hold. (BinomialHeap.vpr@562.15--562.64) [101440]"}
                    treeParent(Heap, prevTemp) == null;
                }
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
            
            // -- Havoc loop written variables (except locals)
              havoc temp_1, prevTemp;
              assume Heap[temp_1, $allocated];
              assume Heap[prevTemp, $allocated];
            
            // -- Check definedness of invariant
              if (*) {
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                
                // -- Check definedness of sorted(temp, minNode)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@548.41--548.62) [101441]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume sorted(Heap, temp_1, minNode);
                assume state(Heap, Mask);
                perm := FullPerm;
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                
                // -- Check definedness of sorted(minNode, null)
                  if (*) {
                    // Exhale precondition of function application
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@549.41--549.62) [101442]"}
                      NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                    // Finish exhale
                    havoc ExhaleHeap;
                    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                    Heap := ExhaleHeap;
                    // Stop execution
                    assume false;
                  }
                assume sorted(Heap, minNode, null);
                assume state(Heap, Mask);
                if (prevTemp == null) {
                  assume temp_1 == nodes_1;
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(nodes_1, prevTemp):=Mask[null, heapseg(nodes_1, prevTemp)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of sorted(nodes, prevTemp)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function sorted might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@551.64--551.87) [101443]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes_1, prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume sorted(Heap, nodes_1, prevTemp);
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume prevTemp != null;
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of prevTemp.sibling == temp
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@552.15--552.103) [101444]"}
                      HasDirectPerm(Mask, prevTemp, sibling);
                  assume Heap[prevTemp, sibling] == temp_1;
                }
                assume state(Heap, Mask);
                if (prevTemp != null && prevTemp != nodes_1) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@553.84--553.110) [101445]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes_1, prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@553.57--553.115) [101446]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes_1, prevTemp)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(nodes, prevTemp) - 1 might not hold. (BinomialHeap.vpr@553.57--553.115) [101447]"}
                        0 <= segLength(Heap, nodes_1, prevTemp) - 1;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(nodes, prevTemp) - 1 < segLength(nodes, prevTemp) might not hold. (BinomialHeap.vpr@553.57--553.115) [101448]"}
                        segLength(Heap, nodes_1, prevTemp) - 1 < segLength(Heap, nodes_1, prevTemp);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@553.118--553.138) [101449]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segDegree(Heap, nodes_1, prevTemp, segLength(Heap, nodes_1, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                assume state(Heap, Mask);
                if (prevTemp != null && temp_1 != minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of treeDegree(prevTemp) < segDegree(temp, minNode, 0)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@554.55--554.75) [101450]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@554.78--554.105) [101451]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp, minNode) might not hold. (BinomialHeap.vpr@554.78--554.105) [101452]"}
                        0 < segLength(Heap, temp_1, minNode);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                assume state(Heap, Mask);
                if (prevTemp != null && temp_1 == minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of treeDegree(prevTemp) < segDegree(minNode, null, 0)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeDegree might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@555.55--555.75) [101453]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@555.78--555.105) [101454]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(minNode, null) might not hold. (BinomialHeap.vpr@555.78--555.105) [101455]"}
                        0 < segLength(Heap, minNode, null);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                assume state(Heap, Mask);
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0)
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@556.60--556.84) [101456]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@556.35--556.89) [101457]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(temp, minNode) - 1 might not hold. (BinomialHeap.vpr@556.35--556.89) [101458]"}
                        0 <= segLength(Heap, temp_1, minNode) - 1;
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(temp, minNode) - 1 < segLength(temp, minNode) might not hold. (BinomialHeap.vpr@556.35--556.89) [101459]"}
                        segLength(Heap, temp_1, minNode) - 1 < segLength(Heap, temp_1, minNode);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@556.92--556.119) [101460]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(minNode, null) might not hold. (BinomialHeap.vpr@556.92--556.119) [101461]"}
                        0 < segLength(Heap, minNode, null);
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null)))
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@557.36--557.60) [101462]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes_1, prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@557.63--557.81) [101463]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@557.84--557.106) [101464]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@557.109--557.131) [101465]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [101466]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@557.15--557.189) [101467]"}
                      HasDirectPerm(UnfoldingMask, this, Nodes);
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := UnfoldingHeap;
                      ExhaleWellDef0Mask := UnfoldingMask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@557.163--557.188) [101468]"}
                        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
                      UnfoldingHeap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segSize(Heap, nodes_1, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                assume state(Heap, Mask);
                if (prevTemp == null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null)))
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@558.36--558.58) [101469]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@558.61--558.83) [101470]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [101471]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assert {:msg "  Contract might not be well-formed. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@558.15--558.141) [101472]"}
                      HasDirectPerm(UnfoldingMask, this, Nodes);
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := UnfoldingHeap;
                      ExhaleWellDef0Mask := UnfoldingMask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@558.115--558.140) [101473]"}
                        NoPerm < perm ==> NoPerm < UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(UnfoldingHeap, ExhaleHeap, UnfoldingMask);
                      UnfoldingHeap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                assume state(Heap, Mask);
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segParent(temp, minNode) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@559.35--559.59) [101474]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, minNode)];
                      assert {:msg "  Precondition of function segParent might not hold. Assertion temp != minNode might not hold. (BinomialHeap.vpr@559.35--559.59) [101475]"}
                        temp_1 != minNode;
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segParent(Heap, temp_1, minNode) == null;
                }
                assume state(Heap, Mask);
                if (minNode != null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segParent(minNode, null) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@560.35--560.59) [101476]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(minNode, null)];
                      assert {:msg "  Precondition of function segParent might not hold. Assertion minNode != null might not hold. (BinomialHeap.vpr@560.35--560.59) [101477]"}
                        minNode != null;
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segParent(Heap, minNode, null) == null;
                }
                assume state(Heap, Mask);
                if (prevTemp != null && nodes_1 != prevTemp) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of segParent(nodes, prevTemp) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@561.57--561.83) [101478]"}
                        NoPerm < perm ==> NoPerm < Mask[null, heapseg(nodes_1, prevTemp)];
                      assert {:msg "  Precondition of function segParent might not hold. Assertion nodes != prevTemp might not hold. (BinomialHeap.vpr@561.57--561.83) [101479]"}
                        nodes_1 != prevTemp;
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume segParent(Heap, nodes_1, prevTemp) == null;
                }
                assume state(Heap, Mask);
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  
                  // -- Check definedness of treeParent(prevTemp) == null
                    if (*) {
                      // Exhale precondition of function application
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      assert {:msg "  Precondition of function treeParent might not hold. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@562.36--562.56) [101480]"}
                        NoPerm < perm ==> NoPerm < Mask[null, tree(prevTemp)];
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                      // Stop execution
                      assume false;
                    }
                  assume treeParent(Heap, prevTemp) == null;
                }
                assume state(Heap, Mask);
                assume false;
              }
            
            // -- Check the loop body
              if (*) {
                // Reset state
                loopHeap := Heap;
                loopMask := Mask;
                Mask := ZeroMask;
                assume state(Heap, Mask);
                // Inhale invariant
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume sorted(Heap, temp_1, minNode);
                perm := FullPerm;
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume sorted(Heap, minNode, null);
                if (prevTemp == null) {
                  assume temp_1 == nodes_1;
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(nodes_1, prevTemp):=Mask[null, heapseg(nodes_1, prevTemp)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume sorted(Heap, nodes_1, prevTemp);
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume prevTemp != null;
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
                  assume state(Heap, Mask);
                  assume Heap[prevTemp, sibling] == temp_1;
                }
                if (prevTemp != null && prevTemp != nodes_1) {
                  assume state(Heap, Mask);
                  assume segDegree(Heap, nodes_1, prevTemp, segLength(Heap, nodes_1, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                if (prevTemp != null && temp_1 != minNode) {
                  assume state(Heap, Mask);
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                if (prevTemp != null && temp_1 == minNode) {
                  assume state(Heap, Mask);
                  assume treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  assume segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  assume segSize(Heap, nodes_1, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                if (prevTemp == null) {
                  assume state(Heap, Mask);
                  assume segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                if (temp_1 != minNode) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, temp_1, minNode) == null;
                }
                if (minNode != null) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, minNode, null) == null;
                }
                if (prevTemp != null && nodes_1 != prevTemp) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, nodes_1, prevTemp) == null;
                }
                if (prevTemp != null) {
                  assume state(Heap, Mask);
                  assume treeParent(Heap, prevTemp) == null;
                }
                assume state(Heap, Mask);
                
                // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp != null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [101481]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                
                // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp == null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [101482]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                // Check and assume guard
                assume temp_1 != minNode;
                assume state(Heap, Mask);
                
                // -- Translate loop body
                  
                  // -- Translating statement: unfold acc(heapseg(temp, minNode), write) -- BinomialHeap.vpr@564.5--564.34
                    assume heapseg#trigger(Heap, heapseg(temp_1, minNode));
                    assume Heap[null, heapseg(temp_1, minNode)] == FrameFragment((if temp_1 != minNode then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], minNode)], FrameFragment((if Heap[temp_1, sibling] != minNode then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Unfolding heapseg(temp, minNode) might fail. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@564.5--564.34) [101483]"}
                        perm <= Mask[null, heapseg(temp_1, minNode)];
                    }
                    Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] - perm];
                    
                    // -- Update version of predicate
                      if (!HasDirectPerm(Mask, null, heapseg(temp_1, minNode))) {
                        havoc newVersion;
                        Heap := Heap[null, heapseg(temp_1, minNode):=newVersion];
                      }
                    if (temp_1 != minNode) {
                      perm := FullPerm;
                      Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                      
                      // -- Extra unfolding of predicate
                        assume InsidePredicate(heapseg(temp_1, minNode), Heap[null, heapseg(temp_1, minNode)], tree(temp_1), Heap[null, tree(temp_1)]);
                      assume state(Heap, Mask);
                      perm := FullPerm;
                      assume temp_1 != null;
                      Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
                      assume state(Heap, Mask);
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(Heap[temp_1, sibling], minNode):=Mask[null, heapseg(Heap[temp_1, sibling], minNode)] + perm];
                      
                      // -- Extra unfolding of predicate
                        assume InsidePredicate(heapseg(temp_1, minNode), Heap[null, heapseg(temp_1, minNode)], heapseg(Heap[temp_1, sibling], minNode), Heap[null, heapseg(Heap[temp_1, sibling], minNode)]);
                      assume state(Heap, Mask);
                      if (Heap[temp_1, sibling] != minNode) {
                        assume state(Heap, Mask);
                        assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], minNode);
                      }
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: if (prevTemp == null) -- BinomialHeap.vpr@565.5--572.6
                    if (prevTemp == null) {
                      
                      // -- Translating statement: fold acc(heapseg(nodes, temp), write) -- BinomialHeap.vpr@567.6--567.31
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (nodes_1 != temp_1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. There might be insufficient permission to access tree(nodes) (BinomialHeap.vpr@567.6--567.31) [101484]"}
                              perm <= Mask[null, tree(nodes_1)];
                          }
                          Mask := Mask[null, tree(nodes_1):=Mask[null, tree(nodes_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(nodes_1, temp_1), Heap[null, heapseg(nodes_1, temp_1)], tree(nodes_1), Heap[null, tree(nodes_1)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. There might be insufficient permission to access nodes.sibling (BinomialHeap.vpr@567.6--567.31) [101485]"}
                              perm <= Mask[nodes_1, sibling];
                          }
                          Mask := Mask[nodes_1, sibling:=Mask[nodes_1, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. There might be insufficient permission to access heapseg(nodes.sibling, temp) (BinomialHeap.vpr@567.6--567.31) [101486]"}
                              perm <= Mask[null, heapseg(Heap[nodes_1, sibling], temp_1)];
                          }
                          Mask := Mask[null, heapseg(Heap[nodes_1, sibling], temp_1):=Mask[null, heapseg(Heap[nodes_1, sibling], temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(nodes_1, temp_1), Heap[null, heapseg(nodes_1, temp_1)], heapseg(Heap[nodes_1, sibling], temp_1), Heap[null, heapseg(Heap[nodes_1, sibling], temp_1)]);
                          if (Heap[nodes_1, sibling] != temp_1) {
                            assert {:msg "  Folding heapseg(nodes, temp) might fail. Assertion treeParent(nodes) == segParent(nodes.sibling, temp) might not hold. (BinomialHeap.vpr@567.6--567.31) [101487]"}
                              treeParent(Heap, nodes_1) == segParent(Heap, Heap[nodes_1, sibling], temp_1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(nodes_1, temp_1):=Mask[null, heapseg(nodes_1, temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(nodes_1, temp_1));
                        assume Heap[null, heapseg(nodes_1, temp_1)] == FrameFragment((if nodes_1 != temp_1 then CombineFrames(Heap[null, tree(nodes_1)], CombineFrames(FrameFragment(Heap[nodes_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[nodes_1, sibling], temp_1)], FrameFragment((if Heap[nodes_1, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(nodes_1, temp_1))) {
                          Heap := Heap[null, heapseg#sm(nodes_1, temp_1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(nodes_1, temp_1):=freshVersion];
                        }
                        if (nodes_1 != temp_1) {
                          havoc newPMask;
                          assume (forall <A, B> o_169: Ref, f_170: (Field A B) ::
                            { newPMask[o_169, f_170] }
                            Heap[null, heapseg#sm(nodes_1, temp_1)][o_169, f_170] || Heap[null, tree#sm(nodes_1)][o_169, f_170] ==> newPMask[o_169, f_170]
                          );
                          Heap := Heap[null, heapseg#sm(nodes_1, temp_1):=newPMask];
                          Heap := Heap[null, heapseg#sm(nodes_1, temp_1):=Heap[null, heapseg#sm(nodes_1, temp_1)][nodes_1, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_170: Ref, f_171: (Field A B) ::
                            { newPMask[o_170, f_171] }
                            Heap[null, heapseg#sm(nodes_1, temp_1)][o_170, f_171] || Heap[null, heapseg#sm(Heap[nodes_1, sibling], temp_1)][o_170, f_171] ==> newPMask[o_170, f_171]
                          );
                          Heap := Heap[null, heapseg#sm(nodes_1, temp_1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    } else {
                      
                      // -- Translating statement: fold acc(heapseg(temp, temp), write) -- BinomialHeap.vpr@569.6--569.30
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (temp_1 != temp_1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@569.6--569.30) [101488]"}
                              perm <= Mask[null, tree(temp_1)];
                          }
                          Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], tree(temp_1), Heap[null, tree(temp_1)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@569.6--569.30) [101489]"}
                              perm <= Mask[temp_1, sibling];
                          }
                          Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access heapseg(temp.sibling, temp) (BinomialHeap.vpr@569.6--569.30) [101490]"}
                              perm <= Mask[null, heapseg(Heap[temp_1, sibling], temp_1)];
                          }
                          Mask := Mask[null, heapseg(Heap[temp_1, sibling], temp_1):=Mask[null, heapseg(Heap[temp_1, sibling], temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], heapseg(Heap[temp_1, sibling], temp_1), Heap[null, heapseg(Heap[temp_1, sibling], temp_1)]);
                          if (Heap[temp_1, sibling] != temp_1) {
                            assert {:msg "  Folding heapseg(temp, temp) might fail. Assertion treeParent(temp) == segParent(temp.sibling, temp) might not hold. (BinomialHeap.vpr@569.6--569.30) [101491]"}
                              treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], temp_1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(temp_1, temp_1):=Mask[null, heapseg(temp_1, temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(temp_1, temp_1));
                        assume Heap[null, heapseg(temp_1, temp_1)] == FrameFragment((if temp_1 != temp_1 then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], temp_1)], FrameFragment((if Heap[temp_1, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(temp_1, temp_1))) {
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(temp_1, temp_1):=freshVersion];
                        }
                        if (temp_1 != temp_1) {
                          havoc newPMask;
                          assume (forall <A, B> o_171: Ref, f_172: (Field A B) ::
                            { newPMask[o_171, f_172] }
                            Heap[null, heapseg#sm(temp_1, temp_1)][o_171, f_172] || Heap[null, tree#sm(temp_1)][o_171, f_172] ==> newPMask[o_171, f_172]
                          );
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=Heap[null, heapseg#sm(temp_1, temp_1)][temp_1, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_172: Ref, f_173: (Field A B) ::
                            { newPMask[o_172, f_173] }
                            Heap[null, heapseg#sm(temp_1, temp_1)][o_172, f_173] || Heap[null, heapseg#sm(Heap[temp_1, sibling], temp_1)][o_172, f_173] ==> newPMask[o_172, f_173]
                          );
                          Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: fold acc(heapseg(prevTemp, temp), write) -- BinomialHeap.vpr@570.6--570.34
                        ExhaleWellDef0Heap := Heap;
                        ExhaleWellDef0Mask := Mask;
                        if (prevTemp != temp_1) {
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@570.6--570.34) [101492]"}
                              perm <= Mask[null, tree(prevTemp)];
                          }
                          Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], tree(prevTemp), Heap[null, tree(prevTemp)]);
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@570.6--570.34) [101493]"}
                              perm <= Mask[prevTemp, sibling];
                          }
                          Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, temp) (BinomialHeap.vpr@570.6--570.34) [101494]"}
                              perm <= Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)];
                          }
                          Mask := Mask[null, heapseg(Heap[prevTemp, sibling], temp_1):=Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)] - perm];
                          
                          // -- Record predicate instance information
                            assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], heapseg(Heap[prevTemp, sibling], temp_1), Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)]);
                          if (Heap[prevTemp, sibling] != temp_1) {
                            assert {:msg "  Folding heapseg(prevTemp, temp) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, temp) might not hold. (BinomialHeap.vpr@570.6--570.34) [101495]"}
                              treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], temp_1);
                          }
                        }
                        perm := FullPerm;
                        Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] + perm];
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                        assume heapseg#trigger(Heap, heapseg(prevTemp, temp_1));
                        assume Heap[null, heapseg(prevTemp, temp_1)] == FrameFragment((if prevTemp != temp_1 then CombineFrames(Heap[null, tree(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)], FrameFragment((if Heap[prevTemp, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                        if (!HasDirectPerm(Mask, null, heapseg(prevTemp, temp_1))) {
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=ZeroPMask];
                          havoc freshVersion;
                          Heap := Heap[null, heapseg(prevTemp, temp_1):=freshVersion];
                        }
                        if (prevTemp != temp_1) {
                          havoc newPMask;
                          assume (forall <A, B> o_173: Ref, f_174: (Field A B) ::
                            { newPMask[o_173, f_174] }
                            Heap[null, heapseg#sm(prevTemp, temp_1)][o_173, f_174] || Heap[null, tree#sm(prevTemp)][o_173, f_174] ==> newPMask[o_173, f_174]
                          );
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=Heap[null, heapseg#sm(prevTemp, temp_1)][prevTemp, sibling:=true]];
                          havoc newPMask;
                          assume (forall <A, B> o_174: Ref, f_175: (Field A B) ::
                            { newPMask[o_174, f_175] }
                            Heap[null, heapseg#sm(prevTemp, temp_1)][o_174, f_175] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], temp_1)][o_174, f_175] ==> newPMask[o_174, f_175]
                          );
                          Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                        }
                        assume state(Heap, Mask);
                        assume state(Heap, Mask);
                      
                      // -- Translating statement: concat(nodes, prevTemp, temp) -- BinomialHeap.vpr@571.6--571.35
                        PreCallHeap := Heap;
                        PreCallMask := Mask;
                        
                        // -- Exhaling precondition
                          ExhaleWellDef0Heap := Heap;
                          ExhaleWellDef0Mask := Mask;
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@571.6--571.35) [101496]"}
                              perm <= Mask[null, heapseg(nodes_1, prevTemp)];
                          }
                          Mask := Mask[null, heapseg(nodes_1, prevTemp):=Mask[null, heapseg(nodes_1, prevTemp)] - perm];
                          perm := FullPerm;
                          if (perm != NoPerm) {
                            assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, temp) (BinomialHeap.vpr@571.6--571.35) [101497]"}
                              perm <= Mask[null, heapseg(prevTemp, temp_1)];
                          }
                          Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] - perm];
                          if (temp_1 != null) {
                            perm := FullPerm;
                            if (perm != NoPerm) {
                              assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@571.6--571.35) [101498]"}
                                perm <= Mask[null, tree(temp_1)];
                            }
                            Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                          }
                          if (nodes_1 != prevTemp && prevTemp != temp_1) {
                            assert {:msg "  The precondition of method concat might not hold. Assertion segParent(nodes, prevTemp) == segParent(prevTemp, temp) might not hold. (BinomialHeap.vpr@571.6--571.35) [101499]"}
                              segParent(Heap, nodes_1, prevTemp) == segParent(Heap, prevTemp, temp_1);
                          }
                          // Finish exhale
                          havoc ExhaleHeap;
                          assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                          Heap := ExhaleHeap;
                        
                        // -- Inhaling postcondition
                          perm := FullPerm;
                          Mask := Mask[null, heapseg(nodes_1, temp_1):=Mask[null, heapseg(nodes_1, temp_1)] + perm];
                          assume state(Heap, Mask);
                          assume state(Heap, Mask);
                          assume segLength(Heap, nodes_1, temp_1) == segLength(PreCallHeap, nodes_1, prevTemp) + segLength(PreCallHeap, prevTemp, temp_1);
                          assume state(Heap, Mask);
                          assume (forall i: int ::
                            { segDegree#frame(Heap[null, heapseg(nodes_1, temp_1)], nodes_1, temp_1, i) } { segDegree#frame(PreCallHeap[null, heapseg(nodes_1, prevTemp)], nodes_1, prevTemp, i) }
                            0 <= i && i < segLength(PreCallHeap, nodes_1, prevTemp) ==> segDegree(Heap, nodes_1, temp_1, i) == segDegree(PreCallHeap, nodes_1, prevTemp, i)
                          );
                          assume state(Heap, Mask);
                          assume (forall i_1: int ::
                            { segDegree#frame(Heap[null, heapseg(nodes_1, temp_1)], nodes_1, temp_1, i_1) }
                            segLength(PreCallHeap, nodes_1, prevTemp) <= i_1 && i_1 < segLength(Heap, nodes_1, temp_1) ==> segDegree(Heap, nodes_1, temp_1, i_1) == segDegree(PreCallHeap, prevTemp, temp_1, i_1 - segLength(PreCallHeap, nodes_1, prevTemp))
                          );
                          if (temp_1 != null) {
                            perm := FullPerm;
                            Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                            assume state(Heap, Mask);
                            assume state(Heap, Mask);
                            assume treeDegree(Heap, temp_1) == treeDegree(PreCallHeap, temp_1);
                            assume state(Heap, Mask);
                            assume treeSize(Heap, temp_1) == treeSize(PreCallHeap, temp_1);
                            assume state(Heap, Mask);
                            assume treeParent(Heap, temp_1) == treeParent(PreCallHeap, temp_1);
                          }
                          if (sorted(PreCallHeap, nodes_1, prevTemp) && (sorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, nodes_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))) {
                            assume state(Heap, Mask);
                            assume sorted(Heap, nodes_1, temp_1);
                          }
                          if (presorted(PreCallHeap, nodes_1, prevTemp) && (presorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, nodes_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, temp_1, 0) && ((2 <= segLength(PreCallHeap, nodes_1, prevTemp) && segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) == segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 2) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)) && (2 <= segLength(PreCallHeap, prevTemp, temp_1) && segDegree(PreCallHeap, prevTemp, temp_1, 0) == segDegree(PreCallHeap, prevTemp, temp_1, 1) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))))) {
                            assume state(Heap, Mask);
                            assume presorted(Heap, nodes_1, temp_1);
                          }
                          if (validChildren(PreCallHeap, nodes_1, prevTemp) && (validChildren(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, nodes_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, temp_1, 0) + 1))) {
                            assume state(Heap, Mask);
                            assume validChildren(Heap, nodes_1, temp_1);
                          }
                          assume state(Heap, Mask);
                          assume segSize(Heap, nodes_1, temp_1) == segSize(PreCallHeap, nodes_1, prevTemp) + segSize(PreCallHeap, prevTemp, temp_1);
                          if (nodes_1 != prevTemp) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, nodes_1, temp_1) == segParent(PreCallHeap, nodes_1, prevTemp);
                          }
                          if (prevTemp != temp_1) {
                            assume state(Heap, Mask);
                            assume segParent(Heap, nodes_1, temp_1) == segParent(PreCallHeap, prevTemp, temp_1);
                          }
                          assume state(Heap, Mask);
                        assume state(Heap, Mask);
                    }
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: prevTemp := temp -- BinomialHeap.vpr@574.5--574.21
                    prevTemp := temp_1;
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: temp := temp.sibling -- BinomialHeap.vpr@575.5--575.25
                    
                    // -- Check definedness of temp.sibling
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@575.5--575.25) [101500]"}
                        HasDirectPerm(Mask, temp_1, sibling);
                    temp_1 := Heap[temp_1, sibling];
                    assume state(Heap, Mask);
                // Exhale invariant
                
                // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp != null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [101501]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                
                // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                  if (prevTemp == null) {
                    UnfoldingHeap := oldHeap;
                    UnfoldingMask := oldMask;
                    assume heap#trigger(UnfoldingHeap, heap_1(this));
                    assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                    ExhaleWellDef0Heap := UnfoldingHeap;
                    ExhaleWellDef0Mask := UnfoldingMask;
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [101502]"}
                        perm <= UnfoldingMask[null, heap_1(this)];
                    }
                    UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    perm := FullPerm;
                    UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                    
                    // -- Extra unfolding of predicate
                      assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    if (UnfoldingHeap[this, Nodes] != null) {
                      assume state(UnfoldingHeap, UnfoldingMask);
                      assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                    }
                    perm := FullPerm;
                    assume this != null;
                    UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                    assume state(UnfoldingHeap, UnfoldingMask);
                  }
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not be preserved. There might be insufficient permission to access heapseg(temp, minNode) (BinomialHeap.vpr@548.15--548.62) [101503]"}
                    perm <= Mask[null, heapseg(temp_1, minNode)];
                }
                Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(temp, minNode), write) && sorted(temp, minNode) might not be preserved. Assertion sorted(temp, minNode) might not hold. (BinomialHeap.vpr@548.15--548.62) [101504]"}
                  sorted(Heap, temp_1, minNode);
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not be preserved. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@549.15--549.62) [101505]"}
                    perm <= Mask[null, heapseg(minNode, null)];
                }
                Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] - perm];
                assert {:msg "  Loop invariant acc(heapseg(minNode, null), write) && sorted(minNode, null) might not be preserved. Assertion sorted(minNode, null) might not hold. (BinomialHeap.vpr@549.15--549.62) [101506]"}
                  sorted(Heap, minNode, null);
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> temp == nodes might not be preserved. Assertion temp == nodes might not hold. (BinomialHeap.vpr@550.15--550.49) [101507]"}
                    temp_1 == nodes_1;
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not be preserved. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@551.15--551.87) [101508]"}
                      perm <= Mask[null, heapseg(nodes_1, prevTemp)];
                  }
                  Mask := Mask[null, heapseg(nodes_1, prevTemp):=Mask[null, heapseg(nodes_1, prevTemp)] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(heapseg(nodes, prevTemp), write) && sorted(nodes, prevTemp) might not be preserved. Assertion sorted(nodes, prevTemp) might not hold. (BinomialHeap.vpr@551.15--551.87) [101509]"}
                    sorted(Heap, nodes_1, prevTemp);
                }
                if (prevTemp != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not be preserved. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@552.15--552.103) [101510]"}
                      perm <= Mask[null, tree(prevTemp)];
                  }
                  Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not be preserved. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@552.15--552.103) [101511]"}
                      perm <= Mask[prevTemp, sibling];
                  }
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                  assert {:msg "  Loop invariant prevTemp != null ==> acc(tree(prevTemp), write) && (acc(prevTemp.sibling, write) && prevTemp.sibling == temp) might not be preserved. Assertion prevTemp.sibling == temp might not hold. (BinomialHeap.vpr@552.15--552.103) [101512]"}
                    Heap[prevTemp, sibling] == temp_1;
                }
                if (prevTemp != null && prevTemp != nodes_1) {
                  assert {:msg "  Loop invariant prevTemp != null && prevTemp != nodes ==> segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not be preserved. Assertion segDegree(nodes, prevTemp, segLength(nodes, prevTemp) - 1) < treeDegree(prevTemp) might not hold. (BinomialHeap.vpr@553.15--553.138) [101513]"}
                    segDegree(Heap, nodes_1, prevTemp, segLength(Heap, nodes_1, prevTemp) - 1) < treeDegree(Heap, prevTemp);
                }
                if (prevTemp != null && temp_1 != minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp != minNode ==> treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not be preserved. Assertion treeDegree(prevTemp) < segDegree(temp, minNode, 0) might not hold. (BinomialHeap.vpr@554.15--554.105) [101514]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
                }
                if (prevTemp != null && temp_1 == minNode) {
                  assert {:msg "  Loop invariant prevTemp != null && temp == minNode ==> treeDegree(prevTemp) < segDegree(minNode, null, 0) might not be preserved. Assertion treeDegree(prevTemp) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@555.15--555.105) [101515]"}
                    treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not be preserved. Assertion segDegree(temp, minNode, segLength(temp, minNode) - 1) < segDegree(minNode, null, 0) might not hold. (BinomialHeap.vpr@556.15--556.119) [101516]"}
                    segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. Assertion segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@557.15--557.189) [101517]"}
                    segSize(Heap, nodes_1, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                if (prevTemp == null) {
                  assert {:msg "  Loop invariant prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not be preserved. Assertion segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) might not hold. (BinomialHeap.vpr@558.15--558.141) [101518]"}
                    segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
                }
                if (temp_1 != minNode) {
                  assert {:msg "  Loop invariant temp != minNode ==> segParent(temp, minNode) == null might not be preserved. Assertion segParent(temp, minNode) == null might not hold. (BinomialHeap.vpr@559.15--559.67) [101519]"}
                    segParent(Heap, temp_1, minNode) == null;
                }
                if (minNode != null) {
                  assert {:msg "  Loop invariant minNode != null ==> segParent(minNode, null) == null might not be preserved. Assertion segParent(minNode, null) == null might not hold. (BinomialHeap.vpr@560.15--560.67) [101520]"}
                    segParent(Heap, minNode, null) == null;
                }
                if (prevTemp != null && nodes_1 != prevTemp) {
                  assert {:msg "  Loop invariant prevTemp != null && nodes != prevTemp ==> segParent(nodes, prevTemp) == null might not be preserved. Assertion segParent(nodes, prevTemp) == null might not hold. (BinomialHeap.vpr@561.15--561.91) [101521]"}
                    segParent(Heap, nodes_1, prevTemp) == null;
                }
                if (prevTemp != null) {
                  assert {:msg "  Loop invariant prevTemp != null ==> treeParent(prevTemp) == null might not be preserved. Assertion treeParent(prevTemp) == null might not hold. (BinomialHeap.vpr@562.15--562.64) [101522]"}
                    treeParent(Heap, prevTemp) == null;
                }
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Terminate execution
                assume false;
              }
            
            // -- Inhale loop invariant after loop, and assume guard
              assume !(temp_1 != minNode);
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(temp_1, minNode):=Mask[null, heapseg(temp_1, minNode)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume sorted(Heap, temp_1, minNode);
              perm := FullPerm;
              Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume sorted(Heap, minNode, null);
              if (prevTemp == null) {
                assume temp_1 == nodes_1;
              }
              if (prevTemp != null) {
                perm := FullPerm;
                Mask := Mask[null, heapseg(nodes_1, prevTemp):=Mask[null, heapseg(nodes_1, prevTemp)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume sorted(Heap, nodes_1, prevTemp);
              }
              if (prevTemp != null) {
                perm := FullPerm;
                Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume prevTemp != null;
                Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] + perm];
                assume state(Heap, Mask);
                assume Heap[prevTemp, sibling] == temp_1;
              }
              if (prevTemp != null && prevTemp != nodes_1) {
                assume state(Heap, Mask);
                assume segDegree(Heap, nodes_1, prevTemp, segLength(Heap, nodes_1, prevTemp) - 1) < treeDegree(Heap, prevTemp);
              }
              if (prevTemp != null && temp_1 != minNode) {
                assume state(Heap, Mask);
                assume treeDegree(Heap, prevTemp) < segDegree(Heap, temp_1, minNode, 0);
              }
              if (prevTemp != null && temp_1 == minNode) {
                assume state(Heap, Mask);
                assume treeDegree(Heap, prevTemp) < segDegree(Heap, minNode, null, 0);
              }
              if (temp_1 != minNode) {
                assume state(Heap, Mask);
                assume segDegree(Heap, temp_1, minNode, segLength(Heap, temp_1, minNode) - 1) < segDegree(Heap, minNode, null, 0);
              }
              if (prevTemp != null) {
                assume state(Heap, Mask);
                assume segSize(Heap, nodes_1, prevTemp) + treeSize(Heap, prevTemp) + segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
              }
              if (prevTemp == null) {
                assume state(Heap, Mask);
                assume segSize(Heap, temp_1, minNode) + segSize(Heap, minNode, null) == segSize(oldHeap, oldHeap[this, Nodes], null);
              }
              if (temp_1 != minNode) {
                assume state(Heap, Mask);
                assume segParent(Heap, temp_1, minNode) == null;
              }
              if (minNode != null) {
                assume state(Heap, Mask);
                assume segParent(Heap, minNode, null) == null;
              }
              if (prevTemp != null && nodes_1 != prevTemp) {
                assume state(Heap, Mask);
                assume segParent(Heap, nodes_1, prevTemp) == null;
              }
              if (prevTemp != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, prevTemp) == null;
              }
              assume state(Heap, Mask);
              
              // -- Execute definedness check of prevTemp != null ==> segSize(nodes, prevTemp) + treeSize(prevTemp) + segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                if (prevTemp != null) {
                  UnfoldingHeap := oldHeap;
                  UnfoldingMask := oldMask;
                  assume heap#trigger(UnfoldingHeap, heap_1(this));
                  assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                  ExhaleWellDef0Heap := UnfoldingHeap;
                  ExhaleWellDef0Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@557.15--557.189) [101523]"}
                      perm <= UnfoldingMask[null, heap_1(this)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  perm := FullPerm;
                  UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                  if (UnfoldingHeap[this, Nodes] != null) {
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                  }
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                  assume state(UnfoldingHeap, UnfoldingMask);
                }
              
              // -- Execute definedness check of prevTemp == null ==> segSize(temp, minNode) + segSize(minNode, null) == old((unfolding acc(heap(this), write) in segSize(this.Nodes, null))) without enforcing the checks (e.g., to gain more information)
                if (prevTemp == null) {
                  UnfoldingHeap := oldHeap;
                  UnfoldingMask := oldMask;
                  assume heap#trigger(UnfoldingHeap, heap_1(this));
                  assume UnfoldingHeap[null, heap_1(this)] == CombineFrames(FrameFragment(UnfoldingHeap[this, Nodes]), CombineFrames(UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)], CombineFrames(FrameFragment((if UnfoldingHeap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(UnfoldingHeap[this, size]))));
                  ExhaleWellDef0Heap := UnfoldingHeap;
                  ExhaleWellDef0Mask := UnfoldingMask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  An internal error occurred. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@558.15--558.141) [101524]"}
                      perm <= UnfoldingMask[null, heap_1(this)];
                  }
                  UnfoldingMask := UnfoldingMask[null, heap_1(this):=UnfoldingMask[null, heap_1(this)] - perm];
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, Nodes:=UnfoldingMask[this, Nodes] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  perm := FullPerm;
                  UnfoldingMask := UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null):=UnfoldingMask[null, heapseg(UnfoldingHeap[this, Nodes], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heap_1(this), UnfoldingHeap[null, heap_1(this)], heapseg(UnfoldingHeap[this, Nodes], null), UnfoldingHeap[null, heapseg(UnfoldingHeap[this, Nodes], null)]);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume sorted(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                  if (UnfoldingHeap[this, Nodes] != null) {
                    assume state(UnfoldingHeap, UnfoldingMask);
                    assume segParent(UnfoldingHeap, UnfoldingHeap[this, Nodes], null) == null;
                  }
                  perm := FullPerm;
                  assume this != null;
                  UnfoldingMask := UnfoldingMask[this, size:=UnfoldingMask[this, size] + perm];
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume state(UnfoldingHeap, UnfoldingMask);
                  assume UnfoldingHeap[this, size] == segSize(UnfoldingHeap, UnfoldingHeap[this, Nodes], null);
                  assume state(UnfoldingHeap, UnfoldingMask);
                }
            assume state(Heap, Mask);
          
          // -- Translating statement: unfold acc(heapseg(minNode, null), write) -- BinomialHeap.vpr@578.4--578.33
            assume heapseg#trigger(Heap, heapseg(minNode, null));
            assume Heap[null, heapseg(minNode, null)] == FrameFragment((if minNode != null then CombineFrames(Heap[null, tree(minNode)], CombineFrames(FrameFragment(Heap[minNode, sibling]), CombineFrames(Heap[null, heapseg(Heap[minNode, sibling], null)], FrameFragment((if Heap[minNode, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Unfolding heapseg(minNode, null) might fail. There might be insufficient permission to access heapseg(minNode, null) (BinomialHeap.vpr@578.4--578.33) [101527]"}
                perm <= Mask[null, heapseg(minNode, null)];
            }
            Mask := Mask[null, heapseg(minNode, null):=Mask[null, heapseg(minNode, null)] - perm];
            
            // -- Update version of predicate
              if (!HasDirectPerm(Mask, null, heapseg(minNode, null))) {
                havoc newVersion;
                Heap := Heap[null, heapseg(minNode, null):=newVersion];
              }
            if (minNode != null) {
              perm := FullPerm;
              Mask := Mask[null, tree(minNode):=Mask[null, tree(minNode)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(minNode, null), Heap[null, heapseg(minNode, null)], tree(minNode), Heap[null, tree(minNode)]);
              assume state(Heap, Mask);
              perm := FullPerm;
              assume minNode != null;
              Mask := Mask[minNode, sibling:=Mask[minNode, sibling] + perm];
              assume state(Heap, Mask);
              perm := FullPerm;
              Mask := Mask[null, heapseg(Heap[minNode, sibling], null):=Mask[null, heapseg(Heap[minNode, sibling], null)] + perm];
              
              // -- Extra unfolding of predicate
                assume InsidePredicate(heapseg(minNode, null), Heap[null, heapseg(minNode, null)], heapseg(Heap[minNode, sibling], null), Heap[null, heapseg(Heap[minNode, sibling], null)]);
              assume state(Heap, Mask);
              if (Heap[minNode, sibling] != null) {
                assume state(Heap, Mask);
                assume treeParent(Heap, minNode) == segParent(Heap, Heap[minNode, sibling], null);
              }
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: prevTemp.sibling := temp.sibling -- BinomialHeap.vpr@579.4--579.36
            
            // -- Check definedness of temp.sibling
              assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@579.4--579.36) [101531]"}
                HasDirectPerm(Mask, temp_1, sibling);
            assert {:msg "  Assignment might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@579.4--579.36) [101532]"}
              FullPerm == Mask[prevTemp, sibling];
            Heap := Heap[prevTemp, sibling:=Heap[temp_1, sibling]];
            assume state(Heap, Mask);
          
          // -- Translating statement: fold acc(heapseg(prevTemp, null), write) -- BinomialHeap.vpr@580.4--580.32
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            if (prevTemp != null) {
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@580.4--580.32) [101535]"}
                  perm <= Mask[null, tree(prevTemp)];
              }
              Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], tree(prevTemp), Heap[null, tree(prevTemp)]);
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@580.4--580.32) [101537]"}
                  perm <= Mask[prevTemp, sibling];
              }
              Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, null) (BinomialHeap.vpr@580.4--580.32) [101539]"}
                  perm <= Mask[null, heapseg(Heap[prevTemp, sibling], null)];
              }
              Mask := Mask[null, heapseg(Heap[prevTemp, sibling], null):=Mask[null, heapseg(Heap[prevTemp, sibling], null)] - perm];
              
              // -- Record predicate instance information
                assume InsidePredicate(heapseg(prevTemp, null), Heap[null, heapseg(prevTemp, null)], heapseg(Heap[prevTemp, sibling], null), Heap[null, heapseg(Heap[prevTemp, sibling], null)]);
              if (Heap[prevTemp, sibling] != null) {
                assert {:msg "  Folding heapseg(prevTemp, null) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, null) might not hold. (BinomialHeap.vpr@580.4--580.32) [101540]"}
                  treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], null);
              }
            }
            perm := FullPerm;
            Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume heapseg#trigger(Heap, heapseg(prevTemp, null));
            assume Heap[null, heapseg(prevTemp, null)] == FrameFragment((if prevTemp != null then CombineFrames(Heap[null, tree(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], null)], FrameFragment((if Heap[prevTemp, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
            if (!HasDirectPerm(Mask, null, heapseg(prevTemp, null))) {
              Heap := Heap[null, heapseg#sm(prevTemp, null):=ZeroPMask];
              havoc freshVersion;
              Heap := Heap[null, heapseg(prevTemp, null):=freshVersion];
            }
            if (prevTemp != null) {
              havoc newPMask;
              assume (forall <A, B> o_175: Ref, f_176: (Field A B) ::
                { newPMask[o_175, f_176] }
                Heap[null, heapseg#sm(prevTemp, null)][o_175, f_176] || Heap[null, tree#sm(prevTemp)][o_175, f_176] ==> newPMask[o_175, f_176]
              );
              Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
              Heap := Heap[null, heapseg#sm(prevTemp, null):=Heap[null, heapseg#sm(prevTemp, null)][prevTemp, sibling:=true]];
              havoc newPMask;
              assume (forall <A, B> o_176: Ref, f_177: (Field A B) ::
                { newPMask[o_176, f_177] }
                Heap[null, heapseg#sm(prevTemp, null)][o_176, f_177] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], null)][o_176, f_177] ==> newPMask[o_176, f_177]
              );
              Heap := Heap[null, heapseg#sm(prevTemp, null):=newPMask];
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
          
          // -- Translating statement: concat(nodes, prevTemp, null) -- BinomialHeap.vpr@581.4--581.33
            PreCallHeap := Heap;
            PreCallMask := Mask;
            
            // -- Exhaling precondition
              ExhaleWellDef0Heap := Heap;
              ExhaleWellDef0Mask := Mask;
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(nodes, prevTemp) (BinomialHeap.vpr@581.4--581.33) [101542]"}
                  perm <= Mask[null, heapseg(nodes_1, prevTemp)];
              }
              Mask := Mask[null, heapseg(nodes_1, prevTemp):=Mask[null, heapseg(nodes_1, prevTemp)] - perm];
              perm := FullPerm;
              if (perm != NoPerm) {
                assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, null) (BinomialHeap.vpr@581.4--581.33) [101543]"}
                  perm <= Mask[null, heapseg(prevTemp, null)];
              }
              Mask := Mask[null, heapseg(prevTemp, null):=Mask[null, heapseg(prevTemp, null)] - perm];
              if (null != null) {
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@581.4--581.33) [101544]"}
                    perm <= Mask[null, tree(null)];
                }
                Mask := Mask[null, tree(null):=Mask[null, tree(null)] - perm];
              }
              if (nodes_1 != prevTemp && prevTemp != null) {
                assert {:msg "  The precondition of method concat might not hold. Assertion segParent(nodes, prevTemp) == segParent(prevTemp, null) might not hold. (BinomialHeap.vpr@581.4--581.33) [101545]"}
                  segParent(Heap, nodes_1, prevTemp) == segParent(Heap, prevTemp, null);
              }
              // Finish exhale
              havoc ExhaleHeap;
              assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
              Heap := ExhaleHeap;
            
            // -- Inhaling postcondition
              perm := FullPerm;
              Mask := Mask[null, heapseg(nodes_1, null):=Mask[null, heapseg(nodes_1, null)] + perm];
              assume state(Heap, Mask);
              assume state(Heap, Mask);
              assume segLength(Heap, nodes_1, null) == segLength(PreCallHeap, nodes_1, prevTemp) + segLength(PreCallHeap, prevTemp, null);
              assume state(Heap, Mask);
              assume (forall i_2_1: int ::
                { segDegree#frame(Heap[null, heapseg(nodes_1, null)], nodes_1, null, i_2_1) } { segDegree#frame(PreCallHeap[null, heapseg(nodes_1, prevTemp)], nodes_1, prevTemp, i_2_1) }
                0 <= i_2_1 && i_2_1 < segLength(PreCallHeap, nodes_1, prevTemp) ==> segDegree(Heap, nodes_1, null, i_2_1) == segDegree(PreCallHeap, nodes_1, prevTemp, i_2_1)
              );
              assume state(Heap, Mask);
              assume (forall i_3: int ::
                { segDegree#frame(Heap[null, heapseg(nodes_1, null)], nodes_1, null, i_3) }
                segLength(PreCallHeap, nodes_1, prevTemp) <= i_3 && i_3 < segLength(Heap, nodes_1, null) ==> segDegree(Heap, nodes_1, null, i_3) == segDegree(PreCallHeap, prevTemp, null, i_3 - segLength(PreCallHeap, nodes_1, prevTemp))
              );
              if (null != null) {
                perm := FullPerm;
                Mask := Mask[null, tree(null):=Mask[null, tree(null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume treeDegree(Heap, null) == treeDegree(PreCallHeap, null);
                assume state(Heap, Mask);
                assume treeSize(Heap, null) == treeSize(PreCallHeap, null);
                assume state(Heap, Mask);
                assume treeParent(Heap, null) == treeParent(PreCallHeap, null);
              }
              if (sorted(PreCallHeap, nodes_1, prevTemp) && (sorted(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, nodes_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))) {
                assume state(Heap, Mask);
                assume sorted(Heap, nodes_1, null);
              }
              if (presorted(PreCallHeap, nodes_1, prevTemp) && (presorted(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, nodes_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, null, 0) && ((2 <= segLength(PreCallHeap, nodes_1, prevTemp) && segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) == segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 2) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)) && (2 <= segLength(PreCallHeap, prevTemp, null) && segDegree(PreCallHeap, prevTemp, null, 0) == segDegree(PreCallHeap, prevTemp, null, 1) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, null, 0)))))) {
                assume state(Heap, Mask);
                assume presorted(Heap, nodes_1, null);
              }
              if (validChildren(PreCallHeap, nodes_1, prevTemp) && (validChildren(PreCallHeap, prevTemp, null) && (0 < segLength(PreCallHeap, nodes_1, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, null) ==> segDegree(PreCallHeap, nodes_1, prevTemp, segLength(PreCallHeap, nodes_1, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, null, 0) + 1))) {
                assume state(Heap, Mask);
                assume validChildren(Heap, nodes_1, null);
              }
              assume state(Heap, Mask);
              assume segSize(Heap, nodes_1, null) == segSize(PreCallHeap, nodes_1, prevTemp) + segSize(PreCallHeap, prevTemp, null);
              if (nodes_1 != prevTemp) {
                assume state(Heap, Mask);
                assume segParent(Heap, nodes_1, null) == segParent(PreCallHeap, nodes_1, prevTemp);
              }
              if (prevTemp != null) {
                assume state(Heap, Mask);
                assume segParent(Heap, nodes_1, null) == segParent(PreCallHeap, prevTemp, null);
              }
              assume state(Heap, Mask);
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: oldTreeSize := treeSize(temp) -- BinomialHeap.vpr@584.3--584.41
        
        // -- Check definedness of treeSize(temp)
          if (*) {
            // Exhale precondition of function application
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            assert {:msg "  Precondition of function treeSize might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@584.27--584.41) [101546]"}
              NoPerm < perm ==> NoPerm < Mask[null, tree(temp_1)];
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Stop execution
            assume false;
          }
        oldTreeSize := treeSize(Heap, temp_1);
        assume state(Heap, Mask);
      
      // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@585.3--585.20
        assume tree#trigger(Heap, tree(temp_1));
        assume Heap[null, tree(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        perm := FullPerm;
        if (perm != NoPerm) {
          assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@585.3--585.20) [101549]"}
            perm <= Mask[null, tree(temp_1)];
        }
        Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
        
        // -- Update version of predicate
          if (!HasDirectPerm(Mask, null, tree(temp_1))) {
            havoc newVersion;
            Heap := Heap[null, tree(temp_1):=newVersion];
          }
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, key:=Mask[temp_1, key] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
        assume state(Heap, Mask);
        perm := FullPerm;
        assume temp_1 != null;
        Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
        assume state(Heap, Mask);
        assume 0 <= Heap[temp_1, degree];
        perm := FullPerm;
        Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
        
        // -- Extra unfolding of predicate
          assume InsidePredicate(tree(temp_1), Heap[null, tree(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
        if (0 < Heap[temp_1, degree]) {
          assume state(Heap, Mask);
          assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
        }
        assume state(Heap, Mask);
        assume validChildren(Heap, Heap[temp_1, child], null);
        if (Heap[temp_1, child] != null) {
          assume state(Heap, Mask);
          assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: temp := temp.child -- BinomialHeap.vpr@586.3--586.21
        
        // -- Check definedness of temp.child
          assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@586.3--586.21) [101555]"}
            HasDirectPerm(Mask, temp_1, child);
        temp_1 := Heap[temp_1, child];
        assume state(Heap, Mask);
      
      // -- Translating statement: fakeNode := temp -- BinomialHeap.vpr@587.3--587.28
        fakeNode := temp_1;
        assume state(Heap, Mask);
      
      // -- Translating statement: fold acc(heapseg(fakeNode, temp), write) -- BinomialHeap.vpr@591.3--591.31
        ExhaleWellDef0Heap := Heap;
        ExhaleWellDef0Mask := Mask;
        if (fakeNode != temp_1) {
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. There might be insufficient permission to access tree(fakeNode) (BinomialHeap.vpr@591.3--591.31) [101558]"}
              perm <= Mask[null, tree(fakeNode)];
          }
          Mask := Mask[null, tree(fakeNode):=Mask[null, tree(fakeNode)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(fakeNode, temp_1), Heap[null, heapseg(fakeNode, temp_1)], tree(fakeNode), Heap[null, tree(fakeNode)]);
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. There might be insufficient permission to access fakeNode.sibling (BinomialHeap.vpr@591.3--591.31) [101560]"}
              perm <= Mask[fakeNode, sibling];
          }
          Mask := Mask[fakeNode, sibling:=Mask[fakeNode, sibling] - perm];
          perm := FullPerm;
          if (perm != NoPerm) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. There might be insufficient permission to access heapseg(fakeNode.sibling, temp) (BinomialHeap.vpr@591.3--591.31) [101562]"}
              perm <= Mask[null, heapseg(Heap[fakeNode, sibling], temp_1)];
          }
          Mask := Mask[null, heapseg(Heap[fakeNode, sibling], temp_1):=Mask[null, heapseg(Heap[fakeNode, sibling], temp_1)] - perm];
          
          // -- Record predicate instance information
            assume InsidePredicate(heapseg(fakeNode, temp_1), Heap[null, heapseg(fakeNode, temp_1)], heapseg(Heap[fakeNode, sibling], temp_1), Heap[null, heapseg(Heap[fakeNode, sibling], temp_1)]);
          if (Heap[fakeNode, sibling] != temp_1) {
            assert {:msg "  Folding heapseg(fakeNode, temp) might fail. Assertion treeParent(fakeNode) == segParent(fakeNode.sibling, temp) might not hold. (BinomialHeap.vpr@591.3--591.31) [101563]"}
              treeParent(Heap, fakeNode) == segParent(Heap, Heap[fakeNode, sibling], temp_1);
          }
        }
        perm := FullPerm;
        Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
        assume state(Heap, Mask);
        assume state(Heap, Mask);
        assume heapseg#trigger(Heap, heapseg(fakeNode, temp_1));
        assume Heap[null, heapseg(fakeNode, temp_1)] == FrameFragment((if fakeNode != temp_1 then CombineFrames(Heap[null, tree(fakeNode)], CombineFrames(FrameFragment(Heap[fakeNode, sibling]), CombineFrames(Heap[null, heapseg(Heap[fakeNode, sibling], temp_1)], FrameFragment((if Heap[fakeNode, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
        if (!HasDirectPerm(Mask, null, heapseg(fakeNode, temp_1))) {
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=ZeroPMask];
          havoc freshVersion;
          Heap := Heap[null, heapseg(fakeNode, temp_1):=freshVersion];
        }
        if (fakeNode != temp_1) {
          havoc newPMask;
          assume (forall <A, B> o_177: Ref, f_178: (Field A B) ::
            { newPMask[o_177, f_178] }
            Heap[null, heapseg#sm(fakeNode, temp_1)][o_177, f_178] || Heap[null, tree#sm(fakeNode)][o_177, f_178] ==> newPMask[o_177, f_178]
          );
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=newPMask];
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=Heap[null, heapseg#sm(fakeNode, temp_1)][fakeNode, sibling:=true]];
          havoc newPMask;
          assume (forall <A, B> o_178: Ref, f_179: (Field A B) ::
            { newPMask[o_178, f_179] }
            Heap[null, heapseg#sm(fakeNode, temp_1)][o_178, f_179] || Heap[null, heapseg#sm(Heap[fakeNode, sibling], temp_1)][o_178, f_179] ==> newPMask[o_178, f_179]
          );
          Heap := Heap[null, heapseg#sm(fakeNode, temp_1):=newPMask];
        }
        assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: while (temp != null) -- BinomialHeap.vpr@592.3--613.4
        
        // -- Before loop head
          
          // -- Exhale loop invariant before loop
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(fakeNode, temp), write) might not hold on entry. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@593.14--593.37) [101565]"}
                perm <= Mask[null, heapseg(fakeNode, temp_1)];
            }
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] - perm];
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp, null), write) might not hold on entry. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@594.14--594.33) [101566]"}
                perm <= Mask[null, heapseg(temp_1, null)];
            }
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
            assert {:msg "  Loop invariant validChildren(fakeNode, temp) might not hold on entry. Assertion validChildren(fakeNode, temp) might not hold. (BinomialHeap.vpr@595.14--595.43) [101567]"}
              validChildren(Heap, fakeNode, temp_1);
            assert {:msg "  Loop invariant validChildren(temp, null) might not hold on entry. Assertion validChildren(temp, null) might not hold. (BinomialHeap.vpr@596.14--596.39) [101568]"}
              validChildren(Heap, temp_1, null);
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assert {:msg "  Loop invariant 0 < segLength(fakeNode, temp) && 0 < segLength(temp, null) ==> segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not hold on entry. Assertion segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not hold. (BinomialHeap.vpr@597.14--598.95) [101569]"}
                segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            if (fakeNode != temp_1) {
              assert {:msg "  Loop invariant fakeNode != temp ==> segParent(fakeNode, temp) == null might not hold on entry. Assertion segParent(fakeNode, temp) == null might not hold. (BinomialHeap.vpr@599.14--599.68) [101570]"}
                segParent(Heap, fakeNode, temp_1) == null;
            }
            assert {:msg "  Loop invariant segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not hold on entry. Assertion segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not hold. (BinomialHeap.vpr@600.14--600.78) [101571]"}
              segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
        
        // -- Havoc loop written variables (except locals)
          havoc temp_1, prevTemp;
          assume Heap[temp_1, $allocated];
          assume Heap[prevTemp, $allocated];
        
        // -- Check definedness of invariant
          if (*) {
            perm := FullPerm;
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of validChildren(fakeNode, temp)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@595.14--595.43) [101572]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume validChildren(Heap, fakeNode, temp_1);
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of validChildren(temp, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function validChildren might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@596.14--596.39) [101573]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume validChildren(Heap, temp_1, null);
            assume state(Heap, Mask);
            
            // -- Check definedness of 0 < segLength(fakeNode, temp) && 0 < segLength(temp, null)
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@597.18--597.43) [101574]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (0 < segLength(Heap, fakeNode, temp_1)) {
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@597.51--597.72) [101575]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              }
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segLength might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@598.33--598.58) [101576]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@598.7--598.63) [101577]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 <= segLength(fakeNode, temp) - 1 might not hold. (BinomialHeap.vpr@598.7--598.63) [101578]"}
                    0 <= segLength(Heap, fakeNode, temp_1) - 1;
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion segLength(fakeNode, temp) - 1 < segLength(fakeNode, temp) might not hold. (BinomialHeap.vpr@598.7--598.63) [101579]"}
                    segLength(Heap, fakeNode, temp_1) - 1 < segLength(Heap, fakeNode, temp_1);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segDegree might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@598.67--598.91) [101580]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                  assert {:msg "  Precondition of function segDegree might not hold. Assertion 0 < segLength(temp, null) might not hold. (BinomialHeap.vpr@598.67--598.91) [101581]"}
                    0 < segLength(Heap, temp_1, null);
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            assume state(Heap, Mask);
            if (fakeNode != temp_1) {
              assume state(Heap, Mask);
              
              // -- Check definedness of segParent(fakeNode, temp) == null
                if (*) {
                  // Exhale precondition of function application
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  assert {:msg "  Precondition of function segParent might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@599.35--599.60) [101582]"}
                    NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                  assert {:msg "  Precondition of function segParent might not hold. Assertion fakeNode != temp might not hold. (BinomialHeap.vpr@599.35--599.60) [101583]"}
                    fakeNode != temp_1;
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                  // Stop execution
                  assume false;
                }
              assume segParent(Heap, fakeNode, temp_1) == null;
            }
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            
            // -- Check definedness of segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@600.14--600.37) [101584]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(fakeNode, temp_1)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
              if (*) {
                // Exhale precondition of function application
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                assert {:msg "  Precondition of function segSize might not hold. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@600.40--600.59) [101585]"}
                  NoPerm < perm ==> NoPerm < Mask[null, heapseg(temp_1, null)];
                // Finish exhale
                havoc ExhaleHeap;
                assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                Heap := ExhaleHeap;
                // Stop execution
                assume false;
              }
            assume segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            assume state(Heap, Mask);
            assume false;
          }
        
        // -- Check the loop body
          if (*) {
            // Reset state
            loopHeap := Heap;
            loopMask := Mask;
            Mask := ZeroMask;
            assume state(Heap, Mask);
            // Inhale invariant
            perm := FullPerm;
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
            assume state(Heap, Mask);
            perm := FullPerm;
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
            assume state(Heap, Mask);
            assume state(Heap, Mask);
            assume validChildren(Heap, fakeNode, temp_1);
            assume state(Heap, Mask);
            assume validChildren(Heap, temp_1, null);
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assume state(Heap, Mask);
              assume segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            if (fakeNode != temp_1) {
              assume state(Heap, Mask);
              assume segParent(Heap, fakeNode, temp_1) == null;
            }
            assume state(Heap, Mask);
            assume segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            assume state(Heap, Mask);
            // Check and assume guard
            assume temp_1 != null;
            assume state(Heap, Mask);
            
            // -- Translate loop body
              
              // -- Translating statement: unfold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@602.4--602.30
                assume heapseg#trigger(Heap, heapseg(temp_1, null));
                assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@602.4--602.30) [101586]"}
                    perm <= Mask[null, heapseg(temp_1, null)];
                }
                Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp_1, null):=newVersion];
                  }
                if (temp_1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree(temp_1), Heap[null, tree(temp_1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp_1 != null;
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp_1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: unfold acc(tree(temp), write) -- BinomialHeap.vpr@603.4--603.21
                assume tree#trigger(Heap, tree(temp_1));
                assume Heap[null, tree(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding tree(temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@603.4--603.21) [101587]"}
                    perm <= Mask[null, tree(temp_1)];
                }
                Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, tree(temp_1))) {
                    havoc newVersion;
                    Heap := Heap[null, tree(temp_1):=newVersion];
                  }
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, key:=Mask[temp_1, key] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, degree:=Mask[temp_1, degree] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, child:=Mask[temp_1, child] + perm];
                assume state(Heap, Mask);
                perm := FullPerm;
                assume temp_1 != null;
                Mask := Mask[temp_1, parent:=Mask[temp_1, parent] + perm];
                assume state(Heap, Mask);
                assume 0 <= Heap[temp_1, degree];
                perm := FullPerm;
                Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] + perm];
                
                // -- Extra unfolding of predicate
                  assume InsidePredicate(tree(temp_1), Heap[null, tree(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                if (0 < Heap[temp_1, degree]) {
                  assume state(Heap, Mask);
                  assume segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                }
                assume state(Heap, Mask);
                assume validChildren(Heap, Heap[temp_1, child], null);
                if (Heap[temp_1, child] != null) {
                  assume state(Heap, Mask);
                  assume segParent(Heap, Heap[temp_1, child], null) == temp_1;
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: temp.parent := null -- BinomialHeap.vpr@604.4--604.23
                assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@604.4--604.23) [101588]"}
                  FullPerm == Mask[temp_1, parent];
                Heap := Heap[temp_1, parent:=null];
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(tree(temp), write) -- BinomialHeap.vpr@605.4--605.19
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.key (BinomialHeap.vpr@605.4--605.19) [101589]"}
                    perm <= Mask[temp_1, key];
                }
                Mask := Mask[temp_1, key:=Mask[temp_1, key] - perm];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.degree (BinomialHeap.vpr@605.4--605.19) [101590]"}
                    perm <= Mask[temp_1, degree];
                }
                Mask := Mask[temp_1, degree:=Mask[temp_1, degree] - perm];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.child (BinomialHeap.vpr@605.4--605.19) [101591]"}
                    perm <= Mask[temp_1, child];
                }
                Mask := Mask[temp_1, child:=Mask[temp_1, child] - perm];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access temp.parent (BinomialHeap.vpr@605.4--605.19) [101592]"}
                    perm <= Mask[temp_1, parent];
                }
                Mask := Mask[temp_1, parent:=Mask[temp_1, parent] - perm];
                assert {:msg "  Folding tree(temp) might fail. Assertion 0 <= temp.degree might not hold. (BinomialHeap.vpr@605.4--605.19) [101593]"}
                  0 <= Heap[temp_1, degree];
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Folding tree(temp) might fail. There might be insufficient permission to access heapseg(temp.child, null) (BinomialHeap.vpr@605.4--605.19) [101594]"}
                    perm <= Mask[null, heapseg(Heap[temp_1, child], null)];
                }
                Mask := Mask[null, heapseg(Heap[temp_1, child], null):=Mask[null, heapseg(Heap[temp_1, child], null)] - perm];
                
                // -- Record predicate instance information
                  assume InsidePredicate(tree(temp_1), Heap[null, tree(temp_1)], heapseg(Heap[temp_1, child], null), Heap[null, heapseg(Heap[temp_1, child], null)]);
                assert {:msg "  Folding tree(temp) might fail. Assertion temp.degree == segLength(temp.child, null) might not hold. (BinomialHeap.vpr@605.4--605.19) [101595]"}
                  Heap[temp_1, degree] == segLength(Heap, Heap[temp_1, child], null);
                if (0 < Heap[temp_1, degree]) {
                  assert {:msg "  Folding tree(temp) might fail. Assertion segDegree(temp.child, null, 0) == temp.degree - 1 might not hold. (BinomialHeap.vpr@605.4--605.19) [101596]"}
                    segDegree(Heap, Heap[temp_1, child], null, 0) == Heap[temp_1, degree] - 1;
                }
                assert {:msg "  Folding tree(temp) might fail. Assertion validChildren(temp.child, null) might not hold. (BinomialHeap.vpr@605.4--605.19) [101597]"}
                  validChildren(Heap, Heap[temp_1, child], null);
                if (Heap[temp_1, child] != null) {
                  assert {:msg "  Folding tree(temp) might fail. Assertion segParent(temp.child, null) == temp might not hold. (BinomialHeap.vpr@605.4--605.19) [101598]"}
                    segParent(Heap, Heap[temp_1, child], null) == temp_1;
                }
                perm := FullPerm;
                Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume tree#trigger(Heap, tree(temp_1));
                assume Heap[null, tree(temp_1)] == CombineFrames(FrameFragment(Heap[temp_1, key]), CombineFrames(FrameFragment(Heap[temp_1, degree]), CombineFrames(FrameFragment(Heap[temp_1, child]), CombineFrames(FrameFragment(Heap[temp_1, parent]), CombineFrames(Heap[null, heapseg(Heap[temp_1, child], null)], CombineFrames(FrameFragment((if 0 < Heap[temp_1, degree] then EmptyFrame else EmptyFrame)), FrameFragment((if Heap[temp_1, child] != null then EmptyFrame else EmptyFrame))))))));
                if (!HasDirectPerm(Mask, null, tree(temp_1))) {
                  Heap := Heap[null, tree#sm(temp_1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, tree(temp_1):=freshVersion];
                }
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, key:=true]];
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, degree:=true]];
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, child:=true]];
                Heap := Heap[null, tree#sm(temp_1):=Heap[null, tree#sm(temp_1)][temp_1, parent:=true]];
                havoc newPMask;
                assume (forall <A, B> o_179: Ref, f_180: (Field A B) ::
                  { newPMask[o_179, f_180] }
                  Heap[null, tree#sm(temp_1)][o_179, f_180] || Heap[null, heapseg#sm(Heap[temp_1, child], null)][o_179, f_180] ==> newPMask[o_179, f_180]
                );
                Heap := Heap[null, tree#sm(temp_1):=newPMask];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: prevTemp := temp -- BinomialHeap.vpr@606.4--606.20
                prevTemp := temp_1;
                assume state(Heap, Mask);
              
              // -- Translating statement: temp := temp.sibling -- BinomialHeap.vpr@607.4--607.24
                
                // -- Check definedness of temp.sibling
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@607.4--607.24) [101599]"}
                    HasDirectPerm(Mask, temp_1, sibling);
                temp_1 := Heap[temp_1, sibling];
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp, temp), write) -- BinomialHeap.vpr@608.4--608.28
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp_1 != temp_1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@608.4--608.28) [101600]"}
                      perm <= Mask[null, tree(temp_1)];
                  }
                  Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], tree(temp_1), Heap[null, tree(temp_1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@608.4--608.28) [101601]"}
                      perm <= Mask[temp_1, sibling];
                  }
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. There might be insufficient permission to access heapseg(temp.sibling, temp) (BinomialHeap.vpr@608.4--608.28) [101602]"}
                      perm <= Mask[null, heapseg(Heap[temp_1, sibling], temp_1)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], temp_1):=Mask[null, heapseg(Heap[temp_1, sibling], temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, temp_1), Heap[null, heapseg(temp_1, temp_1)], heapseg(Heap[temp_1, sibling], temp_1), Heap[null, heapseg(Heap[temp_1, sibling], temp_1)]);
                  if (Heap[temp_1, sibling] != temp_1) {
                    assert {:msg "  Folding heapseg(temp, temp) might fail. Assertion treeParent(temp) == segParent(temp.sibling, temp) might not hold. (BinomialHeap.vpr@608.4--608.28) [101603]"}
                      treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], temp_1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, temp_1):=Mask[null, heapseg(temp_1, temp_1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp_1, temp_1));
                assume Heap[null, heapseg(temp_1, temp_1)] == FrameFragment((if temp_1 != temp_1 then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], temp_1)], FrameFragment((if Heap[temp_1, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp_1, temp_1))) {
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp_1, temp_1):=freshVersion];
                }
                if (temp_1 != temp_1) {
                  havoc newPMask;
                  assume (forall <A, B> o_180: Ref, f_181: (Field A B) ::
                    { newPMask[o_180, f_181] }
                    Heap[null, heapseg#sm(temp_1, temp_1)][o_180, f_181] || Heap[null, tree#sm(temp_1)][o_180, f_181] ==> newPMask[o_180, f_181]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=Heap[null, heapseg#sm(temp_1, temp_1)][temp_1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_181: Ref, f_182: (Field A B) ::
                    { newPMask[o_181, f_182] }
                    Heap[null, heapseg#sm(temp_1, temp_1)][o_181, f_182] || Heap[null, heapseg#sm(Heap[temp_1, sibling], temp_1)][o_181, f_182] ==> newPMask[o_181, f_182]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, temp_1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(prevTemp, temp), write) -- BinomialHeap.vpr@609.4--609.32
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (prevTemp != temp_1) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access tree(prevTemp) (BinomialHeap.vpr@609.4--609.32) [101604]"}
                      perm <= Mask[null, tree(prevTemp)];
                  }
                  Mask := Mask[null, tree(prevTemp):=Mask[null, tree(prevTemp)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], tree(prevTemp), Heap[null, tree(prevTemp)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access prevTemp.sibling (BinomialHeap.vpr@609.4--609.32) [101605]"}
                      perm <= Mask[prevTemp, sibling];
                  }
                  Mask := Mask[prevTemp, sibling:=Mask[prevTemp, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. There might be insufficient permission to access heapseg(prevTemp.sibling, temp) (BinomialHeap.vpr@609.4--609.32) [101606]"}
                      perm <= Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)];
                  }
                  Mask := Mask[null, heapseg(Heap[prevTemp, sibling], temp_1):=Mask[null, heapseg(Heap[prevTemp, sibling], temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(prevTemp, temp_1), Heap[null, heapseg(prevTemp, temp_1)], heapseg(Heap[prevTemp, sibling], temp_1), Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)]);
                  if (Heap[prevTemp, sibling] != temp_1) {
                    assert {:msg "  Folding heapseg(prevTemp, temp) might fail. Assertion treeParent(prevTemp) == segParent(prevTemp.sibling, temp) might not hold. (BinomialHeap.vpr@609.4--609.32) [101607]"}
                      treeParent(Heap, prevTemp) == segParent(Heap, Heap[prevTemp, sibling], temp_1);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(prevTemp, temp_1));
                assume Heap[null, heapseg(prevTemp, temp_1)] == FrameFragment((if prevTemp != temp_1 then CombineFrames(Heap[null, tree(prevTemp)], CombineFrames(FrameFragment(Heap[prevTemp, sibling]), CombineFrames(Heap[null, heapseg(Heap[prevTemp, sibling], temp_1)], FrameFragment((if Heap[prevTemp, sibling] != temp_1 then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(prevTemp, temp_1))) {
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(prevTemp, temp_1):=freshVersion];
                }
                if (prevTemp != temp_1) {
                  havoc newPMask;
                  assume (forall <A, B> o_182: Ref, f_183: (Field A B) ::
                    { newPMask[o_182, f_183] }
                    Heap[null, heapseg#sm(prevTemp, temp_1)][o_182, f_183] || Heap[null, tree#sm(prevTemp)][o_182, f_183] ==> newPMask[o_182, f_183]
                  );
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=Heap[null, heapseg#sm(prevTemp, temp_1)][prevTemp, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_183: Ref, f_184: (Field A B) ::
                    { newPMask[o_183, f_184] }
                    Heap[null, heapseg#sm(prevTemp, temp_1)][o_183, f_184] || Heap[null, heapseg#sm(Heap[prevTemp, sibling], temp_1)][o_183, f_184] ==> newPMask[o_183, f_184]
                  );
                  Heap := Heap[null, heapseg#sm(prevTemp, temp_1):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: unfold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@610.4--610.30
                assume heapseg#trigger(Heap, heapseg(temp_1, null));
                assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                perm := FullPerm;
                if (perm != NoPerm) {
                  assert {:msg "  Unfolding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@610.4--610.30) [101608]"}
                    perm <= Mask[null, heapseg(temp_1, null)];
                }
                Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
                
                // -- Update version of predicate
                  if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                    havoc newVersion;
                    Heap := Heap[null, heapseg(temp_1, null):=newVersion];
                  }
                if (temp_1 != null) {
                  perm := FullPerm;
                  Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree(temp_1), Heap[null, tree(temp_1)]);
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  assume temp_1 != null;
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] + perm];
                  assume state(Heap, Mask);
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] + perm];
                  
                  // -- Extra unfolding of predicate
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                  assume state(Heap, Mask);
                  if (Heap[temp_1, sibling] != null) {
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                  }
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: concat(fakeNode, prevTemp, temp) -- BinomialHeap.vpr@611.4--611.36
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(fakeNode, prevTemp) (BinomialHeap.vpr@611.4--611.36) [101609]"}
                      perm <= Mask[null, heapseg(fakeNode, prevTemp)];
                  }
                  Mask := Mask[null, heapseg(fakeNode, prevTemp):=Mask[null, heapseg(fakeNode, prevTemp)] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access heapseg(prevTemp, temp) (BinomialHeap.vpr@611.4--611.36) [101610]"}
                      perm <= Mask[null, heapseg(prevTemp, temp_1)];
                  }
                  Mask := Mask[null, heapseg(prevTemp, temp_1):=Mask[null, heapseg(prevTemp, temp_1)] - perm];
                  if (temp_1 != null) {
                    perm := FullPerm;
                    if (perm != NoPerm) {
                      assert {:msg "  The precondition of method concat might not hold. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@611.4--611.36) [101611]"}
                        perm <= Mask[null, tree(temp_1)];
                    }
                    Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                  }
                  if (fakeNode != prevTemp && prevTemp != temp_1) {
                    assert {:msg "  The precondition of method concat might not hold. Assertion segParent(fakeNode, prevTemp) == segParent(prevTemp, temp) might not hold. (BinomialHeap.vpr@611.4--611.36) [101612]"}
                      segParent(Heap, fakeNode, prevTemp) == segParent(Heap, prevTemp, temp_1);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Inhaling postcondition
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume segLength(Heap, fakeNode, temp_1) == segLength(PreCallHeap, fakeNode, prevTemp) + segLength(PreCallHeap, prevTemp, temp_1);
                  assume state(Heap, Mask);
                  assume (forall i_4_1: int ::
                    { segDegree#frame(Heap[null, heapseg(fakeNode, temp_1)], fakeNode, temp_1, i_4_1) } { segDegree#frame(PreCallHeap[null, heapseg(fakeNode, prevTemp)], fakeNode, prevTemp, i_4_1) }
                    0 <= i_4_1 && i_4_1 < segLength(PreCallHeap, fakeNode, prevTemp) ==> segDegree(Heap, fakeNode, temp_1, i_4_1) == segDegree(PreCallHeap, fakeNode, prevTemp, i_4_1)
                  );
                  assume state(Heap, Mask);
                  assume (forall i_5: int ::
                    { segDegree#frame(Heap[null, heapseg(fakeNode, temp_1)], fakeNode, temp_1, i_5) }
                    segLength(PreCallHeap, fakeNode, prevTemp) <= i_5 && i_5 < segLength(Heap, fakeNode, temp_1) ==> segDegree(Heap, fakeNode, temp_1, i_5) == segDegree(PreCallHeap, prevTemp, temp_1, i_5 - segLength(PreCallHeap, fakeNode, prevTemp))
                  );
                  if (temp_1 != null) {
                    perm := FullPerm;
                    Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume treeDegree(Heap, temp_1) == treeDegree(PreCallHeap, temp_1);
                    assume state(Heap, Mask);
                    assume treeSize(Heap, temp_1) == treeSize(PreCallHeap, temp_1);
                    assume state(Heap, Mask);
                    assume treeParent(Heap, temp_1) == treeParent(PreCallHeap, temp_1);
                  }
                  if (sorted(PreCallHeap, fakeNode, prevTemp) && (sorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, fakeNode, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))) {
                    assume state(Heap, Mask);
                    assume sorted(Heap, fakeNode, temp_1);
                  }
                  if (presorted(PreCallHeap, fakeNode, prevTemp) && (presorted(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, fakeNode, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) <= segDegree(PreCallHeap, prevTemp, temp_1, 0) && ((2 <= segLength(PreCallHeap, fakeNode, prevTemp) && segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) == segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 2) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)) && (2 <= segLength(PreCallHeap, prevTemp, temp_1) && segDegree(PreCallHeap, prevTemp, temp_1, 0) == segDegree(PreCallHeap, prevTemp, temp_1, 1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) < segDegree(PreCallHeap, prevTemp, temp_1, 0)))))) {
                    assume state(Heap, Mask);
                    assume presorted(Heap, fakeNode, temp_1);
                  }
                  if (validChildren(PreCallHeap, fakeNode, prevTemp) && (validChildren(PreCallHeap, prevTemp, temp_1) && (0 < segLength(PreCallHeap, fakeNode, prevTemp) && 0 < segLength(PreCallHeap, prevTemp, temp_1) ==> segDegree(PreCallHeap, fakeNode, prevTemp, segLength(PreCallHeap, fakeNode, prevTemp) - 1) == segDegree(PreCallHeap, prevTemp, temp_1, 0) + 1))) {
                    assume state(Heap, Mask);
                    assume validChildren(Heap, fakeNode, temp_1);
                  }
                  assume state(Heap, Mask);
                  assume segSize(Heap, fakeNode, temp_1) == segSize(PreCallHeap, fakeNode, prevTemp) + segSize(PreCallHeap, prevTemp, temp_1);
                  if (fakeNode != prevTemp) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, fakeNode, temp_1) == segParent(PreCallHeap, fakeNode, prevTemp);
                  }
                  if (prevTemp != temp_1) {
                    assume state(Heap, Mask);
                    assume segParent(Heap, fakeNode, temp_1) == segParent(PreCallHeap, prevTemp, temp_1);
                  }
                  assume state(Heap, Mask);
                assume state(Heap, Mask);
              
              // -- Translating statement: fold acc(heapseg(temp, null), write) -- BinomialHeap.vpr@612.4--612.28
                ExhaleWellDef0Heap := Heap;
                ExhaleWellDef0Mask := Mask;
                if (temp_1 != null) {
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access tree(temp) (BinomialHeap.vpr@612.4--612.28) [101613]"}
                      perm <= Mask[null, tree(temp_1)];
                  }
                  Mask := Mask[null, tree(temp_1):=Mask[null, tree(temp_1)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], tree(temp_1), Heap[null, tree(temp_1)]);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access temp.sibling (BinomialHeap.vpr@612.4--612.28) [101614]"}
                      perm <= Mask[temp_1, sibling];
                  }
                  Mask := Mask[temp_1, sibling:=Mask[temp_1, sibling] - perm];
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. There might be insufficient permission to access heapseg(temp.sibling, null) (BinomialHeap.vpr@612.4--612.28) [101615]"}
                      perm <= Mask[null, heapseg(Heap[temp_1, sibling], null)];
                  }
                  Mask := Mask[null, heapseg(Heap[temp_1, sibling], null):=Mask[null, heapseg(Heap[temp_1, sibling], null)] - perm];
                  
                  // -- Record predicate instance information
                    assume InsidePredicate(heapseg(temp_1, null), Heap[null, heapseg(temp_1, null)], heapseg(Heap[temp_1, sibling], null), Heap[null, heapseg(Heap[temp_1, sibling], null)]);
                  if (Heap[temp_1, sibling] != null) {
                    assert {:msg "  Folding heapseg(temp, null) might fail. Assertion treeParent(temp) == segParent(temp.sibling, null) might not hold. (BinomialHeap.vpr@612.4--612.28) [101616]"}
                      treeParent(Heap, temp_1) == segParent(Heap, Heap[temp_1, sibling], null);
                  }
                }
                perm := FullPerm;
                Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
                assume state(Heap, Mask);
                assume state(Heap, Mask);
                assume heapseg#trigger(Heap, heapseg(temp_1, null));
                assume Heap[null, heapseg(temp_1, null)] == FrameFragment((if temp_1 != null then CombineFrames(Heap[null, tree(temp_1)], CombineFrames(FrameFragment(Heap[temp_1, sibling]), CombineFrames(Heap[null, heapseg(Heap[temp_1, sibling], null)], FrameFragment((if Heap[temp_1, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                if (!HasDirectPerm(Mask, null, heapseg(temp_1, null))) {
                  Heap := Heap[null, heapseg#sm(temp_1, null):=ZeroPMask];
                  havoc freshVersion;
                  Heap := Heap[null, heapseg(temp_1, null):=freshVersion];
                }
                if (temp_1 != null) {
                  havoc newPMask;
                  assume (forall <A, B> o_184: Ref, f_185: (Field A B) ::
                    { newPMask[o_184, f_185] }
                    Heap[null, heapseg#sm(temp_1, null)][o_184, f_185] || Heap[null, tree#sm(temp_1)][o_184, f_185] ==> newPMask[o_184, f_185]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                  Heap := Heap[null, heapseg#sm(temp_1, null):=Heap[null, heapseg#sm(temp_1, null)][temp_1, sibling:=true]];
                  havoc newPMask;
                  assume (forall <A, B> o_185: Ref, f_186: (Field A B) ::
                    { newPMask[o_185, f_186] }
                    Heap[null, heapseg#sm(temp_1, null)][o_185, f_186] || Heap[null, heapseg#sm(Heap[temp_1, sibling], null)][o_185, f_186] ==> newPMask[o_185, f_186]
                  );
                  Heap := Heap[null, heapseg#sm(temp_1, null):=newPMask];
                }
                assume state(Heap, Mask);
                assume state(Heap, Mask);
            // Exhale invariant
            ExhaleWellDef0Heap := Heap;
            ExhaleWellDef0Mask := Mask;
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(fakeNode, temp), write) might not be preserved. There might be insufficient permission to access heapseg(fakeNode, temp) (BinomialHeap.vpr@593.14--593.37) [101617]"}
                perm <= Mask[null, heapseg(fakeNode, temp_1)];
            }
            Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] - perm];
            perm := FullPerm;
            if (perm != NoPerm) {
              assert {:msg "  Loop invariant acc(heapseg(temp, null), write) might not be preserved. There might be insufficient permission to access heapseg(temp, null) (BinomialHeap.vpr@594.14--594.33) [101618]"}
                perm <= Mask[null, heapseg(temp_1, null)];
            }
            Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] - perm];
            assert {:msg "  Loop invariant validChildren(fakeNode, temp) might not be preserved. Assertion validChildren(fakeNode, temp) might not hold. (BinomialHeap.vpr@595.14--595.43) [101619]"}
              validChildren(Heap, fakeNode, temp_1);
            assert {:msg "  Loop invariant validChildren(temp, null) might not be preserved. Assertion validChildren(temp, null) might not hold. (BinomialHeap.vpr@596.14--596.39) [101620]"}
              validChildren(Heap, temp_1, null);
            if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
              assert {:msg "  Loop invariant 0 < segLength(fakeNode, temp) && 0 < segLength(temp, null) ==> segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not be preserved. Assertion segDegree(fakeNode, temp, segLength(fakeNode, temp) - 1) == segDegree(temp, null, 0) + 1 might not hold. (BinomialHeap.vpr@597.14--598.95) [101621]"}
                segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
            }
            if (fakeNode != temp_1) {
              assert {:msg "  Loop invariant fakeNode != temp ==> segParent(fakeNode, temp) == null might not be preserved. Assertion segParent(fakeNode, temp) == null might not hold. (BinomialHeap.vpr@599.14--599.68) [101622]"}
                segParent(Heap, fakeNode, temp_1) == null;
            }
            assert {:msg "  Loop invariant segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not be preserved. Assertion segSize(fakeNode, temp) + segSize(temp, null) == oldTreeSize - 1 might not hold. (BinomialHeap.vpr@600.14--600.78) [101623]"}
              segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
            // Finish exhale
            havoc ExhaleHeap;
            assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
            Heap := ExhaleHeap;
            // Terminate execution
            assume false;
          }
        
        // -- Inhale loop invariant after loop, and assume guard
          assume !(temp_1 != null);
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(fakeNode, temp_1):=Mask[null, heapseg(fakeNode, temp_1)] + perm];
          assume state(Heap, Mask);
          perm := FullPerm;
          Mask := Mask[null, heapseg(temp_1, null):=Mask[null, heapseg(temp_1, null)] + perm];
          assume state(Heap, Mask);
          assume state(Heap, Mask);
          assume validChildren(Heap, fakeNode, temp_1);
          assume state(Heap, Mask);
          assume validChildren(Heap, temp_1, null);
          if (0 < segLength(Heap, fakeNode, temp_1) && 0 < segLength(Heap, temp_1, null)) {
            assume state(Heap, Mask);
            assume segDegree(Heap, fakeNode, temp_1, segLength(Heap, fakeNode, temp_1) - 1) == segDegree(Heap, temp_1, null, 0) + 1;
          }
          if (fakeNode != temp_1) {
            assume state(Heap, Mask);
            assume segParent(Heap, fakeNode, temp_1) == null;
          }
          assume state(Heap, Mask);
          assume segSize(Heap, fakeNode, temp_1) + segSize(Heap, temp_1, null) == oldTreeSize - 1;
          assume state(Heap, Mask);
        assume state(Heap, Mask);
      
      // -- Translating statement: if (this.Nodes == null && fakeNode == null) -- BinomialHeap.vpr@616.3--636.4
        
        // -- Check definedness of this.Nodes == null && fakeNode == null
          assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@616.6--616.47) [101624]"}
            HasDirectPerm(Mask, this, Nodes);
        if (Heap[this, Nodes] == null && fakeNode == null) {
          
          // -- Translating statement: this.size := 0 -- BinomialHeap.vpr@617.4--617.18
            assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@617.4--617.18) [101625]"}
              FullPerm == Mask[this, size];
            Heap := Heap[this, size:=0];
            assume state(Heap, Mask);
        } else {
          
          // -- Translating statement: if (this.Nodes == null && fakeNode != null) -- BinomialHeap.vpr@619.4--635.5
            
            // -- Check definedness of this.Nodes == null && fakeNode != null
              assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@619.7--619.48) [101626]"}
                HasDirectPerm(Mask, this, Nodes);
            if (Heap[this, Nodes] == null && fakeNode != null) {
              
              // -- Translating statement: r := reverse2(fakeNode, null) -- BinomialHeap.vpr@622.5--622.34
                PreCallHeap := Heap;
                PreCallMask := Mask;
                
                // -- Exhaling precondition
                  ExhaleWellDef0Heap := Heap;
                  ExhaleWellDef0Mask := Mask;
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(fakeNode, null) (BinomialHeap.vpr@622.5--622.34) [101627]"}
                      perm <= Mask[null, heapseg(fakeNode, null)];
                  }
                  Mask := Mask[null, heapseg(fakeNode, null):=Mask[null, heapseg(fakeNode, null)] - perm];
                  assert {:msg "  The precondition of method reverse2 might not hold. Assertion validChildren(fakeNode, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [101628]"}
                    validChildren(Heap, fakeNode, null);
                  assert {:msg "  The precondition of method reverse2 might not hold. Assertion 0 < segLength(fakeNode, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [101629]"}
                    0 < segLength(Heap, fakeNode, null);
                  perm := FullPerm;
                  if (perm != NoPerm) {
                    assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(null, null) (BinomialHeap.vpr@622.5--622.34) [101630]"}
                      perm <= Mask[null, heapseg(null, null)];
                  }
                  Mask := Mask[null, heapseg(null, null):=Mask[null, heapseg(null, null)] - perm];
                  assert {:msg "  The precondition of method reverse2 might not hold. Assertion sorted(null, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [101631]"}
                    sorted(Heap, null, null);
                  if (null != null) {
                    assert {:msg "  The precondition of method reverse2 might not hold. Assertion segDegree(fakeNode, null, 0) < segDegree(null, null, 0) might not hold. (BinomialHeap.vpr@622.5--622.34) [101632]"}
                      segDegree(Heap, fakeNode, null, 0) < segDegree(Heap, null, null, 0);
                  }
                  if (null != null) {
                    assert {:msg "  The precondition of method reverse2 might not hold. Assertion segParent(fakeNode, null) == segParent(null, null) might not hold. (BinomialHeap.vpr@622.5--622.34) [101633]"}
                      segParent(Heap, fakeNode, null) == segParent(Heap, null, null);
                  }
                  // Finish exhale
                  havoc ExhaleHeap;
                  assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                  Heap := ExhaleHeap;
                
                // -- Havocing target variables
                  havoc r_1;
                
                // -- Inhaling postcondition
                  assume r_1 != null;
                  perm := FullPerm;
                  Mask := Mask[null, heapseg(r_1, null):=Mask[null, heapseg(r_1, null)] + perm];
                  assume state(Heap, Mask);
                  assume state(Heap, Mask);
                  assume sorted(Heap, r_1, null);
                  assume state(Heap, Mask);
                  assume segSize(Heap, r_1, null) == segSize(PreCallHeap, fakeNode, null) + segSize(PreCallHeap, null, null);
                  assume state(Heap, Mask);
                  assume segParent(Heap, r_1, null) == segParent(PreCallHeap, fakeNode, null);
                  assume state(Heap, Mask);
                assume Heap[r_1, $allocated];
                assume state(Heap, Mask);
              
              // -- Translating statement: this.Nodes := r -- BinomialHeap.vpr@623.5--623.20
                assert {:msg "  Assignment might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@623.5--623.20) [101634]"}
                  FullPerm == Mask[this, Nodes];
                Heap := Heap[this, Nodes:=r_1];
                assume state(Heap, Mask);
              
              // -- Translating statement: this.size := this.size - 1 -- BinomialHeap.vpr@624.5--624.31
                
                // -- Check definedness of this.size - 1
                  assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@624.5--624.31) [101635]"}
                    HasDirectPerm(Mask, this, size);
                assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@624.5--624.31) [101636]"}
                  FullPerm == Mask[this, size];
                Heap := Heap[this, size:=Heap[this, size] - 1];
                assume state(Heap, Mask);
            } else {
              
              // -- Translating statement: if (this.Nodes != null && fakeNode == null) -- BinomialHeap.vpr@626.5--634.6
                
                // -- Check definedness of this.Nodes != null && fakeNode == null
                  assert {:msg "  Conditional statement might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@626.8--626.49) [101637]"}
                    HasDirectPerm(Mask, this, Nodes);
                if (Heap[this, Nodes] != null && fakeNode == null) {
                  
                  // -- Translating statement: this.size := this.size - 1 -- BinomialHeap.vpr@628.6--628.32
                    
                    // -- Check definedness of this.size - 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@628.6--628.32) [101638]"}
                        HasDirectPerm(Mask, this, size);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@628.6--628.32) [101639]"}
                      FullPerm == Mask[this, size];
                    Heap := Heap[this, size:=Heap[this, size] - 1];
                    assume state(Heap, Mask);
                } else {
                  
                  // -- Translating statement: fold acc(heapseg(null, null), write) -- BinomialHeap.vpr@630.6--630.30
                    ExhaleWellDef0Heap := Heap;
                    ExhaleWellDef0Mask := Mask;
                    if (null != null) {
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(null, null) might fail. There might be insufficient permission to access tree(null) (BinomialHeap.vpr@630.6--630.30) [101642]"}
                          perm <= Mask[null, tree(null)];
                      }
                      Mask := Mask[null, tree(null):=Mask[null, tree(null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(null, null), Heap[null, heapseg(null, null)], tree(null), Heap[null, tree(null)]);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(null, null) might fail. There might be insufficient permission to access null.sibling (BinomialHeap.vpr@630.6--630.30) [101644]"}
                          perm <= Mask[null, sibling];
                      }
                      Mask := Mask[null, sibling:=Mask[null, sibling] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  Folding heapseg(null, null) might fail. There might be insufficient permission to access heapseg(null.sibling, null) (BinomialHeap.vpr@630.6--630.30) [101646]"}
                          perm <= Mask[null, heapseg(Heap[null, sibling], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[null, sibling], null):=Mask[null, heapseg(Heap[null, sibling], null)] - perm];
                      
                      // -- Record predicate instance information
                        assume InsidePredicate(heapseg(null, null), Heap[null, heapseg(null, null)], heapseg(Heap[null, sibling], null), Heap[null, heapseg(Heap[null, sibling], null)]);
                      if (Heap[null, sibling] != null) {
                        assert {:msg "  Folding heapseg(null, null) might fail. Assertion treeParent(null) == segParent(null.sibling, null) might not hold. (BinomialHeap.vpr@630.6--630.30) [101647]"}
                          treeParent(Heap, null) == segParent(Heap, Heap[null, sibling], null);
                      }
                    }
                    perm := FullPerm;
                    Mask := Mask[null, heapseg(null, null):=Mask[null, heapseg(null, null)] + perm];
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                    assume heapseg#trigger(Heap, heapseg(null, null));
                    assume Heap[null, heapseg(null, null)] == FrameFragment((if null != null then CombineFrames(Heap[null, tree(null)], CombineFrames(FrameFragment(Heap[null, sibling]), CombineFrames(Heap[null, heapseg(Heap[null, sibling], null)], FrameFragment((if Heap[null, sibling] != null then EmptyFrame else EmptyFrame))))) else EmptyFrame));
                    if (!HasDirectPerm(Mask, null, heapseg(null, null))) {
                      Heap := Heap[null, heapseg#sm(null, null):=ZeroPMask];
                      havoc freshVersion;
                      Heap := Heap[null, heapseg(null, null):=freshVersion];
                    }
                    if (null != null) {
                      havoc newPMask;
                      assume (forall <A, B> o_186: Ref, f_187: (Field A B) ::
                        { newPMask[o_186, f_187] }
                        Heap[null, heapseg#sm(null, null)][o_186, f_187] || Heap[null, tree#sm(null)][o_186, f_187] ==> newPMask[o_186, f_187]
                      );
                      Heap := Heap[null, heapseg#sm(null, null):=newPMask];
                      Heap := Heap[null, heapseg#sm(null, null):=Heap[null, heapseg#sm(null, null)][null, sibling:=true]];
                      havoc newPMask;
                      assume (forall <A, B> o_187: Ref, f_188: (Field A B) ::
                        { newPMask[o_187, f_188] }
                        Heap[null, heapseg#sm(null, null)][o_187, f_188] || Heap[null, heapseg#sm(Heap[null, sibling], null)][o_187, f_188] ==> newPMask[o_187, f_188]
                      );
                      Heap := Heap[null, heapseg#sm(null, null):=newPMask];
                    }
                    assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: r := reverse2(fakeNode, null) -- BinomialHeap.vpr@631.6--631.35
                    PreCallHeap := Heap;
                    PreCallMask := Mask;
                    
                    // -- Exhaling precondition
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(fakeNode, null) (BinomialHeap.vpr@631.6--631.35) [101649]"}
                          perm <= Mask[null, heapseg(fakeNode, null)];
                      }
                      Mask := Mask[null, heapseg(fakeNode, null):=Mask[null, heapseg(fakeNode, null)] - perm];
                      assert {:msg "  The precondition of method reverse2 might not hold. Assertion validChildren(fakeNode, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [101650]"}
                        validChildren(Heap, fakeNode, null);
                      assert {:msg "  The precondition of method reverse2 might not hold. Assertion 0 < segLength(fakeNode, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [101651]"}
                        0 < segLength(Heap, fakeNode, null);
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method reverse2 might not hold. There might be insufficient permission to access heapseg(null, null) (BinomialHeap.vpr@631.6--631.35) [101652]"}
                          perm <= Mask[null, heapseg(null, null)];
                      }
                      Mask := Mask[null, heapseg(null, null):=Mask[null, heapseg(null, null)] - perm];
                      assert {:msg "  The precondition of method reverse2 might not hold. Assertion sorted(null, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [101653]"}
                        sorted(Heap, null, null);
                      if (null != null) {
                        assert {:msg "  The precondition of method reverse2 might not hold. Assertion segDegree(fakeNode, null, 0) < segDegree(null, null, 0) might not hold. (BinomialHeap.vpr@631.6--631.35) [101654]"}
                          segDegree(Heap, fakeNode, null, 0) < segDegree(Heap, null, null, 0);
                      }
                      if (null != null) {
                        assert {:msg "  The precondition of method reverse2 might not hold. Assertion segParent(fakeNode, null) == segParent(null, null) might not hold. (BinomialHeap.vpr@631.6--631.35) [101655]"}
                          segParent(Heap, fakeNode, null) == segParent(Heap, null, null);
                      }
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                    
                    // -- Havocing target variables
                      havoc r_1;
                    
                    // -- Inhaling postcondition
                      assume r_1 != null;
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(r_1, null):=Mask[null, heapseg(r_1, null)] + perm];
                      assume state(Heap, Mask);
                      assume state(Heap, Mask);
                      assume sorted(Heap, r_1, null);
                      assume state(Heap, Mask);
                      assume segSize(Heap, r_1, null) == segSize(PreCallHeap, fakeNode, null) + segSize(PreCallHeap, null, null);
                      assume state(Heap, Mask);
                      assume segParent(Heap, r_1, null) == segParent(PreCallHeap, fakeNode, null);
                      assume state(Heap, Mask);
                    assume Heap[r_1, $allocated];
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: unionNodes(this, r) -- BinomialHeap.vpr@632.6--632.25
                    PreCallHeap := Heap;
                    PreCallMask := Mask;
                    
                    // -- Exhaling precondition
                      ExhaleWellDef0Heap := Heap;
                      ExhaleWellDef0Mask := Mask;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method unionNodes might not hold. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@632.6--632.25) [101656]"}
                          perm <= Mask[this, Nodes];
                      }
                      Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method unionNodes might not hold. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@632.6--632.25) [101657]"}
                          perm <= Mask[null, heapseg(Heap[this, Nodes], null)];
                      }
                      Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] - perm];
                      assert {:msg "  The precondition of method unionNodes might not hold. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@632.6--632.25) [101658]"}
                        sorted(Heap, Heap[this, Nodes], null);
                      assert {:msg "  The precondition of method unionNodes might not hold. Assertion this.Nodes != null might not hold. (BinomialHeap.vpr@632.6--632.25) [101659]"}
                        Heap[this, Nodes] != null;
                      perm := FullPerm;
                      if (perm != NoPerm) {
                        assert {:msg "  The precondition of method unionNodes might not hold. There might be insufficient permission to access heapseg(r, null) (BinomialHeap.vpr@632.6--632.25) [101660]"}
                          perm <= Mask[null, heapseg(r_1, null)];
                      }
                      Mask := Mask[null, heapseg(r_1, null):=Mask[null, heapseg(r_1, null)] - perm];
                      assert {:msg "  The precondition of method unionNodes might not hold. Assertion sorted(r, null) might not hold. (BinomialHeap.vpr@632.6--632.25) [101661]"}
                        sorted(Heap, r_1, null);
                      if (r_1 != null) {
                        assert {:msg "  The precondition of method unionNodes might not hold. Assertion segParent(this.Nodes, null) == segParent(r, null) might not hold. (BinomialHeap.vpr@632.6--632.25) [101662]"}
                          segParent(Heap, Heap[this, Nodes], null) == segParent(Heap, r_1, null);
                      }
                      // Finish exhale
                      havoc ExhaleHeap;
                      assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
                      Heap := ExhaleHeap;
                    
                    // -- Inhaling postcondition
                      perm := FullPerm;
                      assume this != null;
                      Mask := Mask[this, Nodes:=Mask[this, Nodes] + perm];
                      assume state(Heap, Mask);
                      perm := FullPerm;
                      Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] + perm];
                      assume state(Heap, Mask);
                      assume state(Heap, Mask);
                      assume sorted(Heap, Heap[this, Nodes], null);
                      assume Heap[this, Nodes] != null;
                      assume state(Heap, Mask);
                      assume segSize(Heap, Heap[this, Nodes], null) == segSize(PreCallHeap, PreCallHeap[this, Nodes], null) + segSize(PreCallHeap, r_1, null);
                      assume state(Heap, Mask);
                      assume segParent(Heap, Heap[this, Nodes], null) == segParent(PreCallHeap, PreCallHeap[this, Nodes], null);
                      assume state(Heap, Mask);
                    assume state(Heap, Mask);
                  
                  // -- Translating statement: this.size := this.size - 1 -- BinomialHeap.vpr@633.6--633.32
                    
                    // -- Check definedness of this.size - 1
                      assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@633.6--633.32) [101663]"}
                        HasDirectPerm(Mask, this, size);
                    assert {:msg "  Assignment might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@633.6--633.32) [101664]"}
                      FullPerm == Mask[this, size];
                    Heap := Heap[this, size:=Heap[this, size] - 1];
                    assume state(Heap, Mask);
                }
                assume state(Heap, Mask);
            }
            assume state(Heap, Mask);
        }
        assume state(Heap, Mask);
      
      // -- Translating statement: res := minNode -- BinomialHeap.vpr@638.3--638.17
        res := minNode;
        assume state(Heap, Mask);
    }
    assume state(Heap, Mask);
  
  // -- Translating statement: fold acc(heap(this), write) -- BinomialHeap.vpr@640.2--640.17
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Folding heap(this) might fail. There might be insufficient permission to access this.Nodes (BinomialHeap.vpr@640.2--640.17) [101667]"}
        perm <= Mask[this, Nodes];
    }
    Mask := Mask[this, Nodes:=Mask[this, Nodes] - perm];
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Folding heap(this) might fail. There might be insufficient permission to access heapseg(this.Nodes, null) (BinomialHeap.vpr@640.2--640.17) [101669]"}
        perm <= Mask[null, heapseg(Heap[this, Nodes], null)];
    }
    Mask := Mask[null, heapseg(Heap[this, Nodes], null):=Mask[null, heapseg(Heap[this, Nodes], null)] - perm];
    
    // -- Record predicate instance information
      assume InsidePredicate(heap_1(this), Heap[null, heap_1(this)], heapseg(Heap[this, Nodes], null), Heap[null, heapseg(Heap[this, Nodes], null)]);
    assert {:msg "  Folding heap(this) might fail. Assertion sorted(this.Nodes, null) might not hold. (BinomialHeap.vpr@640.2--640.17) [101670]"}
      sorted(Heap, Heap[this, Nodes], null);
    if (Heap[this, Nodes] != null) {
      assert {:msg "  Folding heap(this) might fail. Assertion segParent(this.Nodes, null) == null might not hold. (BinomialHeap.vpr@640.2--640.17) [101671]"}
        segParent(Heap, Heap[this, Nodes], null) == null;
    }
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Folding heap(this) might fail. There might be insufficient permission to access this.size (BinomialHeap.vpr@640.2--640.17) [101673]"}
        perm <= Mask[this, size];
    }
    Mask := Mask[this, size:=Mask[this, size] - perm];
    assert {:msg "  Folding heap(this) might fail. Assertion this.size == segSize(this.Nodes, null) might not hold. (BinomialHeap.vpr@640.2--640.17) [101674]"}
      Heap[this, size] == segSize(Heap, Heap[this, Nodes], null);
    perm := FullPerm;
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] + perm];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
    assume heap#trigger(Heap, heap_1(this));
    assume Heap[null, heap_1(this)] == CombineFrames(FrameFragment(Heap[this, Nodes]), CombineFrames(Heap[null, heapseg(Heap[this, Nodes], null)], CombineFrames(FrameFragment((if Heap[this, Nodes] != null then EmptyFrame else EmptyFrame)), FrameFragment(Heap[this, size]))));
    if (!HasDirectPerm(Mask, null, heap_1(this))) {
      Heap := Heap[null, heap#sm(this):=ZeroPMask];
      havoc freshVersion;
      Heap := Heap[null, heap_1(this):=freshVersion];
    }
    Heap := Heap[null, heap#sm(this):=Heap[null, heap#sm(this)][this, Nodes:=true]];
    havoc newPMask;
    assume (forall <A, B> o_188: Ref, f_189: (Field A B) ::
      { newPMask[o_188, f_189] }
      Heap[null, heap#sm(this)][o_188, f_189] || Heap[null, heapseg#sm(Heap[this, Nodes], null)][o_188, f_189] ==> newPMask[o_188, f_189]
    );
    Heap := Heap[null, heap#sm(this):=newPMask];
    Heap := Heap[null, heap#sm(this):=Heap[null, heap#sm(this)][this, size:=true]];
    assume state(Heap, Mask);
    assume state(Heap, Mask);
  
  // -- Exhaling postcondition
    ExhaleWellDef0Heap := Heap;
    ExhaleWellDef0Mask := Mask;
    perm := FullPerm;
    if (perm != NoPerm) {
      assert {:msg "  Postcondition of extractMin might not hold. There might be insufficient permission to access heap(this) (BinomialHeap.vpr@530.10--530.20) [101676]"}
        perm <= Mask[null, heap_1(this)];
    }
    Mask := Mask[null, heap_1(this):=Mask[null, heap_1(this)] - perm];
    // Finish exhale
    havoc ExhaleHeap;
    assume IdenticalOnKnownLocations(Heap, ExhaleHeap, Mask);
    Heap := ExhaleHeap;
}